<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>梦幻泡影</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="success&#x3D;persistence">
<meta property="og:type" content="website">
<meta property="og:title" content="梦幻泡影">
<meta property="og:url" content="https://wiwiyiyi.com/page/9/index.html">
<meta property="og:site_name" content="梦幻泡影">
<meta property="og:description" content="success&#x3D;persistence">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EngineerOfFinger">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="梦幻泡影" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wiwi.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦幻泡影</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/%20%7C%7C%20fas%20fa-home">主页</a>
        
          <a class="main-nav-link" href="/archives/%20%7C%7C%20fas%20fa-archive">时间轴</a>
        
          <a class="main-nav-link" href="/tags/%20%7C%7C%20fas%20fa-tags">标签</a>
        
          <a class="main-nav-link" href="/categories/%20%7C%7C%20fas%20fa-folder-open">分类</a>
        
          <a class="main-nav-link" href="/link/%20%7C%7C%20fas%20fa-link">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wiwiyiyi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-服务的基本使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html" class="article-date">
  <time datetime="2021-03-03T02:40:32.000Z" itemprop="datePublished">2021-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html">服务的基本使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天了解了Android四大组件之一的Service-服务，它可以在后台长时间运行操作，处理网络事物以及耗时的IO任务等，包括前台和后台两种，前台主要创建通知提示用户，当你打开允许应用后台运行的权限后，清理掉应用仍然可以执行后台任务，下面分别进行介绍</p>
</blockquote>
<h3 id="二-后台服务"><a href="#二-后台服务" class="headerlink" title="二.后台服务"></a>二.后台服务</h3><ol>
<li><p>首先创建服务</p>
<p>推荐直接创建一个服务类，而不要创建一个类继承自Service，前者可以在Manifests中进行注册</p>
</li>
<li><p>重写生命周期方法</p>
<p>Service和Activity有相似的生命周期</p>
<p>onCreate：首次被创建时触发</p>
<p>onStartCommand：启动服务时触发(内部包含onStart方法)</p>
<p>onDestroy：销毁时触发</p>
<p>onBind：绑定服务时触发</p>
<p>onUnbind：解除绑定</p>
<p>onRebind：重新绑定</p>
<blockquote>
<p>以上必须重写的是<code>onBind()</code>方法，多个Activity可以同时绑定同一个服务，达到共享资源，实现服务器-客户端模式</p>
</blockquote>
</li>
</ol>
<p><strong>通过Intent来启动一个服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent(this,MyService::class.java).also &#123;</span><br><span class="line">            startService(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务的取消也需要通过Intent</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent(this,MyService::class.java).also &#123;</span><br><span class="line">             stopService(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们没有手动停止服务，退出应用进入后台时，服务仍然可以进行，交给系统来管理，当内存比较吃紧的时候会终止服务</p>
</blockquote>
<ol start="3">
<li><p> 为了能够使用LiveData观察以及搭配使用Coroutine，可以使用<code>LifecycleService</code></p>
</li>
<li><p>绑定服务：用于在Activity中反向取出Service中的数据</p>
<p>通过<code>bindService()</code>来绑定服务，需要传入三个参数</p>
<p>Intent、ServiceConnection(接口)、Int</p>
<p>为了能够返回Service的引用，需要创建一个内部类保存当前Service的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class MyService : LifecycleService() &#123;</span><br><span class="line">    val numBerLiveData = MutableLiveData(0)</span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line">    inner class MyBinder:Binder()&#123;</span><br><span class="line">        val service = this@MyService</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onBind(intent: Intent): IBinder &#123;</span><br><span class="line">        super.onBind(intent)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                delay(1000)</span><br><span class="line">                numBerLiveData.value = numBerLiveData.value?.plus(1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return MyBinder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">val bindServiceIntent = Intent(this,MyService::class.java)</span><br><span class="line">val serviceConn = object :ServiceConnection&#123;</span><br><span class="line">            override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123;</span><br><span class="line">                //绑定成功之后，通过第二个参数可以获取到Service的一个引用</span><br><span class="line">                (p1 as MyService.MyBinder).service.numBerLiveData.observe(this@MainActivity)&#123;</span><br><span class="line">                    showText.text = it.toString()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onServiceDisconnected(p0: ComponentName?) &#123;</span><br><span class="line">                //取消绑定时</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">bindService(bindServiceIntent,serviceConn,Context.BIND_AUTO_CREATE)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在MainActivity可以观察MyService内部的LiveData，并刷新界面，如果另一个Activity也绑定该服务，则他们共享数据</p>
</blockquote>
</li>
</ol>
<h3 id="三-前台服务"><a href="#三-前台服务" class="headerlink" title="三.前台服务"></a>三.前台服务</h3><p>上面提到的后台服务对于用户来说是没有任何提示的，并且很容易被系统杀死，前台服务主要使用通过创建通知与用户交互，在Android 8.0以后创建通知需要一下三个步骤</p>
<ol>
<li><p>创建通知渠道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private fun createNotificationChannel() &#123;</span><br><span class="line">       if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">           val name = &quot;前台通知Test&quot;</span><br><span class="line">           val importance = NotificationManager.IMPORTANCE_HIGH</span><br><span class="line">           val channel = NotificationChannel(CHANNEL_ID, name, importance)</span><br><span class="line">           val notificationManager: NotificationManager =</span><br><span class="line">               getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">           notificationManager.createNotificationChannel(channel)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建通知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val notification = NotificationCompat.Builder(this, CHANNEL_ID)</span><br><span class="line">           .setContentTitle(&quot;Hello&quot;)</span><br><span class="line">           .setContentText(&quot;今日第一次测试&quot;)</span><br><span class="line">           .setSmallIcon(R.drawable.ic_launcher_foreground)</span><br><span class="line">           .build()</span><br></pre></td></tr></table></figure></li>
<li><p>启动前台服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startForeground(1,notification)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意启动前台服务函数的第一个参数不能是0，否则不会弹出通知，另外一个问题是，在模拟器上运行即使是清理了App，前台服务依旧存在，但在真机上不行，因为Android厂商不允许这些应用在后台运行以及自启动，除非手动打开权限或者将app加入白名单</p>
</blockquote>
</li>
</ol>
<p><strong>按照常理来说，当我们点击通知后可以跳转到app内，只需要在创建通知的时候设置Intent</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val pendingIntent = PendingIntent.getActivity(</span><br><span class="line">            this,</span><br><span class="line">            0,</span><br><span class="line">            Intent(this,MainActivity::class.java),</span><br><span class="line">            0</span><br><span class="line">        )</span><br><span class="line">setContentIntent(pendingIntent)        </span><br></pre></td></tr></table></figure>

<p><strong>整体效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%9C%8D%E5%8A%A1show.gif" style="zoom:40%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>服务作为四大组件之一，但不是每个项目都必须的，因为耗时任务可以放在Coroutine中执行，目前了解怎么使用即可</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html" data-id="clchki9l6005vt0qh6p0o5rgi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-列表加载更多" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A.html" class="article-date">
  <time datetime="2021-02-25T09:05:52.000Z" itemprop="datePublished">2021-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A.html">列表加载更多</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>对于列表页面，每当我们滑到底时总会出现加载更多的字样并且搭配一个旋转中的图标，然后便会请求网络加载数据，当数据加载成功并展示时，字样会消失，这便是<strong>加载更多</strong>，各大软件也频繁使用，下面介绍两种实现方式</p>
</blockquote>
<h3 id="二-方式一：普通方式"><a href="#二-方式一：普通方式" class="headerlink" title="二.方式一：普通方式"></a>二.方式一：普通方式</h3><blockquote>
<p>使用普通方式的缺点是代码逻辑繁琐，下面简述一下步骤：</p>
</blockquote>
<ol>
<li><p>首先肯定从界面入手，增加一个布局文件作为末尾<strong>加载更多</strong>的布局，在Adapter中增加<strong>ItemView</strong>的数量，然后在解析单个Item时通过<code>viewType</code>判断处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun getItemViewType(position: Int): Int &#123;</span><br><span class="line">        return if (position == itemCount - 1) FOOTER_VIEW_TYPE else NORMAL_VIEW_TYPE</span><br><span class="line">    &#125;</span><br><span class="line">override fun getItemCount(): Int &#123;</span><br><span class="line">        return super.getItemCount() + 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其次是数据层面，此实例中使用的是<code>ViewModel</code>管理以及获取数据，但对于数据的获取有两种形式，一是全部重新获取，二是在原来的基础上继续获取即加载更多数据，其实本质只需提供一个真正去加载数据的方法，全部重新获取即数据重置，然后再去加载更多数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">fun resetQuery()&#123;</span><br><span class="line">        currentPage = 1</span><br><span class="line">        totalPage = 1</span><br><span class="line">        currentKey = keywords.random()</span><br><span class="line">        isNewQuery = true</span><br><span class="line">        needToScrollToTop = true</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;</span><br><span class="line">fun fetchData()&#123;</span><br><span class="line">        if (isLoading) return</span><br><span class="line">        if (currentPage&gt;totalPage) &#123;</span><br><span class="line">            _dataStatusLive.value = DATA_STATUS_NO_MORE</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        isLoading = true</span><br><span class="line">        val stringRequest = StringRequest(</span><br><span class="line">            Request.Method.GET,</span><br><span class="line">            getUrl(),</span><br><span class="line">            &#123;</span><br><span class="line">                with(Gson().fromJson(it,Pixabay::class.java))&#123;</span><br><span class="line">                    totalPage = ceil(totalHits.toDouble()/perPage).toInt()</span><br><span class="line">                    if (isNewQuery)&#123;</span><br><span class="line">                        _photoListLive.value = hits.toList()</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        _photoListLive.value = arrayListOf(_photoListLive.value!!,hits.toList()).flatten()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                _dataStatusLive.value = DATA_STATUS_CAN_LOAD_MORE</span><br><span class="line">                isLoading = false</span><br><span class="line">                isNewQuery = false</span><br><span class="line">                currentPage++</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                isLoading = false</span><br><span class="line">                _dataStatusLive.value = DATA_STATUS_NETWORK_ERROR</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        VolleySingleton.getInstance(getApplication()).requestQueue.add(stringRequest)</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure></li>
<li><p>整体维护，细节处理</p>
<blockquote>
<p>当数据全部加载完毕或者网络异常时，我们需要通过一些常量进行标识，并更新UI告知用户，这便是维护，其中数据监听使用的是LiveData，可变私有化，提供一个不可变的供用户使用监听，其中还有一些小细节比如RecyclerView滑动处理，详情请见代码</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/normal-load-more">代码链接</a></p>
</li>
</ol>
<h3 id="三-方式二：使用Paging库"><a href="#三-方式二：使用Paging库" class="headerlink" title="三.方式二：使用Paging库"></a>三.方式二：使用Paging库</h3><p>首先添加依赖：<code>implementation &#39;androidx.paging:paging-runtime-ktx:2.1.0&#39;</code></p>
<blockquote>
<p>其中的关键组件是PagedList类，用于保存数据，数据从DataSource的实例对象取得，DataSource有以下三个子类</p>
</blockquote>
<ol>
<li><p>PageKeyedDataSource</p>
<p>前后页通过Key通常是整数即页数关联，上一页中包含下一页的Key</p>
</li>
<li><p>ItemKeyedDataSource</p>
<p>上一页包含加载下一页的数据，比如下一个查询之前，上一项的属性定义了如何执行它</p>
</li>
<li><p>PositionalDataSource</p>
<p>基于位置的数据加载器，用于固定大小、可计数的数据集，支持在任意页面位置进行固定大小的加载</p>
</li>
</ol>
<p>在本实例中使用第一个，因为上一项包含下一项的Key，即页码</p>
<p><strong>下面将从两个方面去分析使用Paging架构的实例</strong></p>
<ol>
<li><p>数据如何获得并展示到界面上</p>
<p>在方式一中数据的获取是在viewModel中进行的，而使用Paging库数据源是DataSource，所以我们需要创建PageKeyedDataSource的子类并从网络加载数据，而是如何带出数据，DataSource对象的创建离不开工厂类DataSource.Factory，并且LivePagedListProvider通过构造方法将PagedList与DataSource联系，所以我们通过<strong>DataSource.Factory</strong>的对象即可获取到DataSource对象中的数据，并且类型是**LiveData&lt;PagedList&lt;T&gt;&gt;**，因此我们只需要在viewModel中保存Factory的对象即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private val factory = PixabayDataSourceFactory(application)</span><br><span class="line">val pagedListLiveData = factory.toLiveData(1)</span><br></pre></td></tr></table></figure>

<p>具体代码可以前往代码链接，此处仅展示局部代码，有了LiveData版本的数据，在Fragment中就可以进行监听，并且提交给Adapter，让RecyclerView显示数据</p>
</li>
<li><p>整体的维护</p>
<p>此处的维护是指当网络异常时，数据加载失败，我们需要通过代码保存状态，并且通过界面提示用户继续进行加载</p>
<p>Kotlin的函数式编程很有优势，可以定义一个变量保存函数，当网络恢复后，再次调用该函数，恢复数据加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var retry:(()-&gt;Unit) ?= null</span><br><span class="line">retry = &#123;loadInitial(params,callback)&#125;</span><br></pre></td></tr></table></figure>

<p>当然还需定义枚举类保存状态，在java中推荐使用定义常量，但在Kotlin中更推荐使用枚举类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum class NetworkStatus&#123;</span><br><span class="line">    LOADING,</span><br><span class="line">    FAILED,</span><br><span class="line">    COMPLETED,</span><br><span class="line">    INITIAL_LOADING,</span><br><span class="line">    LOADED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据是否加载成功是在DataSource中得到，所以我们需要在该子类中定义一个保存状态的LiveData监听状态，然后是将该LiveData带出去让外部能够监听，还是通过<strong>DataSource.Factory</strong>来取出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val networkStatus = Transformations.switchMap(factory.pixabayDataSource) &#123; it.networkStatus &#125;</span><br></pre></td></tr></table></figure>

<p>在viewModel中通过此方法取出DataSource对象中保存的LiveData，至于在何处改变networkStatus的值在此不作赘述，请看代码链接，在Fragment中监听到网络状态发生改变后，还需通知Adapter做相应处理，Adapter中提供的方法请看代码链接</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>通过对比以上两种方式的代码实现，使用Paging库实在简洁太多，并且架构清晰，通过此实例深化了对MVVM的认识以及使用，也对RecyclerView中ViewHolder有了更深的理解，视图中加载的每一行在代码中其实就是一个Holder，将繁杂的代码剥离出来，会让Adapter更加简洁</p>
</blockquote>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/FinalGalleryShow.gif" style="zoom:45%;" />

<p><a target="_blank" rel="noopener" href="https://github.com/wiwi289/GalleryShow">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A.html" data-id="clchki9kc003lt0qh0ruxfwng" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-动态申请权限以及坑点解决" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90%E4%BB%A5%E5%8F%8A%E5%9D%91%E7%82%B9%E8%A7%A3%E5%86%B3.html" class="article-date">
  <time datetime="2021-02-21T12:12:11.000Z" itemprop="datePublished">2021-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90%E4%BB%A5%E5%8F%8A%E5%9D%91%E7%82%B9%E8%A7%A3%E5%86%B3.html">动态申请权限以及坑点解决</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在涉及到权限管理时发现有些权限即使在清单文件中添加了也不会申请成功，因为那些权限对于Android系统来说是危险的，比如读取公共区域的文件、获取定位等等，那么此时我们就需要<strong>动态申请权限</strong></p>
</blockquote>
<h3 id="二-权限分类"><a href="#二-权限分类" class="headerlink" title="二.权限分类"></a>二.权限分类</h3><p>在进行动态申请权限时，应该了解哪些权限需要动态申请</p>
<ol>
<li><p>普通权限</p>
<p>ACCESS_LOCATION_EXTRA_COMMANDS<br>ACCESS_NETWORK_STATE<br>ACCESS_NOTIFICATION_POLICY<br>ACCESS_WIFI_STATE<br>BLUETOOTH<br>BLUETOOTH_ADMIN<br>BROADCAST_STICKY<br>CHANGE_NETWORK_STATE<br>CHANGE_WIFI_MULTICAST_STATE<br>CHANGE_WIFI_STATE<br>DISABLE_KEYGUARD<br>EXPAND_STATUS_BAR<br>GET_PACKAGE_SIZE<br>INSTALL_SHORTCUT<br>INTERNET<br>KILL_BACKGROUND_PROCESSES<br>MODIFY_AUDIO_SETTINGS<br>NFC<br>READ_SYNC_SETTINGS<br>READ_SYNC_STATS<br>RECEIVE_BOOT_COMPLETED<br>REORDER_TASKS<br>REQUEST_INSTALL_PACKAGES<br>SET_ALARM<br>SET_TIME_ZONE<br>SET_WALLPAPER<br>SET_WALLPAPER_HINTS<br>TRANSMIT_IR<br>UNINSTALL_SHORTCUT<br>USE_FINGERPRINT<br>VIBRATE<br>WAKE_LOCK<br>WRITE_SYNC_SETTINGS</p>
</li>
<li><p>危险权限(共分为9个组)</p>
<p>①group:android.permission-group.CONTACTS<br>  permission:android.permission.WRITE_CONTACTS<br>  permission:android.permission.GET_ACCOUNTS<br>  permission:android.permission.READ_CONTACTS</p>
<p>②group:android.permission-group.PHONE<br>  permission:android.permission.READ_CALL_LOG<br>  permission:android.permission.READ_PHONE_STATE<br>  permission:android.permission.CALL_PHONE<br>  permission:android.permission.WRITE_CALL_LOG<br>  permission:android.permission.USE_SIP<br>  permission:android.permission.PROCESS_OUTGOING_CALLS<br>  permission:com.android.voicemail.permission.ADD_VOICEMAIL</p>
<p>③group:android.permission-group.CALENDAR<br>  permission:android.permission.READ_CALENDAR<br>  permission:android.permission.WRITE_CALENDAR</p>
<p>④group:android.permission-group.CAMERA<br>  permission:android.permission.CAMERA</p>
<p>⑤group:android.permission-group.SENSORS<br>  permission:android.permission.BODY_SENSORS</p>
<p>⑥group:android.permission-group.LOCATION<br>  permission:android.permission.ACCESS_FINE_LOCATION<br>  permission:android.permission.ACCESS_COARSE_LOCATION</p>
<p>⑦group:android.permission-group.STORAGE<br>  permission:android.permission.READ_EXTERNAL_STORAGE<br>  permission:android.permission.WRITE_EXTERNAL_STORAGE</p>
<p>⑧group:android.permission-group.MICROPHONE<br>  permission:android.permission.RECORD_AUDIO</p>
<p>⑨group:android.permission-group.SMS<br>  permission:android.permission.READ_SMS<br>  permission:android.permission.RECEIVE_WAP_PUSH<br>  permission:android.permission.RECEIVE_MMS<br>  permission:android.permission.RECEIVE_SMS<br>  permission:android.permission.SEND_SMS<br>  permission:android.permission.READ_CELL_BROADCASTS</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35937681/article/details/73469176">更多详情参考这篇文章</a></p>
</li>
</ol>
<h3 id="三-如何进行动态申请权限以及解决对话框不弹出问题"><a href="#三-如何进行动态申请权限以及解决对话框不弹出问题" class="headerlink" title="三.如何进行动态申请权限以及解决对话框不弹出问题"></a>三.如何进行动态申请权限以及解决对话框不弹出问题</h3><blockquote>
<p>所谓动态申请权限就是通过代码来申请权限，在我了解此部分时，发现仅仅通过代码申请有一个问题，就是申请权限的对话框不会弹出，网上也有很多帖子，但其实这不是什么坑，我们只需要在<strong>清单文件中添加权限</strong>就可以了，即使没有什么实际效果，但需要让系统知道我们将动态申请哪些权限，否则代码中比对时将是空对象，下面开始码代码</p>
</blockquote>
<ol>
<li><p>首先准备一个需要动态申请权限的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val permissions = arrayOf(</span><br><span class="line">            Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">            Manifest.permission.ACCESS_BACKGROUND_LOCATION,</span><br><span class="line">            Manifest.permission.READ_CONTACTS,</span><br><span class="line">            Manifest.permission.INTERNET</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li><p>先对数组中的权限进行遍历，筛选出哪些危险权限没有打开，并保存到另一个数组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val requiresPermissions = mutableListOf&lt;String&gt;()</span><br><span class="line"> private fun applyJurisdictions()&#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M)&#123;</span><br><span class="line">            permissions.forEach &#123;</span><br><span class="line">                if (ContextCompat.checkSelfPermission(this,it)!=PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    requiresPermissions.add(it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (requiresPermissions.size&gt;0)&#123;</span><br><span class="line">                requestPermissions(requiresPermissions.toTypedArray(),REQUEST_PERMISSIONS)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>if语句中的判断条件基本是死的，照搬即可，然后遍历数组，通过ContextCompat.checkSelfPermission(上下文，权限)进行查找筛选没有申请的权限，并添加到真正需要申请权限的数组中</p>
</blockquote>
</li>
<li><p>筛选完毕后，遍历真正需要进行动态申请权限的数组，通过<code>requestPermissions(权限数组,请求码)</code>方法进行申请，此方法会弹出申请权限的对话框，它是<code>Activity</code>类中的方法，所以如果使用工具类进行封装的话，需要通过Activity对象调用</p>
</li>
<li><p>权限申请完后，还可以处理回调事件，在Activity中重写<code>onRequestPermissionsResult()</code>方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123;</span><br><span class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        if (requestCode== REQUEST_PERMISSIONS)&#123;</span><br><span class="line">            grantResults.forEach &#123;</span><br><span class="line">                if (it!=PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    //没有获取到权限就强制退出app</span><br><span class="line">                    Log.v(&quot;cx&quot;,&quot;请求失败！&quot;)</span><br><span class="line">                    myApp.exitApp()</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Toast.makeText(this,&quot;申请权限成功！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有申请过的权限结果都保存在<code>grantResults</code>数组中，与<code>permissions</code>保存权限的数组一一对应</p>
</blockquote>
</li>
</ol>
<p><strong>现在绝大部分的App都会在启动App后进行危险权限的申请，如果用户拒绝了，它就会强行退出，进制用户使用，本实例中通过Application这个类来实现，即将所有启动过的Activity保存起来，然后通过一个方法一次性销毁，下面上代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyApp:Application() &#123;</span><br><span class="line">    private val activities = mutableListOf&lt;Activity&gt;()</span><br><span class="line">     override fun onCreate() &#123;</span><br><span class="line">         super.onCreate()</span><br><span class="line">     &#125;</span><br><span class="line">     fun addActivity(activity: Activity)&#123;</span><br><span class="line">        activities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line">     fun exitApp()&#123;</span><br><span class="line">        activities.forEach &#123;</span><br><span class="line">            it.finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90show.gif" style="zoom: 33%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>在一个大型的App中经常会涉及到危险权限申请问题，经过以上的流程，发现动态申请权限其实很简单的</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/apply-jurisdictions">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90%E4%BB%A5%E5%8F%8A%E5%9D%91%E7%82%B9%E8%A7%A3%E5%86%B3.html" data-id="clchki9kb003jt0qh09el5fz3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Glide源码解读以及自定义图片加载库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93.html" class="article-date">
  <time datetime="2021-02-18T13:57:11.000Z" itemprop="datePublished">2021-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93.html">Glide源码解读以及自定义图片加载库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在了解了Glide的基本使用后，还需进一步了解的实现原理，通过源码理清思路后能够自己封装一个类似的网络图片加载库，下面分步骤详解</p>
</blockquote>
<p><strong>下面照旧从三个方面进行源码解读</strong></p>
<ol>
<li>请求发送到哪里去了</li>
<li>请求是被谁处理的</li>
<li>请求是怎么被维护的</li>
</ol>
<h3 id="二-请求发送到哪里去了"><a href="#二-请求发送到哪里去了" class="headerlink" title="二.请求发送到哪里去了"></a>二.请求发送到哪里去了</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%AD%A5%E9%AA%A4%E4%B8%80.png" style="zoom:67%;" />

<blockquote>
<p>从链式代码的最后一个步<code>into()</code>入手，进入<code>RequestBuilder</code>类中，有多个<code>into</code>方法，跳转两次后，会看到<code>requestManager.track()</code>，进入到<code>runRequest()</code>方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void runRequest(@NonNull Request request) &#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      request.clear();</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, &quot;Paused, delaying request&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到里面的逻辑，如果没有暂停则立即执行请求，否则清空运行中的队列，并将请求添加到等待中的队列</p>
<h3 id="三-请求是被谁处理的"><a href="#三-请求是被谁处理的" class="headerlink" title="三.请求是被谁处理的"></a>三.请求是被谁处理的</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%AD%A5%E9%AA%A4%E4%BA%8C.png" style="zoom: 67%;" />

<blockquote>
<p>进入到<code>loadData()</code>的具体实现类<code>HttpUrlFetcher</code>，在<code>loadDataWithRedirects()</code>中可以清楚的看到真正在处理网络请求的是<code>HttpUrlConnection</code></p>
</blockquote>
<h3 id="四-请求是怎么被维护的"><a href="#四-请求是怎么被维护的" class="headerlink" title="四.请求是怎么被维护的"></a>四.请求是怎么被维护的</h3><p>Glide传入了Context参数，具有生命周期，据此来进行维护</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%AD%A5%E9%AA%A4%E4%B8%89.png" style="zoom:80%;" />

<blockquote>
<p>涉及到的方法较少，通过<code>supportFragmentGet()</code>创建一个无UI的Fragment，并且与返回的<code>requestManager</code>进行了绑定，Fragment可以感知Activity的生命周期，因此<code>requestManager</code>也具有了生命周期，而且在<code>RequestManager</code>类中也可以看到<code>onStart</code>、<code>onStop</code>等方法，具体调用<code>resumeRequests()</code>、<code>pauseRequests()</code>，并且在<code>SingleRequest</code>中还有<code>recycle()</code>回收机制</p>
</blockquote>
<h3 id="五-自定义图片加载框架"><a href="#五-自定义图片加载框架" class="headerlink" title="五.自定义图片加载框架"></a>五.自定义图片加载框架</h3><blockquote>
<p>弄懂Glide的原理后，下面尝试着写一个类似的图片加载框架，比较简单</p>
</blockquote>
<p>可以将下面的例子类比成一个餐馆，客人就是请求，桌子就是处理线程，客人都会先进行排队(将任务丢进队列)，然后是寻找桌子(线程从队列中取任务)，在菜做好(图片加载好)之前，先吃点花生米(展示提示图)，整个店就是一个图片加载框架，服务员类似于<code>RequestManager</code>的角色，所以核心类就只有三个<code>BitmapRequest</code>、<code>BitmapDispatcher</code>、<code>RequestManager</code></p>
<p><strong>例子中会使用到一个Md5工具类，用于核对防止图片设置错位</strong></p>
<blockquote>
<p>由于多个BitmapDispatcher是从同一个队列中取任务，所以它内部管理的只能是一个引用，不能自己创建一个队列，该队列只能维护在<code>RequestManager</code>中，取任务的过程依然是一个死循环</p>
</blockquote>
<p>在此就不贴出代码了，还请自行前往链接查看，理清三个类之间的关系即可</p>
<p>效果展示：</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/MyGlide%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif" style="zoom: 33%;" />

<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/my-glide">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93.html" data-id="clchki9j7000tt0qhfx7o81kl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Retrofit源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html" class="article-date">
  <time datetime="2021-02-16T12:34:01.000Z" itemprop="datePublished">2021-02-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html">Retrofit源码解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面以及学习了如何使用Retrofit发起常用的网络请求，确实感觉Retrofit是目前来说非常好用的网络框架，虽然它不是独立的，只是对Okhttp的一层封装，下面小编想通过查看源码的方式去了解Retrofit是如何运作的</p>
</blockquote>
<h3 id="二-Retrofit中注解的解析流程"><a href="#二-Retrofit中注解的解析流程" class="headerlink" title="二.Retrofit中注解的解析流程"></a>二.Retrofit中注解的解析流程</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/retrofit%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" style="zoom: 25%;" />

<p>在此就不贴源码了，实在太多，上述流程大致分为以下步骤：</p>
<ol>
<li>通过Method获取到所有的注解并保存</li>
<li>通过一个方法进行解析，此方法在下面列出</li>
<li>通过解析获取到的所有参数以及路径进行构造request，最终还是回到了OkHttpCall上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">     if (annotation instanceof DELETE) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof GET) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof HEAD) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof PATCH) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);</span><br><span class="line">     &#125; else if (annotation instanceof POST) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</span><br><span class="line">     &#125; else if (annotation instanceof PUT) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);</span><br><span class="line">     &#125; else if (annotation instanceof OPTIONS) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof HTTP) &#123;</span><br><span class="line">       HTTP http = (HTTP) annotation;</span><br><span class="line">       parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">     &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">       String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">       if (headersToParse.length == 0) &#123;</span><br><span class="line">         throw methodError(method, &quot;@Headers annotation is empty.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       headers = parseHeaders(headersToParse);</span><br><span class="line">     &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">       if (isFormEncoded) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isMultipart = true;</span><br><span class="line">     &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">       if (isMultipart) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isFormEncoded = true;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当然这类解析方法还有多个，都是进行具体注解解析，获取到所有参数，用于拼接路径，构建Okhttp请求</p>
<h3 id="三-Retrofit的运作流程"><a href="#三-Retrofit的运作流程" class="headerlink" title="三.Retrofit的运作流程"></a>三.Retrofit的运作流程</h3><p>先上从构建Retrofit对象到发起请求最后返回结果的整体流程图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/retrofit%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" style="zoom: 50%;" />

<blockquote>
<p>相信流程图已经很详细了，下面根据流程图贴出部分源码</p>
</blockquote>
<ol>
<li><p>在Retrofit的建造者模式中，会有一个Platform类，Android手机返回Android()对象，该平台提供了下面的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final class MainThreadExecutor implements Executor &#123;</span><br><span class="line">      private final Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void execute(Runnable r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因此使用异步请求时，可以将结果返回到UI主线程</p>
</li>
<li><p>使用动态代理模式创建接口的实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(T) Proxy.newProxyInstance(</span><br><span class="line">           service.getClassLoader(),</span><br><span class="line">           new Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">           new InvocationHandler() &#123;</span><br><span class="line">             private final Platform platform = Platform.get();</span><br><span class="line">             private final Object[] emptyArgs = new Object[0];</span><br><span class="line">             @Override</span><br><span class="line">             public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">                 throws Throwable &#123;</span><br><span class="line">               // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">               if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                 return method.invoke(this, args);</span><br><span class="line">               &#125;</span><br><span class="line">               args = args != null ? args : emptyArgs;</span><br><span class="line">               return platform.isDefaultMethod(method)</span><br><span class="line">                   ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                   : loadServiceMethod(method).invoke(args);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<p>loadServiceMethod(method).invoke(args);此方法开始解析接口中通过注解定义的方法，接下来的流程对应了上面提到的注解解析流程，在此不再赘述</p>
</li>
<li><p>进行网络请求时，是通过具体的CallAdpter调用get方法获取到与之适配的Call对象，并在与之对应的工厂类中调用Okhttp的Call方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      this.callbackExecutor = callbackExecutor;</span><br><span class="line">      this.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      Objects.requireNonNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(</span><br><span class="line">          new Callback&lt;T&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">              callbackExecutor.execute(</span><br><span class="line">                  () -&gt; &#123;</span><br><span class="line">                    if (delegate.isCanceled()) &#123;</span><br><span class="line">                      // Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on</span><br><span class="line">                      // cancellation.</span><br><span class="line">                      callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                      callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">              callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>真正在执行请求的是Okhttp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过此方法转换到Okhttp中call对象上，因此最终调用的也是Okhttp中的enqueue方法</p>
</li>
<li><p>若请求成功，则通过parseResponse()方法进行数据转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</span><br><span class="line">   ResponseBody rawBody = rawResponse.body();</span><br><span class="line">   </span><br><span class="line">   // Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span><br><span class="line">   rawResponse =</span><br><span class="line">       rawResponse</span><br><span class="line">           .newBuilder()</span><br><span class="line">           .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">           .build();</span><br><span class="line">   </span><br><span class="line">   int code = rawResponse.code();</span><br><span class="line">   if (code &lt; 200 || code &gt;= 300) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       // Buffer the entire body to avoid future I/O.</span><br><span class="line">       ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">       return Response.error(bufferedBody, rawResponse);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       rawBody.close();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   if (code == 204 || code == 205) &#123;</span><br><span class="line">     rawBody.close();</span><br><span class="line">     return Response.success(null, rawResponse);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">   try &#123;</span><br><span class="line">     T body = responseConverter.convert(catchingBody);</span><br><span class="line">     return Response.success(body, rawResponse);</span><br><span class="line">   &#125; catch (RuntimeException e) &#123;</span><br><span class="line">     // If the underlying source threw an exception, propagate that rather than indicating it was</span><br><span class="line">     // a runtime exception.</span><br><span class="line">     catchingBody.throwIfCaught();</span><br><span class="line">     throw e;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>转换完成后，通过success()方法回调带出结果</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>经过以上流程，也大致对Retrofit的运作原理有了一定的了解，结合流程图会更清晰。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html" data-id="clchki9jn001tt0qh7hbs8dms" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Okhttp源码解读以及自搭网络框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E6%90%AD%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6.html" class="article-date">
  <time datetime="2021-02-10T07:39:53.000Z" itemprop="datePublished">2021-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E6%90%AD%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6.html">Okhttp源码解读以及自搭网络框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面已经了解了Okhttp的基本组成以及用法，除此之外我们还需深入源码了解Okhttp的运行机制，并且能够自己搭建一个类似的网络请求框架，其实弄懂Okhttp一个网络框架，其他的网络开源库自然容易理解</p>
</blockquote>
<p>先上Okhttp的整体框架图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Okhttp%E6%A1%86%E6%9E%B6%E5%9B%BE.png" style="zoom: 40%;" />

<p>下面将从以下三个方面剖析Okhttp的运行机制：</p>
<ol>
<li>请求发送到哪里去了</li>
<li>请求是被谁处理的</li>
<li>请求是怎么被维护的</li>
</ol>
<p>以请求为中心展开分析</p>
<h3 id="二-请求发送到哪里去了"><a href="#二-请求发送到哪里去了" class="headerlink" title="二.请求发送到哪里去了"></a>二.请求发送到哪里去了</h3><blockquote>
<p>为了便于理解，下面以异步请求即请求入队列的方式来分析源码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过跟踪<code>enqueue()</code>方法，我们发现两个队列：<code>runningAsyncCalls</code>和<code>readyAsyncCalls</code>，即运行中的队列和等待中的队列，只有同时满足运行队列中任务的个数小于64以及对同一个目标的访问数小于5时才会被添加到运行中的队列，并执行，否则添加到等待中的队列</p>
<h3 id="三-请求是被谁处理的"><a href="#三-请求是被谁处理的" class="headerlink" title="三.请求是被谁处理的"></a>三.请求是被谁处理的</h3><p>从上面的代码可以看到，任务被丢给了<code>executorService()</code>来处理，即线程池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">   if (executorService == null) &#123;</span><br><span class="line">     executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">         new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">   &#125;</span><br><span class="line">   return executorService;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一张图先来解释一下线程池</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%BE%E8%A7%A3.png" style="zoom:50%;" />

<p>而此处内部创建的是<code>SynchronousQueue</code>无容量的队列，即只要有任务丢进线程池就会立即执行，即使没有空闲线程也会立即创建，所以在设置最大线程数时用的是<code>Integer.MAX_VALUE</code>，相当大的一个值</p>
<blockquote>
<p>在第一步时说到Okhttp本身就有两个队列，等待和运行，也就意味着它自己本身就可以控制同一时间最多可以执行多少个任务，超过数量就进入等待的队列，所以就没必要再在线程池中自己维护一个有容量的队列，效率也不太高</p>
</blockquote>
<p>当任务交给线程池后，线程池会找一个空闲线程调用<code>run()</code>方法去执行具体的任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">     boolean signalledCallback = false;</span><br><span class="line">     try &#123;</span><br><span class="line">       Response response = getResponseWithInterceptorChain();</span><br><span class="line">       if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">         signalledCallback = true;</span><br><span class="line">         responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         signalledCallback = true;</span><br><span class="line">         responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       if (signalledCallback) &#123;</span><br><span class="line">         // Do not signal the callback twice!</span><br><span class="line">         Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         eventListener.callFailed(RealCall.this, e);</span><br><span class="line">         responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       client.dispatcher().finished(this);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">   // Build a full stack of interceptors.</span><br><span class="line">   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">   interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">   interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">   if (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">       originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">       client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">   return chain.proceed(originalRequest);</span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure>

<p>这是<code>RealCall</code>的内部类<code>AsyncCall</code>中的方法，调用该方法后，首先进入的是<strong>责任链</strong>模式</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png"></p>
<p>在请求发送到服务器之前需要通过一系列关卡的检查，这些关卡就是所谓的<strong>拦截器</strong>，只有当符合所有条件的请求才能通过，最终通过<code>RealInterceptorChain</code>发送请求，此过程提升了网络请求的效率</p>
<h3 id="四-请求是怎么被维护的"><a href="#四-请求是怎么被维护的" class="headerlink" title="四.请求是怎么被维护的"></a>四.请求是怎么被维护的</h3><p>在<code>execute()</code>方法中有一个<code>finally</code>代码块，调用了<code>client.dispatcher().finished(this)</code>，进入到<code>finished()</code>方法内部可以看到<code>promoteCalls()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当一个请求被处理完毕后，会执行以上代码块进行维护，其实就是下图所示的循环</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E5%85%B7%E4%BD%93%E7%BB%B4%E6%8A%A4.png" style="zoom:50%;" />

<p>通过线程间的执行进行维护</p>
<h3 id="五-自定义网络框架"><a href="#五-自定义网络框架" class="headerlink" title="五.自定义网络框架"></a>五.自定义网络框架</h3><p>经历了上述三个过程发现Okhttp框架其实很清晰，下面模仿它的思路自定义一个请求Json数据的网络框架，先上图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6.png" style="zoom:50%;" />

<p>通过核心线程进行维护，和上述的Okhttp思路相似，只不过线程池中的队列不再是无容量的，而是指定了空闲线程数以及容量的队列</p>
<p>说明：由于该Demo涉及到泛型，而Kotlin中个人感觉是不兼容，因此使用Java语言</p>
<ol>
<li><p>首先我们需要先写好线程池部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ThreadPoolManager &#123;</span><br><span class="line">    private LinkedBlockingQueue&lt;Runnable&gt; mQueue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    private ThreadPoolExecutor mThreadPoolExecutor;</span><br><span class="line">    public Runnable coreThread = new Runnable() &#123;</span><br><span class="line">        Runnable runn = null;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    runn = mQueue.take();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mThreadPoolExecutor.execute(runn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private ThreadPoolManager()&#123;</span><br><span class="line">        mThreadPoolExecutor = new ThreadPoolExecutor(3, 10, 15, TimeUnit.SECONDS, new ArrayBlockingQueue&lt; Runnable &gt;(5)</span><br><span class="line">                , new RejectedExecutionHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void rejectedExecution(Runnable runnable, ThreadPoolExecutor threadPoolExecutor) &#123;</span><br><span class="line">                addTask(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mThreadPoolExecutor.execute(coreThread);</span><br><span class="line">    &#125;</span><br><span class="line">    private static  ThreadPoolManager instance = new ThreadPoolManager();</span><br><span class="line">    public static ThreadPoolManager getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addTask(Runnable runnable)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mQueue.put(runnable);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列采用的是阻塞式的，保证同步性，线程安全</p>
<p><strong>核心线程是通过死循环不断监听队列中是否有任务，这和Okhttp通过线程之间的交互连接实现的死循环很类似，此处使用死循环也不会造成很大的开销，毕竟只是一个子线程，只要思路相似即可</strong></p>
</li>
<li><p>封装请求部分</p>
<p>首先需要定义封装请求方法的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IHttpRequest &#123;</span><br><span class="line">    void setUrl(String url);</span><br><span class="line">    void setData(byte[] data);</span><br><span class="line">    void setListener(CallbackListener listener);</span><br><span class="line">    void excute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class JsonHttpRequest implements IHttpRequest &#123;</span><br><span class="line">    private String url;</span><br><span class="line">    private byte[] data;</span><br><span class="line">    private CallbackListener mCallbackListener;</span><br><span class="line">    private HttpURLConnection urlConnection;</span><br><span class="line">    @Override</span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">            this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setData(byte[] data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setListener(CallbackListener listener) &#123;</span><br><span class="line">            this.mCallbackListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void excute() &#123;</span><br><span class="line">        URL url = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            url = new URL(this.url);</span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            urlConnection.setConnectTimeout(6000);</span><br><span class="line">            urlConnection.setUseCaches(false);//不使用缓存</span><br><span class="line">            urlConnection.setInstanceFollowRedirects(true);</span><br><span class="line">            urlConnection.setReadTimeout(3080);</span><br><span class="line">            urlConnection.setDoInput(true);</span><br><span class="line">            urlConnection.setDoOutput(true);</span><br><span class="line">            urlConnection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">            urlConnection.setRequestProperty( &quot;Content-Type&quot;,&quot;application/json;charset=UTF-8&quot;);</span><br><span class="line">            urlConnection.connect();</span><br><span class="line">            OutputStream out = urlConnection.getOutputStream();</span><br><span class="line">            BufferedOutputStream bos = new BufferedOutputStream(out);</span><br><span class="line">            bos.write(data);</span><br><span class="line">            bos.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            if (urlConnection.getResponseCode() == HttpURLConnection.HTTP_OK)&#123;</span><br><span class="line">                InputStream in = urlConnection.getInputStream();</span><br><span class="line">                mCallbackListener.onSuccess(in);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于为什么要封装<code>excute()</code>方法，因为子线程会调用<code>run()</code>方法，最终会调用任务本身的<code>excute()</code>去具体执行任务</p>
</li>
<li><p>封装数据回调</p>
<p>首先定义回调的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface CallbackListener &#123;</span><br><span class="line">    void onSuccess(InputStream inputStream);</span><br><span class="line">    void onFailure();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为网络请求带回来的是<code>InputStream</code>，然后再将流中的数据写入到内存，转换成具体的对象带出去，一般网络请求的用法大抵如此</p>
<p>定义带出数据的类，即将网络请求的数据转换成具体需要的对象回调带出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class JsonCallbackListener&lt;T&gt; implements CallbackListener &#123;</span><br><span class="line">    private Class&lt;T&gt; responseClass;</span><br><span class="line">    private IJsonDataTransforListener listener;</span><br><span class="line">    private Handler mHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">    public JsonCallbackListener(Class&lt;T&gt; responseClass,IJsonDataTransforListener listener)&#123;</span><br><span class="line">        this.responseClass = responseClass;</span><br><span class="line">        this.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(InputStream inputStream) &#123;</span><br><span class="line">            String response = getContent(inputStream);</span><br><span class="line">            final T clazz = JSON.parseObject(response,responseClass);</span><br><span class="line">            mHandler.post(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    listener.onSuccess(clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getContent(InputStream inputStream)&#123;</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line"></span><br><span class="line">            String line = null;</span><br><span class="line">            while (((line = reader.readLine()) != null)) &#123;</span><br><span class="line">                builder.append(line).append(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是数据回调的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IJsonDataTransforListener&lt;T&gt; &#123;</span><br><span class="line">    void onSuccess(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后还差封装具体的网络请求任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class HttpTask&lt;T&gt; implements Runnable &#123;</span><br><span class="line">    private IHttpRequest httpRequest;</span><br><span class="line">    public HttpTask(String url,T requestData,IHttpRequest httpRequest,CallbackListener listener)&#123;</span><br><span class="line">        this.httpRequest = httpRequest;</span><br><span class="line">        httpRequest.setUrl(url);</span><br><span class="line">        httpRequest.setListener(listener);</span><br><span class="line">        String content = JSON.toJSONString(requestData);</span><br><span class="line">        try &#123;</span><br><span class="line">            httpRequest.setData(content.getBytes(&quot;utf-8&quot;));</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        httpRequest.excute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候还需组装一个请求任务，为了体现高度的封装性，再提供一个类进行封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyHttp &#123;</span><br><span class="line">    public static&lt;T,M&gt; void sendJsonRequest(String url,T requestData,Class&lt;M&gt; response,IJsonDataTransforListener listener)&#123;</span><br><span class="line">        IHttpRequest httpRequest = new JsonHttpRequest();</span><br><span class="line">        CallbackListener callbackListener = new JsonCallbackListener&lt;&gt;(response,listener);</span><br><span class="line">        HttpTask httpTask = new HttpTask(url,requestData,httpRequest,callbackListener);</span><br><span class="line">        ThreadPoolManager.getInstance().addTask(httpTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义数据类型，进行实战演练</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class MyBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyBean&#123;&quot; +</span><br><span class="line">                &quot;resultCode=&quot; + resultCode +</span><br><span class="line">                &quot;, reason=&#x27;&quot; + reason + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int resultCode;</span><br><span class="line"></span><br><span class="line">    public int getResultCode() &#123;</span><br><span class="line">        return resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setResultCode(int resultCode) &#123;</span><br><span class="line">        this.resultCode = resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReason() &#123;</span><br><span class="line">        return reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReason(String reason) &#123;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String reason;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private String url = &quot;http://apis.juhe.cn/simpleWeather/query&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        OkHttpClient client = new OkHttpClient();</span><br><span class="line">        for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            sendRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sendRequest()&#123;</span><br><span class="line">        MyHttp.sendJsonRequest(url, null, MyBean.class, new IJsonDataTransforListener&lt;MyBean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(MyBean myBean) &#123;</span><br><span class="line">                Log.v(&quot;cx&quot;,&quot;返回的数据：&quot;+myBean.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的那个数据回调是否有点像Okhttp中的异步回调呢，经历了以上步骤还是清晰的看出网络访问框架就是这样一层一层封装的，下面上效果图</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83.png"></p>
</li>
</ol>
<blockquote>
<p>可以看到发送的十次请求都有了结果，速度也是很快的</p>
</blockquote>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><blockquote>
<p>经过以上的折磨，我们也大概知道Okhttp的运行原理了，小编也是头一回写网络框架，感觉还不错，只要把握好整体的结构，需要回调带出数据时便定义接口，初级阶段只要清楚原理即可</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/myhttp-demo">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E6%90%AD%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6.html" data-id="clchki9jj001it0qhd2vdh27a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络开源库-Glide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Glide.html" class="article-date">
  <time datetime="2021-02-07T02:12:38.000Z" itemprop="datePublished">2021-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Glide.html">网络开源库-Glide</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天将介绍一个用于加载图片的网络开源库Glide，如果你还在使用请求网络，将返回的IO流通过BitmapFactory合成Bitmap的方式加载图片的话，小编强烈建议使用Glide，一行代码解决问题，相当简洁好用</p>
</blockquote>
<p><strong>下面详细列出Glide的优势</strong></p>
<ol>
<li>使用简单，上手特别快</li>
<li>可配置度高，自适应程度高</li>
<li>支持常见的图片格式 jpg png gif webp</li>
<li>支持多种数据源：网络、本地、资源、Assets等</li>
<li>高效率缓存策略：支持Memory和Disk图片缓存，默认Bitmap格式采用RGB_565内存使用至少减少一半</li>
<li>生命周期集成：根据Activity/Fragment生命周期自动管理请求</li>
<li>高效处理Bitmap：使用Bitmap Pool让Bitmap复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力</li>
</ol>
<p>添加好依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com.github.bumptech.glide:glide:4.11.0&#x27;</span><br></pre></td></tr></table></figure>

<p>由于下面涉及到手机内存文件的读取，在Android 6.0以后需要动态申请权限，所以在加载内存图片之前需要调用一下方法申请权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun applyForFileReadJurisdction()&#123;</span><br><span class="line">      if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">          val REQUEST_CODE_CONTACT = 101</span><br><span class="line">          val permissions = arrayOf&lt;String&gt;(</span><br><span class="line">              Manifest.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">          )</span><br><span class="line">          //验证是否许可权限</span><br><span class="line">          for (str in permissions) &#123;</span><br><span class="line">              if (this.checkSelfPermission(str) !== PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                  //申请权限</span><br><span class="line">                  this.requestPermissions(permissions, REQUEST_CODE_CONTACT)</span><br><span class="line">                  return</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次运行可能看不到图片加载，因为代码在你申请成功之前已经执行完毕了，所以第二次进入就可以看到图片被加载出来，此外还需要在清单文件中添加权限，在Okhttp篇已经提及</p>
</blockquote>
<h3 id="二-Glide的具体使用加载图片"><a href="#二-Glide的具体使用加载图片" class="headerlink" title="二.Glide的具体使用加载图片"></a>二.Glide的具体使用加载图片</h3><ol>
<li><p>加载网络图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://192.168.0.103/iamge4.jpg&quot;)</span><br><span class="line">     .into(glide_image1)</span><br></pre></td></tr></table></figure></li>
<li><p>加载Drawable资源图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">    .load(R.drawable.image1)</span><br><span class="line">    .into(glide_image2)</span><br></pre></td></tr></table></figure></li>
<li><p>加载手机SD卡图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val imgPath = Environment.getExternalStorageDirectory().path+&quot;/a/retrofitDownload.jpg&quot;</span><br><span class="line">val file = File(imgPath)</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(Uri.fromFile(file))</span><br><span class="line">     .into(glide_image3)</span><br></pre></td></tr></table></figure></li>
<li><p>加载网络gif</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://192.168.0.103/internet.gif&quot;)</span><br><span class="line">     .placeholder(R.drawable.ic_launcher_foreground)</span><br><span class="line">     .into(glide_image4)</span><br></pre></td></tr></table></figure></li>
<li><p>加载Drawable资源gif图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(R.drawable.drawable)</span><br><span class="line">     .into(glide_image5)</span><br></pre></td></tr></table></figure></li>
<li><p>加载手机SD卡gif图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val gifPath = Environment.getExternalStorageDirectory().path+&quot;/a/SD卡.gif&quot;</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(gifPath)</span><br><span class="line">     .into(glide_image6)</span><br></pre></td></tr></table></figure></li>
<li><p>加载本地视频</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val videoPath = Environment.getExternalStorageDirectory().path+&quot;/a/Test.mp4&quot;</span><br><span class="line">val videoFile = File(videoPath)</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(videoFile)</span><br><span class="line">     .into(glide_image7)</span><br></pre></td></tr></table></figure>

<p><strong>加载本地视频只能加载首页</strong></p>
</li>
<li><p>设置缩略图比例，然后先加载，再加载原图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val localThumbnail = Environment.getExternalStorageDirectory().path+&quot;/a/本地缩略图.png&quot;</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(localThumbnail)</span><br><span class="line">     .thumbnail(0.1f)</span><br><span class="line">     .centerCrop()</span><br><span class="line">     .into(glide_image8)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>thumbnail设置缩略图占原图的比例，centerCrop从中心对齐</p>
</blockquote>
</li>
<li><p>先创建一个缩略图对象，然后，先加载缩略图，再加载原图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val thumbnailRequest = Glide.with(this).load(&quot;http://192.168.0.103/girl1.jpg&quot;)</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://192.168.0.103/girl3.jpg&quot;)</span><br><span class="line">     .thumbnail(thumbnailRequest)</span><br><span class="line">     .centerCrop()</span><br><span class="line">     .into(glide_image9)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先创建显示的缩略图不一定是最终显示的图片，也是通过thumbnail来设置添加</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>观察以上代码，发现Glide使用是实在简洁，通过一行链式代码解决，并且load方法传入的参数也多种多样</p>
</blockquote>
<h3 id="三-添加图形变换"><a href="#三-添加图形变换" class="headerlink" title="三.添加图形变换"></a>三.添加图形变换</h3><p>如果你要对图片做一些效果，比如模糊、截取部分等等，需要使用下面的图片转换库搭配Glide加载图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;jp.wasabeef:glide-transformations:4.3.0&#x27;</span><br></pre></td></tr></table></figure>

<p>在此小编简单演示几个</p>
<ol>
<li><p>使用圆角</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">            .load(&quot;http://192.168.0.103/iamge4.jpg&quot;)</span><br><span class="line">            .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(500, 0, RoundedCornersTransformation.CornerType.ALL)))</span><br><span class="line">            .into(glide_image1)</span><br></pre></td></tr></table></figure>

<p>通过apply方法，RequestOptions.bitmapTransform()是不变的，变的是里面的参数，参数一是设置半径，参数二设置与四周的间距，参数三是设置具体的样式</p>
</li>
<li><p>使用模糊</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(RequestOptions.bitmapTransform(BlurTransformation(25, 3)))</span><br></pre></td></tr></table></figure>

<p>两个参数共同调控模糊度，都是值越大越模糊</p>
</li>
<li><p>同时使用多个效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val multi = MultiTransformation(</span><br><span class="line">           BlurTransformation(25),</span><br><span class="line">           RoundedCornersTransformation(500, 0, RoundedCornersTransformation.CornerType.ALL)</span><br><span class="line">       )</span><br><span class="line">apply(RequestOptions.bitmapTransform(multi))       </span><br></pre></td></tr></table></figure>

<p>如果比较感兴趣的话可以去百度其他博客，小编在此仅做引入</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wasabeef/glide-transformations">官网链接</a></p>
<p><strong>集体效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif" style="zoom:45%;" /></li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>经过上面的过程，相信Glide上手真的很快，使用方便，是项目中加载图片的不二之选</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/glide_">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Glide.html" data-id="clchki9le006dt0qh00ou63hx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络开源库-Volley" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Volley.html" class="article-date">
  <time datetime="2021-02-07T02:11:54.000Z" itemprop="datePublished">2021-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Volley.html">网络开源库-Volley</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天了解网络开源库<code>Volley</code>，主要以<code>Volley</code>的日常使用为主，下面是<code>Volley</code>的优势和劣势</p>
</blockquote>
<p>优点：</p>
<ol>
<li><p>网络请求的排序(scheduling)</p>
</li>
<li><p>网络请求的优先级处理</p>
</li>
<li><p>缓存</p>
</li>
<li><p>多级别取消请求</p>
</li>
<li><p>和Activity的生命周期联动(Activity结束时同时取消所有网络请求)</p>
</li>
<li><p>非常适合进行数据量不大，但通信频繁的网络操作</p>
</li>
<li><p>可自定义扩展</p>
</li>
</ol>
<p>缺点：对于大数据量的网络操作，如下载文件，Volley不太行   </p>
<p><code>Volley</code>的使用大致分为三个步骤：</p>
<ol>
<li> 创建一个请求队列</li>
<li>创建一个请求</li>
<li>将请求添加到队列中</li>
</ol>
<p>有以下几种请求API：</p>
<ol>
<li>请求String类型数据：StringRequest</li>
<li>请求JSON数据：JsonObjectRequest/JsonArrayRequest</li>
<li>请求图片数据：ImageRequest</li>
</ol>
<h3 id="二-简单的GET请求"><a href="#二-简单的GET请求" class="headerlink" title="二.简单的GET请求"></a>二.简单的GET请求</h3><p><strong>由于创建请求队列特别好资源所以我们将它进行封装成单例，全局只有一个请求队列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class VolleySingleton private constructor(context: Context)&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        var instance:VolleySingleton?=null</span><br><span class="line">        fun getInstance(context: Context) = instance?: synchronized(this)&#123;</span><br><span class="line">            instance?:VolleySingleton(context).also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val requestQueue:RequestQueue by lazy &#123;</span><br><span class="line">            Volley.newRequestQueue(context.applicationContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：在网络请求中我们多数使用的是String类型数据的请求，返回给我们的是Json字符串，然后通过相应的Json解析得到实体类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun VolleyGet()&#123;</span><br><span class="line">        val request = StringRequest(url1,&#123;</span><br><span class="line">            val weather = gson.fromJson(it,Weather::class.java)</span><br><span class="line">            Toast.makeText(this,&quot;请求成功！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">            if (weather.error_code == 0)&#123;</span><br><span class="line">                city.text = weather.result.city</span><br><span class="line">                weatherInfo.text = weather.result.realtime.info</span><br><span class="line">                temperature.text = weather.result.realtime.temperature</span><br><span class="line">                wind.text = weather.result.realtime.direct</span><br><span class="line">                power.text = weather.result.realtime.power</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            Toast.makeText(this,&quot;请求失败&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;)</span><br><span class="line">        VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>StringRequest(url地址，请求成功的处理(参数是Json字符串)，请求失败的处理)</code></p>
</li>
<li><p>此处使用的API是聚合数据提供的天气查询，返回的Json字符串通过Gson解析成对应的实体类，当然这种对应可以不是一一对应，如果你只需要其中的部分值，那么构建实体类时添加部分属性即可，下面上代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data class Weather(val error_code:Int,val result: Result)</span><br><span class="line">data class Result(val city:String,val realtime: RealTime)</span><br><span class="line">data class RealTime(</span><br><span class="line">    val temperature:String,</span><br><span class="line">    val info:String,</span><br><span class="line">    val direct:String,</span><br><span class="line">    val power:String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面通过查看工具可以看到返回的Json字符串的结构</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%B8%80%E5%B1%82.png" style="zoom:70%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%BA%8C%E5%B1%82.png" style="zoom:50%;" /></li>
</ol>
<h3 id="三-POST请求添加参数"><a href="#三-POST请求添加参数" class="headerlink" title="三.POST请求添加参数"></a>三.POST请求添加参数</h3><p>同样使用<code>StringRequest()</code>演示使用POST请求并添加参数进行登录验证</p>
<p><strong>添加参数需要使用匿名内部类的方式重写StringRequest中的一个getParams()方法，并通过Map添加键值对的方式来设置参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun VolleyPostTest()&#123;</span><br><span class="line">		val url2 = &quot;http://192.168.0.103/login/login.php&quot;</span><br><span class="line">       val request = object :StringRequest(Method.POST,url2,&#123;</span><br><span class="line">        Toast.makeText(this,it,Toast.LENGTH_SHORT).show()</span><br><span class="line">       &#125;,&#123;</span><br><span class="line">           Toast.makeText(this,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">       &#125;)&#123;</span><br><span class="line">           override fun getParams(): MutableMap&lt;String, String&gt; &#123;</span><br><span class="line">               return HashMap&lt;String,String&gt;().apply &#123;</span><br><span class="line">                   put(&quot;user_name&quot;, &quot;jack&quot;)</span><br><span class="line">                   put(&quot;user_pwd&quot;, &quot;123&quot;)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>和GET方式一样，使用简单</p>
<h3 id="四-请求Json数据"><a href="#四-请求Json数据" class="headerlink" title="四.请求Json数据"></a>四.请求Json数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun VolleyJson()&#123;</span><br><span class="line">        val request = JsonObjectRequest(url1,null,&#123;</span><br><span class="line">            Toast.makeText(this,it.toString(),Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            Toast.makeText(this,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;)</span><br><span class="line">        VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到几乎没什么变化，只是多了一个jsonRequest的参数，通常是null</p>
<p>请求回来的JsonObject数据目前咱不知道如何使用，所以就将它转换成字符串打印出来，看网上的博客说可以搭配Ajax和jsp实现页面刷新</p>
<h3 id="五-加载图片"><a href="#五-加载图片" class="headerlink" title="五.加载图片"></a>五.加载图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun VolleyImage()&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/girl1.jpg&quot;</span><br><span class="line">        val request = ImageRequest(url,&#123;bitmap-&gt;</span><br><span class="line">			imageView.setImageBitmap(bitmap)</span><br><span class="line">        &#125;,0,0,ImageView.ScaleType.FIT_CENTER,Bitmap.Config.RGB_565,&#123;</span><br><span class="line">            Toast.makeText(this,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;)</span><br><span class="line">        VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>步骤和前面的那些请求基本一致，除了参数变多</p>
<p>参数一：url地址</p>
<p>参数二：请求成功的操作，参数为Bitmap类型</p>
<p>参数三：最大宽度，设置为0是默认</p>
<p>参数四：最大高度，同理</p>
<p>参数五：图片的拉伸方式</p>
<p>参数六：图片的透明度以及红绿蓝使用哪种模式，示例代码使用的是缓存最小的模式</p>
<h3 id="六-使用Volley中的ImageLoader加载图片"><a href="#六-使用Volley中的ImageLoader加载图片" class="headerlink" title="六.使用Volley中的ImageLoader加载图片"></a>六.使用Volley中的ImageLoader加载图片</h3><ol>
<li>创建ImageLoader，由于使用的单例所以省去创建RequestQueue这一步骤</li>
<li>通过ImageLoader提供的get方法传入url地址和实现监听的匿名内部类加载图片</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun NoCacheImagLoader()&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/girl2.jpg&quot;</span><br><span class="line">        val imageLoader = ImageLoader(</span><br><span class="line">            VolleySingleton.getInstance(applicationContext).requestQueue,</span><br><span class="line">            object :ImageLoader.ImageCache&#123;</span><br><span class="line">                override fun getBitmap(url: String?): Bitmap? &#123;</span><br><span class="line">                    return null</span><br><span class="line">                &#125;</span><br><span class="line">                override fun putBitmap(url: String?, bitmap: Bitmap?) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        //加载图片</span><br><span class="line">        imageLoader.get(url,object :ImageLoader.ImageListener&#123;</span><br><span class="line">            override fun onErrorResponse(error: VolleyError?) &#123;</span><br><span class="line">                Toast.makeText(this@MainActivity,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onResponse(response: ImageLoader.ImageContainer?, isImmediate: Boolean) &#123;</span><br><span class="line">                imageView.setImageBitmap(response?.bitmap)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方式是没有缓存的，下面展示有缓存的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">val imageLoader = ImageLoader(</span><br><span class="line">            VolleySingleton.getInstance(applicationContext).requestQueue,</span><br><span class="line">            object :ImageLoader.ImageCache&#123;</span><br><span class="line">                var mCache:LruCache&lt;String,Bitmap&gt;</span><br><span class="line">                init &#123;</span><br><span class="line">                    val maxSize = 10*1024*1024</span><br><span class="line">                    mCache = object :LruCache&lt;String,Bitmap&gt;(maxSize)&#123;</span><br><span class="line">                        override fun sizeOf(key: String?, value: Bitmap?): Int &#123;</span><br><span class="line">                            return if (value?.height==null)&#123;</span><br><span class="line">                                super.sizeOf(key, value)</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                value.rowBytes*value.height</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                override fun getBitmap(url: String?): Bitmap? &#123;</span><br><span class="line">                    return mCache.get(url)</span><br><span class="line">                &#125;</span><br><span class="line">                override fun putBitmap(url: String?, bitmap: Bitmap?) &#123;</span><br><span class="line">                    mCache.put(url,bitmap)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h3 id="七-使用NetworkImageView加载图片"><a href="#七-使用NetworkImageView加载图片" class="headerlink" title="七.使用NetworkImageView加载图片"></a>七.使用NetworkImageView加载图片</h3><p>关键步骤：</p>
<ol>
<li>设置ImageLoader</li>
<li>设置Url</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fun NetworkLoadImage()&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/girl3.jpg&quot;</span><br><span class="line">        val imageLoader = ImageLoader(</span><br><span class="line">            VolleySingleton.getInstance(applicationContext).requestQueue,</span><br><span class="line">            object :ImageLoader.ImageCache&#123;</span><br><span class="line">                var mCache:LruCache&lt;String,Bitmap&gt;</span><br><span class="line">                init &#123;</span><br><span class="line">                    val maxSize = 10*1024*1024</span><br><span class="line">                    mCache = object :LruCache&lt;String,Bitmap&gt;(maxSize)&#123;</span><br><span class="line">                        override fun sizeOf(key: String?, value: Bitmap?): Int &#123;</span><br><span class="line">                            return if (value?.height==null)&#123;</span><br><span class="line">                                super.sizeOf(key, value)</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                value.rowBytes*value.height</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                override fun getBitmap(url: String?): Bitmap? &#123;</span><br><span class="line">                    return mCache.get(url)</span><br><span class="line">                &#125;</span><br><span class="line">                override fun putBitmap(url: String?, bitmap: Bitmap?) &#123;</span><br><span class="line">                    mCache.put(url,bitmap)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        networkImageView.setImageUrl(url,imageLoader)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外还可以设置默认图片以及加载失败后的图片</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">networkImageView.setDefaultImageResId()</span><br><span class="line">networkImageView.setErrorImageResId()</span><br></pre></td></tr></table></figure>

<h3 id="八-集体效果展示"><a href="#八-集体效果展示" class="headerlink" title="八.集体效果展示"></a>八.集体效果展示</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Volley%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%90%88%E9%9B%86.gif" style="zoom: 40%;" />

<h3 id="九-总结"><a href="#九-总结" class="headerlink" title="九.总结"></a>九.总结</h3><blockquote>
<p>Volley是网络开源库第二站，与之前的Okhttp相比确实简洁很多，尤其是普通的GET和POST请求，上述的所有请求方式大致都分为三大步骤，这种异步的请求处理确实方便很多</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Volley.html" data-id="clchki9lh006lt0qhegv9cfct" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-对象序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.html" class="article-date">
  <time datetime="2021-02-02T03:18:25.000Z" itemprop="datePublished">2021-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.html">对象序列化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在实际开发中，我们会涉及到将一个对象数据存入数据库或者上传到服务器，而底层的数据传输只能以字节流的形式进行，所以本文将介绍如何将一个对象转换成字节流的形式进行数据传输，即对象的序列化</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.png" style="zoom:33%;" />

<p>当然，有序列化也会有反序列化，从数据库或者云端加载得到的二进制数据通过<strong>反序列化转换成可操作的对象数据</strong></p>
<p>对象的序列化分以下三种方式：</p>
<ol>
<li><p>Serializable</p>
<p>Java自带的原生态接口，只需要让进行序列化的类实现接口即可，做一个标记，具体的实现是JDK帮我们完成，使用也简单，但缺点是效率太低</p>
</li>
<li><p>Parcelable</p>
<p>Android系统定制的，效率更高，适合进程间的通信</p>
</li>
<li><p>XML/JSON</p>
<p>基于文本的序列化，优点很明显，可读性高，对使用者友好</p>
</li>
</ol>
<p><strong>就目前来说，我用得最多的是XML/JSON的形式，后来Google推出了GSON工具类，让JSON数据的解析更加轻松</strong></p>
<h3 id="二-Serializable的基本使用"><a href="#二-Serializable的基本使用" class="headerlink" title="二.Serializable的基本使用"></a>二.Serializable的基本使用</h3><p>上面也提到了，只要让需要进行序列化的类实现Serializable接口即可，不需要实现任何方法，只是做一个标记，具体的实现是有JDK来完成，读写文件通过<strong>Object字节流</strong>进行即可，下面通过一个小例子来演示</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/Serializable%E5%B1%95%E7%A4%BA.gif" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">data class Stuent(</span><br><span class="line">    val name:String,</span><br><span class="line">    val age:Int,</span><br><span class="line">    val score: Score</span><br><span class="line">):Serializable</span><br><span class="line">class Score(val Math:Int,val English:Int,val Chinese:Int):Serializable&#123;</span><br><span class="line">    var grade = &quot;&quot;</span><br><span class="line">    init &#123;</span><br><span class="line">        if (Math&gt;90&amp;&amp;English&gt;90&amp;&amp;Chinese&gt;90)&#123;</span><br><span class="line">            grade = &quot;A&quot;</span><br><span class="line">        &#125;else if (Math&gt;80&amp;&amp;English&gt;80&amp;&amp;Chinese&gt;80)&#123;</span><br><span class="line">            grade = &quot;B&quot;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            grade = &quot;C&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">fun saveData()&#123;</span><br><span class="line">        val math = inputMath.text.toString().toInt()</span><br><span class="line">        val english = inputEnglish.text.toString().toInt()</span><br><span class="line">        val chinese = inputChinese.text.toString().toInt()</span><br><span class="line">        val name = inputName.text.toString()</span><br><span class="line">        val age = inputAge.text.toString().toInt()</span><br><span class="line">        val score = Score(math,english,chinese)</span><br><span class="line">        val stuent = Stuent(name,age,score)</span><br><span class="line">        val objectOutputStream = ObjectOutputStream(openFileOutput(FILE_NAME, MODE_PRIVATE))</span><br><span class="line">        objectOutputStream.use &#123;</span><br><span class="line">            it.writeObject(stuent)</span><br><span class="line">            it.flush()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">fun loadData()&#123;</span><br><span class="line">        val objectInputStream = ·(openFileInput(FILE_NAME))</span><br><span class="line">        objectInputStream.use &#123;</span><br><span class="line">            val student = it.readObject() as Stuent</span><br><span class="line">            inputName.setText(student.name)</span><br><span class="line">            inputAge.setText(student.age.toString())</span><br><span class="line">            inputMath.setText(student.score.Math.toString())</span><br><span class="line">            inputEnglish.setText(student.score.English.toString())</span><br><span class="line">            inputChinese.setText(student.score.Chinese.toString())</span><br><span class="line">            showGrade.text = student.score.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>直接上代码，由于<code>Student</code>和<code>Score</code>类都需要存入文件即都需序列化，因此两个类都需实现<code>Serializable</code>接口，做标记，系统会自动识别，使用的时候只需要通过<code>ObjectOutputStream</code>写入对象即可，之后可以在data/data/包名/files目录下找到存储过后的文件，打开后全是16进制数据，可通过特殊工具查看，反序列化通过<code>ObjectInputStream</code>读取一个对象即可</p>
</blockquote>
<p> <strong>另外需要注意一点的是，需要手动添加一个long类型的静态seriaVersionUID，如果不添加，系统自动生成一个，但如果你增加了属性，那么又会生成一个新的UID，如此一来就会发生版本不兼容问题，所以最好我们自己写死一个UID</strong></p>
<h3 id="三-Parcelable"><a href="#三-Parcelable" class="headerlink" title="三.Parcelable"></a>三.Parcelable</h3><p>使用场景：在两个进程或者Activity/Fragment之间传递对象数据</p>
<p>具体使用：只需让类实现该接口，并添加相应的方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Activity1</span><br><span class="line">jump.setOnClickListener &#123;</span><br><span class="line">            val name = inputName.text.toString()</span><br><span class="line">            val age = inputAge.text.toString().toInt()</span><br><span class="line">            val math = inputMath.text.toString().toInt()</span><br><span class="line">            val english = inputEnglish.text.toString().toInt()</span><br><span class="line">            val student = Student(name,age, Score(math,english))</span><br><span class="line">            val bundle = Bundle().apply &#123;</span><br><span class="line">                putParcelable(&quot;student&quot;,student)</span><br><span class="line">            &#125;</span><br><span class="line">            Intent(this,MainActivity2::class.java).apply &#123;</span><br><span class="line">                putExtra(&quot;data&quot;,bundle)</span><br><span class="line">                startActivity(this)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//Activity2</span><br><span class="line">val bundle = intent.getBundleExtra(&quot;data&quot;)</span><br><span class="line">        val student = bundle?.getParcelable&lt;Student&gt;(&quot;student&quot;)</span><br><span class="line">        student?.let &#123;</span><br><span class="line">            showName.text = it.name</span><br><span class="line">            showAge.text = it.age.toString()</span><br><span class="line">            showMath.text = it.score?.math.toString()</span><br><span class="line">            showEnglish.text = it.score?.english.toString()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/Parcelable.gif" style="zoom:33%;" />

<p><strong>从上面的代码可以看出传递数据使用对象数据方便很多，否则需要一条一条的放进Bundle对象，太繁琐</strong></p>
<h3 id="四-XML-JSON"><a href="#四-XML-JSON" class="headerlink" title="四.XML/JSON"></a>四.XML/JSON</h3><p>网络操作常用格式，通过key-Value键值对的方式存储数据，用一对大括号表示一个单元，<strong>整个大括号</strong>对应的是一个对象，使用Google推出的Gson工具类可以轻松进行对象序列化和反序列化，下面通过代码进行演示</p>
<p>添加依赖<code> implementation &#39;com.google.code.gson:gson:2.8.6&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val student = Student(&quot;jack&quot;,18, Score(100,100))</span><br><span class="line">val gson = Gson()</span><br><span class="line">//序列化，转换成Json字符串</span><br><span class="line">val studentJson = gson.toJson(student)</span><br><span class="line">Log.v(&quot;cx&quot;,&quot;Json格式：$studentJson&quot;)</span><br><span class="line">//反序列化，将Json字符串转换成对象数据</span><br><span class="line">val jsonStr = &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:80,\&quot;Math\&quot;:80&#125;&#125;&quot;</span><br><span class="line">val student2 = gson.fromJson(jsonStr,Student::class.java)</span><br></pre></td></tr></table></figure>

<p><strong>将对象数据转换成字符串</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/jsonShow.png"></p>
<p><strong>将Json格式的字符串转换成对象数据</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/json%E8%A7%A3%E6%9E%90.png" style="zoom: 33%;" />

<p>所以只需创建一个Gson的对象，用它实现转换即可</p>
<p><strong>除此之外，Gson还可以转换对象数组，下面以一个小项目的部分代码进行展示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                   val result = response.body?.string()</span><br><span class="line">                   val students = gson.fromJson(result, Array&lt;Student&gt;::class.java)</span><br><span class="line">                   val msg = Message()</span><br><span class="line">                   msg.what = Repository.MSG_TYPE_STUDENTINFOR</span><br><span class="line">                   msg.obj = students</span><br><span class="line">                   handler.sendMessage(msg)</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>当时使用的是Okhttp进行网络请求，从服务器端返回Json字符串，即<code>result</code>，然后通过Gson转换成Student的数组类型，最后通过Handler中的Message进行数据传递，将对象数组转换成Json字符串如法炮制</p>
<p><strong>可以通过<code>TypeToken</code>创建新的类型数据</strong></p>
<p>将<code>[&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;jack&quot;,&quot;score&quot;:&#123;&quot;English&quot;:100,&quot;Math&quot;:100&#125;&#125;,&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;rose&quot;,&quot;score&quot;:&#123;&quot;English&quot;:90,&quot;Math&quot;:90&#125;&#125;,&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;xw&quot;,&quot;score&quot;:&#123;&quot;English&quot;:80,&quot;Math&quot;:80&#125;&#125;]</code>转换成<code>List类型</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val Jsonstr = &quot;[&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:100,\&quot;Math\&quot;:100&#125;&#125;,&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;rose\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:90,\&quot;Math\&quot;:90&#125;&#125;,&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;xw\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:80,\&quot;Math\&quot;:80&#125;&#125;]&quot;</span><br><span class="line">val typeStudents = object :TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.type</span><br><span class="line">val studentLists = gson.fromJson&lt;List&lt;Student&gt;&gt;(Jsonstr,typeStudents)</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/%E8%A7%A3%E6%9E%90%E6%88%90List.png" style="zoom: 40%;" />

<p><strong>如果与你对接的人对变量的命名习惯不同，那么你可以通过增加注解，为变量增添一个名字，从而解析处理的Json字符串中的变量名就是注解添加的变量名</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/json%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3.png" style="zoom:75%;" />

<p>转换结果：[{“student_age”:18,”student_name”:”jack”,”score”:{“English”:100,”Math”:100}},{“student_age”:18,”student_name”:”rose”,”score”:{“English”:90,”Math”:90}},{“student_age”:18,”student_name”:”xw”,”score”:{“English”:80,”Math”:80}}]</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>对比三种反序列化的方式，XML/JSON格式最为简单，并且可读性很高，就目前而言，也是写项目常用</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.html" data-id="clchki9kp004nt0qhf2zeaqk6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Room架构实战——记单词神器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Room%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%AE%B0%E5%8D%95%E8%AF%8D%E7%A5%9E%E5%99%A8.html" class="article-date">
  <time datetime="2021-02-01T03:22:49.000Z" itemprop="datePublished">2021-02-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Room%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%AE%B0%E5%8D%95%E8%AF%8D%E7%A5%9E%E5%99%A8.html">Room架构实战——记单词神器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面以及了解了Room的基本使用以及搭配使用MVVM架构，下面通过一个小Demo进一步巩固，顺带回顾之前所学知识点，Demo演示效果图如下：</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Room/%E8%AE%B0%E5%8D%95%E8%AF%8D%E7%A5%9E%E5%99%A8show.gif" style="zoom:40%;" />

<p>感觉效果还不错，用来记单词的话我觉得还不错，比较小型，基本的功能也具备用到的知识点如下</p>
<ol>
<li>Room高效访问数据库中的数据</li>
<li>使用MVVM搭配Repository架构</li>
<li>菜单栏的设计</li>
<li>RecyclerView，增加了滑动删除功能，这也是很多app热门使用</li>
<li>封装SharedPreferences存储简单键值对</li>
<li>自定义Dialog</li>
<li>Coroutine协程的使用</li>
</ol>
<h3 id="二-实际开发中坑点与知识点分析"><a href="#二-实际开发中坑点与知识点分析" class="headerlink" title="二.实际开发中坑点与知识点分析"></a>二.实际开发中坑点与知识点分析</h3><p>该Demo不算难，架构也清晰，但也需注意以下几点：</p>
<ol>
<li>LiveData观察的是<strong>底层数据</strong>的改变而不是中间层的引用</li>
<li>时刻注意RecyclerView的特性：回收，当ItemView达到一定数量时，滚动的过程中将不会创建新的ItemView，也就意味着，只会执行<code>onBindViewHolder</code>方法，ItemView之前绑定过的监听事件同样有效，所以监听事件的绑定就放在<code>onCreateViewHolder</code>，这样效率更高</li>
<li>理解RecyclerView中的适配器模式，同一个RecyclerView展示怎样的视图是由Adapter决定的，所以切换多个视图只需准备多个Adapter</li>
<li>清楚什么时候才应该调用<code>notifyDataSetChanged()</code>方法刷新界面，只有当数据库中的数据数量改变时才需要刷新，而单个数据内部的属性即分量改变时不需要调用此方法，该方法本身就相当消耗内存</li>
<li>掌握另一种提示框<code>Snackbar</code>，使用与<code>Toast</code>类似</li>
<li>数据库的模糊匹配搭配LiveData以及适配器模式更换数据达到数据筛选的功能</li>
<li>使用协程虽然在主线程中依然无法实现同步返回数据的功能，但在同一个协程域中可以做到，因此执行耗时任务的方法可以有返回值，只要它的执行线程不在Main线程即可，有了协程，不用去顾虑返回值能不能同步拿到的问题，只需要关心它应不应该有返回值，这是一个需要转换的观念</li>
</ol>
<h3 id="三-心得体会"><a href="#三-心得体会" class="headerlink" title="三.心得体会"></a>三.心得体会</h3><blockquote>
<p>该小Demo融合的知识点实在丰富，并且实际意义也挺大，只可惜，事时间原因不能将它做得更加完善，下面上代码链接</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/recite-words">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Room%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%AE%B0%E5%8D%95%E8%AF%8D%E7%A5%9E%E5%99%A8.html" data-id="clchki9jp001yt0qhgp5egbo3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/10/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">Android重要组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%A1%B9%E7%9B%AE/">Android项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html%E5%AD%A6%E4%B9%A0/">html学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/">系统控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%B3%BB%E5%88%97/">组件化系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">hexo博客搭建问题总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" rel="tag">学年设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" rel="tag">系统高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 18px;">Android常用琐碎知识点</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" style="font-size: 10px;">Android开发小Demo</a> <a href="/tags/Android%E9%AB%98%E7%BA%A7UI/" style="font-size: 16px;">Android高级UI</a> <a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 10px;">hexo博客搭建问题总结</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 10px;">发布开源库</a> <a href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">学年设计</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" style="font-size: 20px;">算法篇</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" style="font-size: 12px;">系统高级UI</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 14px;">网络开源库</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
          </li>
        
          <li>
            <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
          </li>
        
          <li>
            <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
          </li>
        
          <li>
            <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
          </li>
        
          <li>
            <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 EngineerOfFinger<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/%20%7C%7C%20fas%20fa-home" class="mobile-nav-link">主页</a>
  
    <a href="/archives/%20%7C%7C%20fas%20fa-archive" class="mobile-nav-link">时间轴</a>
  
    <a href="/tags/%20%7C%7C%20fas%20fa-tags" class="mobile-nav-link">标签</a>
  
    <a href="/categories/%20%7C%7C%20fas%20fa-folder-open" class="mobile-nav-link">分类</a>
  
    <a href="/link/%20%7C%7C%20fas%20fa-link" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>