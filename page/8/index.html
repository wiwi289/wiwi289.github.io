<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>梦幻泡影</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="success&#x3D;persistence">
<meta property="og:type" content="website">
<meta property="og:title" content="梦幻泡影">
<meta property="og:url" content="https://wiwiyiyi.com/page/8/index.html">
<meta property="og:site_name" content="梦幻泡影">
<meta property="og:description" content="success&#x3D;persistence">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EngineerOfFinger">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="梦幻泡影" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wiwi.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦幻泡影</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/%20%7C%7C%20fas%20fa-home">主页</a>
        
          <a class="main-nav-link" href="/archives/%20%7C%7C%20fas%20fa-archive">时间轴</a>
        
          <a class="main-nav-link" href="/tags/%20%7C%7C%20fas%20fa-tags">标签</a>
        
          <a class="main-nav-link" href="/categories/%20%7C%7C%20fas%20fa-folder-open">分类</a>
        
          <a class="main-nav-link" href="/link/%20%7C%7C%20fas%20fa-link">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wiwiyiyi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基本计算器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8.html" class="article-date">
  <time datetime="2021-03-10T12:39:41.000Z" itemprop="datePublished">2021-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8.html">基本计算器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>涉及到混合运算可能大多数朋友都会想到使用栈来存储，但对于混合运算的运算式(乘除法以及括号)我们首先得转换成前缀或者后缀表达式之后再使用栈来存储以及遍历才能完成相应运算，如果没有圆括号的混合运算还可使用两个数组进行保存操作数和操作符，而本题只有加减法搭配圆括号，由于涉及到算式的优先级问题，所以考虑使用栈进行存储，那么你可能迷惑要不要使用两个栈进行存储，显然这里是没有必要的，因为加减法可以使用1或-1来表示，因此操作数和操作符都用一个栈来存储，一旦遇到左括号就将之前的运算结果入栈，同时操作符也入栈并位于栈顶，当遇到右括号时出栈一个运算符和运算数，该过程有点类似递归，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int calculate(String s)&#123;</span><br><span class="line">        String dataString = s.replaceAll(&quot; &quot;,&quot;&quot;);</span><br><span class="line">        //保存结果</span><br><span class="line">        int res = 0;</span><br><span class="line">        int sign = 1;</span><br><span class="line">        //记录操作数</span><br><span class="line">        int num = 0;</span><br><span class="line">        Stack&lt;Integer&gt; ops = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; dataString.length(); i++) &#123;</span><br><span class="line">            char nowChar = dataString.charAt(i);</span><br><span class="line">            if (Character.isDigit(nowChar))&#123;</span><br><span class="line">                num = 10*num + nowChar-&#x27;0&#x27;;</span><br><span class="line">                if (i&lt;dataString.length()-1 &amp;&amp; dataString.charAt(i+1)&gt;=&#x27;0&#x27; &amp;&amp; dataString.charAt(i+1)&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if (nowChar==&#x27;+&#x27;||nowChar==&#x27;-&#x27;)&#123;</span><br><span class="line">                sign= nowChar==&#x27;+&#x27;? 1 : -1;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;else if (nowChar==&#x27;(&#x27;)&#123;</span><br><span class="line">                ops.push(res);</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                res = 0;</span><br><span class="line">                sign = 1;</span><br><span class="line">            &#125;else if (nowChar==&#x27;)&#x27;)&#123;</span><br><span class="line">               sign = ops.pop();</span><br><span class="line">               num = res;</span><br><span class="line">               res = ops.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res+=num*sign;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>每获得一个操作数，res需要更新，而当遇到运算符时，num置0，重新获取操作数，如果遇到左括号则将之前的res和sign入栈并恢复起始状态，进入一个括号相当于开启一个新的运算式，遇到右括号时取出位于栈顶的运算数和运算符进行合并，依次类推</p>
<h3 id="三-扩展"><a href="#三-扩展" class="headerlink" title="三.扩展"></a>三.扩展</h3><blockquote>
<p>之前提到过如果仅仅是四则运算的混合，而没有圆括号，可以使用两个数组进行操作，不需要栈，但就目前的算法而言还是有缺陷的，因为数字都放在了一个数组里面，所以无法区分操作数到底是一个几位数，所以这里挺局限的，仅对一位数进行操作</p>
</blockquote>
<p>基本思路：</p>
<p>首先遍历运算表达式的字符串，依次将数组放进一个数组，运算符放进一个数组，然后使用两个计数器分别操作两个数组取出对应的元素，由于不能统一控制循环次数，所以都采用while循环，首先取出运算符，然后根据是否之前有运算结果取操作数，如果遇到乘除号，我们需要另启一个while循环直到高级运算执行完毕，由于低级运算和高级运算返回时会导致操作数1和操作数2改变方式不同，所以需要一个变量记录是否是经过了高级运算后返回的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public static int calculate(String s) &#123;</span><br><span class="line">        String dataString = s.replaceAll(&quot; &quot;,&quot;&quot;);</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Character&gt; operatorChar = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= 0;i&lt; dataString.length();i++)&#123;</span><br><span class="line">            char nowChar = dataString.charAt(i);</span><br><span class="line">            if (Character.isDigit(nowChar))&#123;</span><br><span class="line">                nums.add(nowChar-&#x27;0&#x27;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                operatorChar.add(nowChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int firstResult = 0;</span><br><span class="line">        int secondResult = 0;</span><br><span class="line">        int firstNum = 0;</span><br><span class="line">        int secondNum = 0;</span><br><span class="line">        int i = 0,j = 0;</span><br><span class="line">        char nowOperator = &#x27; &#x27;;</span><br><span class="line">        boolean lastIsNormOperator = true;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            nowOperator= lastIsNormOperator ? operatorChar.get(i++) : nowOperator;</span><br><span class="line">            if (nowOperator==&#x27;*&#x27;||nowOperator==&#x27;/&#x27;)&#123;</span><br><span class="line">                firstNum = firstResult==0 ? nums.get(j++) : firstResult;</span><br><span class="line">                secondNum = nums.get(j++);</span><br><span class="line">                firstResult = realCalculate(firstNum,nowOperator,secondNum);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (lastIsNormOperator)&#123;</span><br><span class="line">                firstNum = firstResult==0 ? nums.get(j++) : firstResult;</span><br><span class="line">                secondNum = nums.get(j++);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                secondNum = secondResult;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i==operatorChar.size()||operatorChar.get(i)!=&#x27;*&#x27;&amp;&amp; operatorChar.get(i)!=&#x27;/&#x27;)&#123;</span><br><span class="line">                firstResult = realCalculate(firstNum,nowOperator,secondNum);</span><br><span class="line">                lastIsNormOperator = true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    char newOperator = operatorChar.get(i++);</span><br><span class="line">                    int newFirst = secondResult==0 ? secondNum :secondNum;</span><br><span class="line">                     int newSecond = nums.get(j++);</span><br><span class="line">                     secondResult = realCalculate(newFirst,newOperator,newSecond);</span><br><span class="line">                    if (i==operatorChar.size()) return realCalculate(firstNum,nowOperator,secondResult);</span><br><span class="line">                    if (operatorChar.get(i)!=&#x27;*&#x27; &amp;&amp; operatorChar.get(i)!=&#x27;/&#x27;) break;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIsNormOperator = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i==operatorChar.size()) return firstResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      int realCalculate(int first,char operator,int second)&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        switch (operator)&#123;</span><br><span class="line">            case &#x27;-&#x27;:</span><br><span class="line">                result = first-second;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;+&#x27;:</span><br><span class="line">                result = first+second;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;*&#x27;:</span><br><span class="line">                result = first*second;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;/&#x27;:</span><br><span class="line">                result = first/second;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>对于此类问题，首先应该考虑使用什么样的数据结构进行数据存储，思考是否有递归，并且应该从最简单的情况开始考虑</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8.html" data-id="clchki9kh0045t0qh53g95ei0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-桶排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%A1%B6%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-10T00:39:21.000Z" itemprop="datePublished">2021-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%A1%B6%E6%8E%92%E5%BA%8F.html">桶排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面介绍了桶思想中使用较多的计数和基数排序，下面本文介绍桶排序，其实桶排序用的很少，在特定情况下用的最多的还是计数和基数排序，因此桶排序仅做了解即可</p>
</blockquote>
<h3 id="二-桶排序原理以及代码实现"><a href="#二-桶排序原理以及代码实现" class="headerlink" title="二.桶排序原理以及代码实现"></a>二.桶排序原理以及代码实现</h3><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181130/9095a2947d144f4b960369dbc1d259d7.gif"></p>
<blockquote>
<p>原理分析：首先确定找出数组中的最大值和最小值，然后确定桶的大小即间距，通过最大最小值的差值除以间距的结果+1便是桶的数量，由于结果是整数，所以至少保证有一个桶，然后依次对每个桶进行排序即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void bucketSort(int[] arr)&#123;</span><br><span class="line">        int min=arr[0],max=arr[0];</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            min = Math.min(arr[i],min);</span><br><span class="line">            max = Math.max(arr[i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        int bucketNum = (max-min)/arr.length + 1;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        for(int i= 0;i&lt; bucketNum;i++)&#123;</span><br><span class="line">            bucket.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int elem:arr)&#123;</span><br><span class="line">            int index = (elem-min)/arr.length;</span><br><span class="line">            bucket.get(index).add(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            Collections.sort(bucket.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        int k=0;</span><br><span class="line">        for (ArrayList&lt;Integer&gt; tempList:bucket) &#123;</span><br><span class="line">            for (int elem:tempList) &#123;</span><br><span class="line">                arr[k++] = elem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n+k)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%A1%B6%E6%8E%92%E5%BA%8F.html" data-id="clchki9l5005tt0qh89wycrcb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基数排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-09T14:39:32.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html">基数排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍计数排序，它也是桶排序的一种，同时是非比较的排序，究其本质是多关键字的排序，内部其实调用了计数排序</p>
</blockquote>
<h3 id="二-基数排序原理以及代码实现"><a href="#二-基数排序原理以及代码实现" class="headerlink" title="二.基数排序原理以及代码实现"></a>二.基数排序原理以及代码实现</h3><p>首先上图解释</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190418104853042-13278997.gif" alt="img"></p>
<blockquote>
<p>原理分析：每次从个位数开始，以个位数为关键字进行计数排序，前面已经介绍过计数排序了，然后再取十位数、百位数…..依次进行计数排序，所以原理很简单，就是依次对一个数字的各位数进行计数排序，基数排序分<strong>低位优先</strong>和<strong>高位优先</strong>，本实例使用的是低位优先，及从个位数开始，高位优先属于分治的思想</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void baseSort(int[] arr,int maxDigit)&#123;</span><br><span class="line">       int[] tempArray = new int[arr.length];</span><br><span class="line">       int[] count = new int[10];</span><br><span class="line">       for (int i = 0; i &lt; maxDigit; i++) &#123;</span><br><span class="line">           int division = (int)Math.pow(10,i);</span><br><span class="line">           for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">               int num = arr[j]/division % 10;</span><br><span class="line">               count[num]++;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int m = 1; m &lt; count.length; m++) &#123;</span><br><span class="line">               count[m] = count[m] + count[m-1];</span><br><span class="line">           &#125;</span><br><span class="line">           for (int n = arr.length-1; n &gt;=0 ; n--) &#123;</span><br><span class="line">               tempArray[--count[arr[n]/division % 10]] = arr[n];</span><br><span class="line">           &#125;</span><br><span class="line">           System.arraycopy(tempArray,0,arr,0,arr.length);</span><br><span class="line">           Arrays.fill(count,0);</span><br><span class="line">       &#125;</span><br><span class="line">       for (int temp:arr) &#123;</span><br><span class="line">           System.out.print(temp + &quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   static int getDigit(int[] arr)&#123;</span><br><span class="line">       int[] copyArr = Arrays.copyOf(arr,arr.length);</span><br><span class="line">       int maxDigit = 0;</span><br><span class="line">       for (int i = 0; i &lt; copyArr.length; i++) &#123;</span><br><span class="line">           int digit = 0;</span><br><span class="line">           for(;copyArr[i]&gt;0;copyArr[i] /= 10)</span><br><span class="line">               digit++;</span><br><span class="line">           maxDigit = Math.max(maxDigit, digit);</span><br><span class="line">       &#125;</span><br><span class="line">       return maxDigit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>每进行一次计数排序需要清空count数组</li>
<li>计算数组中最高位数时需要拷贝一份数组，对拷贝数组进行操作</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html" data-id="clchki9kg0042t0qh5owk3ny3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计数排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-08T12:59:18.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html">计数排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍计数排序，它是非比较排序，同时也是桶排序的一种，计数排序应用不是很广泛，只在某种特定范围条件下使用，比如某大型企业数万名员工年龄排序，以及如何快速获取高考名次，虽然数量比较多，但是其中值的取值范围比较小</p>
</blockquote>
<h3 id="二-计数排序原理以及代码实现"><a href="#二-计数排序原理以及代码实现" class="headerlink" title="二.计数排序原理以及代码实现"></a>二.计数排序原理以及代码实现</h3><p>首先上图进行理解</p>
<p><img src="https://img-blog.csdn.net/20180924230309226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JvY2xpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<blockquote>
<p>根据动图展示，发现原理很简单，没有进行比较，首先根据值的取值范围创建一个count数组，通过某种映射关系可以建立值和count数组下标一一对应，该数组保存的是原始数组中每个值出现的次数，然后遍历原始数组，通过映射关系找到该值对应的数组下标，并且count数组中对应的值+1，直到遍历完毕，接着创建一个和原始数组长度相同的result数组，遍历count数组，通过下标值还原真实值，然后填入到result数组中，出现了多少次便填入几次</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void countSort(int[] arr)&#123;</span><br><span class="line">        int[] tempArray = new int[arr.length];</span><br><span class="line">        int[] countArray = new int[10];</span><br><span class="line">        for(int i= 0;i&lt; arr.length;i++)&#123;</span><br><span class="line">            countArray[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i= 0, k = 0;i&lt; countArray.length;i++)&#123;</span><br><span class="line">            while (countArray[i]-- &gt;0) tempArray[k++] = i;</span><br><span class="line">        &#125;     </span><br><span class="line">        for (int temp: tempArray) &#123;</span><br><span class="line">            System.out.print(temp+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//数据测试</span><br><span class="line">int[] data = &#123;7,2,3,4,5,9,1,2,4,1,3,5,7,8,9,4,6,7,1,5,2,3,5,4,4,6,1,5,8,2&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是基本的算法实现，但是该算法是不稳定的，因为排序的是整型数据，并且范围小，正好可以用元素值作为count数组的下标，但在写入最终的数组中时根本就没有管相同元素的相对位置，仅仅看重同一个元素出现了几次，下面对此算法做出改进，并将基础数据类型换成类类型，模拟实际情况</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static  void countSortObj (Student[] arr)&#123;</span><br><span class="line">        Student[] tempArray = new Student[arr.length];</span><br><span class="line">        int[] scoreCountArray = new int[10];</span><br><span class="line">        for(int i=0;i&lt; tempArray.length;i++)&#123;</span><br><span class="line">            scoreCountArray[arr[i].score]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt; scoreCountArray.length;i++)&#123;</span><br><span class="line">            scoreCountArray[i] = scoreCountArray[i]+scoreCountArray[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = arr.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">            tempArray[--scoreCountArray[arr[i].score]] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; tempArray.length; i++) &#123;</span><br><span class="line">            System.out.print(tempArray[i]+&quot; &quot;);</span><br><span class="line">            if ((i+1)%3==0)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8Fshow.png"></p>
<p>为了方便看效果，此处使用序数词演示，很明显，此算法是稳定的，实例中根据高考分数查看排名也可使用该算法</p>
<blockquote>
<p>算法改进之处：同样首先处理生成count数组，不同的是此处又在count数组的基础上做了累加数组，该处理不仅可以保存元素出现的次数，还可以保存它们的相对位置，但最后一步写入数组时必须将原数组从末尾开始遍历，下面通过图来解释</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png"></p>
<p>相信再结合代码理解会容易很多，实在佩服这个算法，妙啊！</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><strong>要实现稳定的话，使用改进后的累加数组计数</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html" data-id="clchki9lq007jt0qh1dczftsf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-快速排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-08T06:50:09.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html">快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍使用频率较高的快速排序，内部采用递归，同样是深度优先算法，个人感觉编写此算法时容易出bug</p>
</blockquote>
<h3 id="二-快速排序原理以及代码实现"><a href="#二-快速排序原理以及代码实现" class="headerlink" title="二.快速排序原理以及代码实现"></a>二.快速排序原理以及代码实现</h3><p><img src="https://img-blog.csdnimg.cn/2019060415201822.gif"></p>
<blockquote>
<p>快速排序基本思路是，首先确定一个**轴(pivot)**，通过一趟排序，实现比轴小的数都放在左边，比轴大的数都放在右边，因此我们需要定义两个指针，左指针从左往右依次查找比轴大的数，右指针从右往左查找比轴小的数，找到之后两者交换，一趟排序结束后，分成了左右两个区域，然后对左右两个区域进行递归继续排序，为了缕清思路，还是先从一趟排序开始，确定没有bug后再进行递归</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void sort(int[] arr,int leftBound,int rightBound)&#123;</span><br><span class="line">            if (leftBound &gt;= rightBound) return;</span><br><span class="line">           int mid = partition(arr,leftBound,rightBound);</span><br><span class="line">           sort(arr,leftBound,mid-1);</span><br><span class="line">           sort(arr,mid+1,rightBound);</span><br><span class="line">    &#125;</span><br><span class="line">    static int partition(int[] arr,int leftBound,int rightBound)&#123;</span><br><span class="line">        int pivot = arr[rightBound];</span><br><span class="line">        int leftPtr = leftBound;</span><br><span class="line">        int rightPtr = rightBound-1;</span><br><span class="line">        while (leftPtr &lt;= rightPtr)&#123;</span><br><span class="line">            while (leftPtr&lt;=rightPtr &amp;&amp; arr[leftPtr] &lt;= pivot) leftPtr++;</span><br><span class="line">            while (leftPtr&lt;=rightPtr &amp;&amp; arr[rightPtr] &gt; pivot) rightPtr--;</span><br><span class="line">            if (leftPtr&lt;rightPtr)  swap(arr,leftPtr,rightPtr);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,leftPtr,rightBound);</span><br><span class="line">        return leftPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp = arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>坑点分析：</strong></p>
<ol>
<li><p>外层while循环一定是左指针的小于等于右指针，因为如果最后是两个数进行排序的话，左指针或者右指针必须发生移动，否则会出现逆序</p>
</li>
<li><p>从左往右查找比轴大的数时，一定要把等于轴的数跳过，否则会出现右侧有等于轴的数</p>
</li>
<li><p>内层的两个while循环都必须加上左指针小于等于右指针的条件，否则会出现左右指针越界问题，这个可以取极端情况，比如最右侧取为轴，并且轴是最大或者最小的数，此时就会报错</p>
</li>
<li><p>一趟排序完成后，需要返回轴的位置，因为发生了交换所以左指针就是轴，其余递归是在轴的左右剩余区域再进行排序，轴不会发生位置的改变</p>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>快速排序如果不自己动手写写，根本就不会清楚里面的坑点在哪儿，到底哪些地方需要注意边界值能不能取等</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">不稳</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html" data-id="clchki9kv0054t0qhbpks7zum" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-归并排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-07T13:05:01.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html">归并排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍稍微复杂一点的排序算法——归并排序，里面采用了递归，所以它是深度优先算法，建议先复习一下递归算法，否则归并排序理解起来不是那么容易</p>
</blockquote>
<h3 id="二-归并排序原理以及代码实现"><a href="#二-归并排序原理以及代码实现" class="headerlink" title="二.归并排序原理以及代码实现"></a>二.归并排序原理以及代码实现</h3><p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif"></p>
<p>结合树形图理解</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326213950253-1393118004.png"></p>
<blockquote>
<p>归并排序主要分为两个过程，<strong>分组</strong>和**归并(Merge)**，所以在进行归并排序之前，可以先将归并算法写好，分组并不难，只需要注意分界点即可，可以使用左右已经排好序的一个数组进行归并测试，如{1,7,9,3,6,8}，分为左右两组，左右两组一次进行比较元素，小的先放进额外分配的数组中，因此归并排序的空间复杂度不再是O(1)，具体的归并算法如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void merge(int[] arr,int leftPtr,int rightPtr,int rightBound)&#123;</span><br><span class="line">       int[] testArray = new int[rightBound-leftPtr+1];</span><br><span class="line">       int i = leftPtr,j = rightPtr,k = 0;</span><br><span class="line">       while (i&lt;=rightPtr-1 &amp;&amp; j&lt;=rightBound)&#123;</span><br><span class="line">           testArray[k++] = arr[i]&lt;=arr[j] ? arr[i++]: arr[j++];</span><br><span class="line">       &#125;</span><br><span class="line">       while (i&lt;=rightPtr-1) testArray[k++] = arr[i++];</span><br><span class="line">       while (j&lt;=rightBound) testArray[k++] = arr[j++];</span><br><span class="line">       for(int m=0;m&lt; testArray.length;m++) arr[leftPtr+m] = testArray[m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>比较完毕后，肯定会有一组左边或者右边全都放进了额外数组空间中，那么还需通过一个循环将另外一个数组左边或者右边放进额外数组中，归并完毕后，需要根据已经排好序的额外数组改变原数组中元素的顺序，否则相当于没有排序</strong></p>
<h3 id="三-分组的理解以及完整代码"><a href="#三-分组的理解以及完整代码" class="headerlink" title="三.分组的理解以及完整代码"></a>三.分组的理解以及完整代码</h3><blockquote>
<p>如果是刚接触算法的朋友，可以像上面树形结构图一样画出每次的分组状态，标记出左边界、右边界、中间值的大小，画到最后是以<strong>一个元素为一组结束分组</strong>，并且第一次归并是一个元素或者两个元素进行的，值得注意的是，左边一组的右边界是<code>mid</code>，右边一组的左边界是<code>mid+1</code>，第一次分组的右边一组的右边界可以是<strong>数组长度-1</strong>，也可以是<strong>数组长度</strong>，随之改变的是<code>Merge</code>方法中右边界能不能取等于，小编使用的是<strong>数组长度-1</strong>，因此取等于，完整算法如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void sort(int[] arr,int left,int right)&#123;</span><br><span class="line">        if (left==right) return;</span><br><span class="line">        int mid = left + (right-left)/2;</span><br><span class="line">        sort(arr,left,mid);</span><br><span class="line">        sort(arr,mid+1,right);</span><br><span class="line">        merge(arr,left,mid+1,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中mid的算法需要注意，虽然上面的写法的结果和left+right除以2相同，但是如果数组长度很大时，容易超出整数范围，所以这是一个小细节</strong></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32534441/article/details/95098059">关于归并排序的时间复杂度计算可以参考此篇文章</a></p>
<blockquote>
<p>由于归并排序是稳定的，应用于java对象排序中，但目前使用的是改进后的归并排序<code>TimSort</code></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html" data-id="clchki9kv0056t0qh0tjofh0k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-希尔排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-07T12:13:30.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html">希尔排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍希尔排序，希尔排序是改进后的插入排序，虽然效率提高了，但它是不稳定的，因此很少使用</p>
</blockquote>
<h3 id="二-希尔排序原理以及代码实现"><a href="#二-希尔排序原理以及代码实现" class="headerlink" title="二.希尔排序原理以及代码实现"></a>二.希尔排序原理以及代码实现</h3><p>先上动图</p>
<p><img src="http://p2.itc.cn/images03/20200526/1b76d0ccb5ba4179bee9e177f557a7eb.gif"></p>
<blockquote>
<p>希尔排序是根据<strong>间隔</strong>来取出对应的元素，并对它们进行插入排序，外层是依次挪动的，而内层是根据间隔跳跃往前进行插入排序，最外层是控制<strong>间隔的不断减少</strong>，直到减少为1，也就是说最后一次排序是完整的插入排序，经过前面几次跳跃式的插入排序，数组中的元素大致趋势是从小到大，所以最后一次完整的插入排序很快，移动元素的次数大大减少了，这也是为什么说希尔排序是插入排序的改进版本，但由于它是跳跃式的，如果存在相同元素，它们的相对位置可能发生改变，所以希尔排序是不稳定的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void shellSort(int[] dataArray)&#123;</span><br><span class="line">        for (int gap = 4; gap&gt;0; gap/=2) &#123;</span><br><span class="line">            for(int i=gap;i&lt; dataArray.length;i++)&#123;</span><br><span class="line">                for(int j= i;j&gt;gap-1;j-=gap)&#123;</span><br><span class="line">                    if (dataArray[j-gap]&gt;dataArray[j])&#123;</span><br><span class="line">                        int temp = dataArray[j];</span><br><span class="line">                        dataArray[j] = dataArray[j-gap];</span><br><span class="line">                        dataArray[j-gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上算法需要注意的是第二层for循环是<code>i++</code>，而不是<code>i+=gap</code>，只有进行插排时才是向前跳跃间隔比较查找</p>
</blockquote>
<h3 id="三-间隔数的设置"><a href="#三-间隔数的设置" class="headerlink" title="三.间隔数的设置"></a>三.间隔数的设置</h3><p>希尔排序间隔数的设置也是挺有讲究的，不同的间隔显然效率不同，间隔大时移动次数比较少，间隔小时移动距离比较短，而希尔排序的创始人想的是以数组大小的一半为起始间隔，然后依次折半，但这并不是效率最高的，下面介绍一种间隔序列：<strong>Knuth序列</strong></p>
<p>首先根据公式以及约束条件求出最大的间隔h</p>
<p>h = 1</p>
<p>h = h*3+1 -&gt; 1、4、13…..</p>
<p>约束条件是h小于数组的长度除以3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int h = 1;</span><br><span class="line">while (h&lt; dataArray.length/3)&#123;</span><br><span class="line">       h = 3*h + 1;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时，gap = (gap-1)/3，gap的初值是h</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>1.3</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>希尔排序很少用，记住它的时间复杂度即可，以及它是不稳定的</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html" data-id="clchki9ks004ut0qh9sxm3yyw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-插入排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-07T07:31:55.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html">插入排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍插入排序，也是简单排序中的一种，它是稳定的</p>
</blockquote>
<h3 id="二-插入排序原理"><a href="#二-插入排序原理" class="headerlink" title="二.插入排序原理"></a>二.插入排序原理</h3><p>首先先配上一种动图演示插入排序的基本原理</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325144034879-1237555952.gif"></p>
<blockquote>
<p>原理也很简单，有点类似往前的冒泡排序，取出一个数，将它与前面的数进行比较，如果比它小则前面的数往后挪一个位置，然后将它插入，动图也很形象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void insertSort(int[] dataArray)&#123;</span><br><span class="line">        for(int i=0;i&lt; dataArray.length-1;i++)&#123;</span><br><span class="line">            for(int j= i+1;j&gt;0;j--)&#123;</span><br><span class="line">                if (dataArray[j]&lt;dataArray[j-1])&#123;</span><br><span class="line">                    int temp;</span><br><span class="line">                    temp = dataArray[j-1];</span><br><span class="line">                    dataArray[j-1] = dataArray[j];</span><br><span class="line">                    dataArray[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此算法还可以优化，为了减少交换次数，我们可以先将前面所有比它大的元素往后挪动，最后才插入进去，改进如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void insertSort(int[] dataArray)&#123;</span><br><span class="line">        for(int i=0;i&lt; dataArray.length-1;i++)&#123;</span><br><span class="line">            int j = i+1;</span><br><span class="line">            int temp = dataArray[j];</span><br><span class="line">            for(;j&gt;0;j--)&#123;</span><br><span class="line">                if (temp&lt;dataArray[j-1])&#123;</span><br><span class="line">                   dataArray[j] = dataArray[j-1];</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dataArray[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><strong>总结一下三种简单排序算法</strong></p>
<ol>
<li>冒泡：基本不用，太慢</li>
<li>选择：基本不用，不稳</li>
<li>插入：样本小且基本有序的情况效率高</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html" data-id="clchki9l1005it0qhay2046jq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-选择排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-06T15:36:27.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html">选择排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍选择排序的原理以及为什么选择排序是不稳定的，由于它的不稳定性，选择排序基本被废弃，不用于项目中</p>
</blockquote>
<h3 id="二-选择排序原理分析和算法实现"><a href="#二-选择排序原理分析和算法实现" class="headerlink" title="二.选择排序原理分析和算法实现"></a>二.选择排序原理分析和算法实现</h3><p>先上动图理解选择排序</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325085919297-1818609484.gif"></p>
<p>个人感觉选择排序和冒泡排序是反着来的，选择排序是前面作为有序区，后面作为无序区，每一趟排序都是将<strong>无序区中的第一个元素作为最小的元素</strong>，然后往后比较查找比它更小的元素位置，查找完后进行交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ChooseSort &#123;</span><br><span class="line">    static void chooseSort(Element[] dataArray)&#123;</span><br><span class="line">        int minPos;</span><br><span class="line">        int j;</span><br><span class="line">        for(j=0;j&lt;dataArray.length - 1;j++) &#123;</span><br><span class="line">            minPos = j;</span><br><span class="line">            for (int i = j; i &lt; dataArray.length; i++) &#123;</span><br><span class="line">                minPos = dataArray[minPos].value &gt; dataArray[i].value ? i : minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            Element temp = dataArray[minPos];</span><br><span class="line">            dataArray[minPos] = dataArray[j];</span><br><span class="line">            dataArray[j] = temp;</span><br><span class="line">            for (Element temp2:dataArray) &#123;</span><br><span class="line">                System.out.print(temp2+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Element[] datas = &#123;new Element(5,&quot;first&quot;),new Element(8,&quot;second&quot;)</span><br><span class="line">                ,new Element(9,&quot;third&quot;),new Element(6,&quot;fourth&quot;),</span><br><span class="line">                new Element(5,&quot;fifth&quot;),</span><br><span class="line">                new Element(1,&quot;sixth&quot;),new Element(7,&quot;seventh&quot;)</span><br><span class="line">                ,new Element(4,&quot;eighth&quot;)   &#125;;</span><br><span class="line">        chooseSort(datas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public class Element &#123;</span><br><span class="line">    int value;</span><br><span class="line">    String tag;</span><br><span class="line">    public Element(int value, String tag) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &#x27;(&#x27;+&quot;value:&quot;+value+&quot; tag:&quot;+tag+&#x27;)&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我对此处进行排序的元素进行了封装，为了能够演示选择排序的不稳定性，多加了一个标记<code>Tag</code></p>
</blockquote>
<h3 id="三-选择排序的不稳定性"><a href="#三-选择排序的不稳定性" class="headerlink" title="三.选择排序的不稳定性"></a>三.选择排序的不稳定性</h3><p>首先引出不稳定性的概念：</p>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法</p>
<p>根据以上描述以及代码，下面演示一下选择排序的不稳定性：</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%80%89%E6%8B%A9%E4%B8%8D%E7%A8%B3%E5%AE%9A.png"></p>
<p>根据最终的排序结果可以看到，第一个5和第二个5相对位置发生了改变，因此不稳定，这种不稳定性弊端明显，如果你排序的元素还有其他变量域类似于此处的<code>tag</code>，并且其他变量域根据某种排序规则已经排好序了，那么这种结果肯定是我们不想要的，并且徒增麻烦，如果使用冒泡排序对以上的元素进行排序，相同<code>value</code>的相对位置是不会改变的</p>
<h3 id="四-选择排序稳定化"><a href="#四-选择排序稳定化" class="headerlink" title="四.选择排序稳定化"></a>四.选择排序稳定化</h3><p>下面对上面不稳定的算法进行优化，让它变成稳定的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void BubbleSortOptimization(Element[] dataArray)&#123;</span><br><span class="line">       boolean hasExchanged = true;</span><br><span class="line">       int lastPosition = dataArray.length-1;</span><br><span class="line">       int k = 0;</span><br><span class="line">       for(int i=dataArray.length-1;i&gt;0&amp;&amp;hasExchanged;i--)&#123;</span><br><span class="line">           hasExchanged = false;</span><br><span class="line">           for(int j = 0; j&lt;lastPosition; j++)&#123;</span><br><span class="line">               Element temp;</span><br><span class="line">               if (dataArray[j].value&gt;dataArray[j+1].value)&#123;</span><br><span class="line">                   temp = dataArray[j+1];</span><br><span class="line">                   dataArray[j+1] = dataArray[j];</span><br><span class="line">                   dataArray[j]=temp;</span><br><span class="line">                   hasExchanged = true;</span><br><span class="line">                   k = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for (Element temp2:dataArray) &#123;</span><br><span class="line">               System.out.print(temp2+&quot; &quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">           lastPosition = k;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34437210/article/details/106928384?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-5-106928384.pc_agg_rank_aggregation&utm_term=%E7%A8%B3%E5%AE%9A%E7%9A%84%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&spm=1000.2123.3001.4430">上面的思路来自此篇文章</a></p>
<p>通过依次往后挪动的方式来保证元素之前的相对性，但代价是付出了更多的时间，最坏的情况时间增加了一倍，虽然复杂度还是O(n<sup>2</sup>)</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">不稳</td>
</tr>
</tbody></table>
<blockquote>
<p>选择排序容易理解，但项目中基本不用，就算使用了稳定版的选择排序，耗时也很多</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html" data-id="clchki9lv007zt0qh1qoidva5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-冒泡排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-06T13:02:50.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html">冒泡排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>从今天开始，小编将开始一段新的章程–算法，算法是计算机专业比较重要的一门学科，很多算法思想也会在项目中使用到，下面将以排序中的冒泡排序作为开端</p>
</blockquote>
<h3 id="二-冒泡排序描述"><a href="#二-冒泡排序描述" class="headerlink" title="二.冒泡排序描述"></a>二.冒泡排序描述</h3><p>首先上图演示冒泡排序的原理</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif"></p>
<p>冒泡排序是比较好理解的，分两层循环，内层是控制每一趟，外层是控制总的趟数，如果理不清思路，可以先从一趟冒泡开始，每一趟排序都是让最大的数沉底，每次都是两两比较所以冒泡排序是很稳定的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BubbleSortOptimization &#123;</span><br><span class="line">    static void BubbleSortOptimization(int[] dataArray)&#123;       </span><br><span class="line">        for(int i=dataArray.length-1;i&gt;0;i--)&#123;          </span><br><span class="line">            for(int j = 0; j&lt;i; j++)&#123;</span><br><span class="line">                int temp = 0;</span><br><span class="line">                if (dataArray[j]&gt;dataArray[j+1])&#123;</span><br><span class="line">                    temp = dataArray[j+1];</span><br><span class="line">                    dataArray[j+1] = dataArray[j];</span><br><span class="line">                    dataArray[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是实现冒泡排序最基本的方式，但是缺点很明显，无论是最好的情况还是最坏的情况，时间复杂度都是O(n<sup>2</sup>)，因此做以下算法优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void BubbleSortOptimization(int[] dataArray)&#123;</span><br><span class="line">      boolean hasExchanged = true;</span><br><span class="line">      int lastPosition = dataArray.length-1;</span><br><span class="line">      int k = 0;</span><br><span class="line">      for(int i=dataArray.length-1;i&gt;0&amp;&amp;hasExchanged;i--)&#123;</span><br><span class="line">          hasExchanged = false;</span><br><span class="line">          for(int j = 0; j&lt;lastPosition; j++)&#123;</span><br><span class="line">              int temp = 0;</span><br><span class="line">              if (dataArray[j]&gt;dataArray[j+1])&#123;</span><br><span class="line">                  temp = dataArray[j+1];</span><br><span class="line">                  dataArray[j+1] = dataArray[j];</span><br><span class="line">                  dataArray[j]=temp;</span><br><span class="line">                  hasExchanged = true;</span><br><span class="line">                  k = j;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          lastPosition = k;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此段代码优化了两点，第一点是如果给出的数组是<strong>前半部分排好序的</strong>，那么在某一趟排序中肯定是没有元素交换的，因此可以利用这一点做一个标注，如果某趟排序没有交换元素，就证明已经排好序了，这里通过一个布尔值来标识，第二点是如果某个给定的数组是<strong>后半部分排好序的</strong>，那么可以省略掉几趟排序，我们只需要记录上一趟排序进行<strong>最后一次元素交换的位置</strong>即可，此位置以后都是排好序的，那么下一趟排序就只需要比较到记录位置即可，中间省去了几次比较，也是一种优化方式</p>
</blockquote>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>冒泡排序算是比较简单好用的一种排序方式，初学者都应掌握，下面列出冒泡排序相关性质</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p>所谓空间复杂度是使用多少<strong>额外的空间</strong></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html" data-id="clchki9ka003ft0qhd9mz3e8h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">Android重要组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%A1%B9%E7%9B%AE/">Android项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html%E5%AD%A6%E4%B9%A0/">html学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/">系统控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%B3%BB%E5%88%97/">组件化系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">hexo博客搭建问题总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" rel="tag">学年设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" rel="tag">系统高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 18px;">Android常用琐碎知识点</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" style="font-size: 10px;">Android开发小Demo</a> <a href="/tags/Android%E9%AB%98%E7%BA%A7UI/" style="font-size: 16px;">Android高级UI</a> <a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 10px;">hexo博客搭建问题总结</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 10px;">发布开源库</a> <a href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">学年设计</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" style="font-size: 20px;">算法篇</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" style="font-size: 12px;">系统高级UI</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 14px;">网络开源库</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
          </li>
        
          <li>
            <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
          </li>
        
          <li>
            <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
          </li>
        
          <li>
            <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
          </li>
        
          <li>
            <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 EngineerOfFinger<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/%20%7C%7C%20fas%20fa-home" class="mobile-nav-link">主页</a>
  
    <a href="/archives/%20%7C%7C%20fas%20fa-archive" class="mobile-nav-link">时间轴</a>
  
    <a href="/tags/%20%7C%7C%20fas%20fa-tags" class="mobile-nav-link">标签</a>
  
    <a href="/categories/%20%7C%7C%20fas%20fa-folder-open" class="mobile-nav-link">分类</a>
  
    <a href="/link/%20%7C%7C%20fas%20fa-link" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>