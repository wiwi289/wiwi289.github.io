<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>梦幻泡影</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="success&#x3D;persistence">
<meta property="og:type" content="website">
<meta property="og:title" content="梦幻泡影">
<meta property="og:url" content="https://wiwiyiyi.com/page/6/index.html">
<meta property="og:site_name" content="梦幻泡影">
<meta property="og:description" content="success&#x3D;persistence">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EngineerOfFinger">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="梦幻泡影" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wiwi.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦幻泡影</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/%20%7C%7C%20fas%20fa-home">主页</a>
        
          <a class="main-nav-link" href="/archives/%20%7C%7C%20fas%20fa-archive">时间轴</a>
        
          <a class="main-nav-link" href="/tags/%20%7C%7C%20fas%20fa-tags">标签</a>
        
          <a class="main-nav-link" href="/categories/%20%7C%7C%20fas%20fa-folder-open">分类</a>
        
          <a class="main-nav-link" href="/link/%20%7C%7C%20fas%20fa-link">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wiwiyiyi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-被吊打的第一天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E8%A2%AB%E5%90%8A%E6%89%93%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9.html" class="article-date">
  <time datetime="2021-07-19T12:14:18.000Z" itemprop="datePublished">2021-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E8%A2%AB%E5%90%8A%E6%89%93%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9.html">被吊打的第一天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>实习生活开始有几天了，近两天接触到了UI相关的bug修复，因为维护的是近十年的老项目，所以对项目结构一脸懵逼，大量的时间花在了找代码位置的时间上，虽然看似很简单，但却弄复杂了，瞎折磨了近两天，结果被别人20分钟搞定，有点难以接受，也因此多了一些感悟吧，码代码这么久，头一回被吊打，[泪崩]</p>
</blockquote>
<h3 id="二-具体任务分析"><a href="#二-具体任务分析" class="headerlink" title="二.具体任务分析"></a>二.具体任务分析</h3><p>接到的任务有以下三个：</p>
<ol>
<li>更改某处图片(主要是通过工具找位置)</li>
<li>扩大点击事件的响应范围</li>
<li>更改icon以及大小等等</li>
</ol>
<p>总的来说，麻烦的就第二和第三，第三个任务是真的磨人，UI设计的小姐姐把图纸发给你，你真的就可能很懵逼，毕竟是两个维度，她不会将view的嵌套关系给你画出来，只会给一个大概，然后你如果对层层嵌套的布局不熟悉的话，是真的要吐血，因为你在设置间距和大小的时候总会发现位置不对或者超出视图范围，哎，真的难顶，另外，你如果不会使用工具来抓捕视图的话，真的会徘徊在源码的世界，甚至迷失自我。</p>
<p><strong>重点：</strong>第二个任务其实很简单，但就是容易踩坑，突然发现自己很久没有接触UI方面的东西，很多都有点手生，扩大响应范围，我最原始的想法是将零零散散的view通过一层布局包裹来实现，这样点击整个大的嵌套布局就可以轻松实现功能，然后很开心，结果导师说不推荐这样做，毕竟多一层嵌套会多一些视图上的计算以及事件传递啥的，效率不高，虽然这是一个简单又傻冒的想法，后来我折磨了一个晚上，通过事件拦截的方式处理你需要响应外的区域，如果落在外面就直接拦截并消费，不需要再传递给子view，但太久没用，所以调试了很久，踩了很多坑，建议对<code>OnTouchEvent</code>、<code>onInterceptTouchEvent</code>足够了解以及能够使用，另外就是矩形区域的使用，判断触摸点是否在区域内，这都是很基本的了，最后我实现了这个功能。可第二天导师说不行，区域还不够，其实中间有一个bug，我比较投机取巧的解决了，但确实不够灵活，我giao，然后继续看代码流程，看UI，当我总算弄清楚所有布局的时候，却发现无法解决，导师也是这样说，所以我干了个寂寞，再到最后，我的布局更改有问题，代码实现不符规定，唉，奈何时间紧，只能看着导师一顿操作猛如虎，20分钟搞定，直接喷血了。。。。</p>
<h3 id="三-第一次改bug小总结"><a href="#三-第一次改bug小总结" class="headerlink" title="三.第一次改bug小总结"></a>三.第一次改bug小总结</h3><p>看着导师的资深操作，我看呆了，当然了，他对项目整体的把握没得说，所以上来直接开改，其实改UI这种事情一定要落到实处，踏踏实实去做，一点点修改，有局部观的同时要顾及总体，所以你看到尺寸并非就是你要设置的尺寸，你得根据层层嵌套来分析到底需要预留多少才能得出实际应该设置多少的值，我缺少的就是总体观，做的很随意，所以处处都不对，唉，确实挺惨，得好好改改。另外就是，第二处bug根本就不需要做事件拦截，只需要给整个大的view添加一个点击事件，然后再给局部不需要响应的区域添加一个空的点击事件，相当于直接消费了，就不会回传到根视图，只觉得这种思想很牛逼，所以有空再把事件传递机制好好看看。只觉得刚来就有点心浮气躁，不过最近确实烦心吧，本来就是一个小菜鸟，还是得虚心学习，但被吊打还是得习惯。</p>
<h3 id="四-推荐使用的视图分析小工具"><a href="#四-推荐使用的视图分析小工具" class="headerlink" title="四.推荐使用的视图分析小工具"></a>四.推荐使用的视图分析小工具</h3><p>在Android Studio提供了一个非常nice的工具<strong>Legacy Layout Inspector</strong>，连上你的手机，就可抓捕当前的页面，你可以下拉进行选择，因为有的时候会有Dialog之类，这个也是可以抓捕的，具体操作流程如下：</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/as%E8%A7%86%E5%9B%BE%E6%8A%93%E6%8D%95%E5%B7%A5%E5%85%B7.png" style="zoom:40%;" />

<p>然后在Tools工具中就可以看到了，我觉得对实习小白来说真的是一个非常nice的工具，至少你不会因为看不懂界面布局而头疼，也不会因为找不到某个控件id而发愁</p>
<p>然后就是开发者选项中也有一个非常好用的工具</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.jpg"></p>
<p>你打开指针位置显示和边界布局，也可以清晰的看到页面中的布局是怎样的，就这两个工具已经可以供你快速熟悉公司项目了，只能说得心应手，很爽</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E8%A2%AB%E5%90%8A%E6%89%93%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9.html" data-id="clchki9lp007et0qhdz1p02b1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Dagger-Hilt实现依赖注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Dagger-Hilt%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html" class="article-date">
  <time datetime="2021-07-11T09:09:59.000Z" itemprop="datePublished">2021-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Dagger-Hilt%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html">Dagger&amp;&amp;Hilt实现依赖注入</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>关于依赖注入部分小编也是刚上手，其实在日常项目的开发中我们经常会使用到依赖注入，但是很多时候我们的原生方式效率不高，代码量过大，导致结构不清晰，因为依赖注入这部分代码其实不是核心部分，不影响整体结构，所以我们应该尽量让它们变得简洁，因此我们会选用Dagger或Hilt的依赖注入库来实现这部分功能，让代码更加灵活</p>
</blockquote>
<h3 id="二-什么是依赖注入"><a href="#二-什么是依赖注入" class="headerlink" title="二.什么是依赖注入"></a>二.什么是依赖注入</h3><blockquote>
<p>依赖注入，说白了就是从其他地方获取到你需要的对象，下面通过两个小例子来进行展示</p>
</blockquote>
<ol>
<li><p>通过参数传递实现注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyClass constructor(val user: User) &#123;&#125;</span><br><span class="line">data class User(id:Int,name:String)</span><br></pre></td></tr></table></figure></li>
<li><p>通过函数(代码块)实现注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object UserProvideFactory &#123;</span><br><span class="line">    fun getUser() = User(1,&quot;cx&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fun main()&#123;</span><br><span class="line">    val user = UserProvideFactory.getUser()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当然了，方式有很多，比如还有set方法、使用接口等，对于上述两种方式，对于Kotlin来说还好，比较简洁，但是代码量也是有的，例如第二种方式需要提供一个工厂类进行管理这类似的所有方法，对于庞大的项目来说，这种代码是没有任何意义的，下面通过开源工具进行简化</p>
<h3 id="三-Dagger实现依赖注入"><a href="#三-Dagger实现依赖注入" class="headerlink" title="三.Dagger实现依赖注入"></a>三.Dagger实现依赖注入</h3><blockquote>
<p>Hilt是在Dagger的基础上做了一层封装，解决了Dagger一些比较繁琐的代码问题，所以我们先从从Dagger进行了解</p>
</blockquote>
<ol>
<li><p>添加依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#x27;kotlin-kapt&#x27;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.dagger:dagger:2.x&#x27;</span><br><span class="line">    kapt &#x27;com.google.dagger:dagger-compiler:2.x&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建提供依赖的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class User @Inject constructor()&#123;</span><br><span class="line"> override fun toString(): String &#123;</span><br><span class="line">    return &quot;hello my name is cx&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建使用依赖对象的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    @Inject lateinit var user: User</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">         Log.v(&quot;cx&quot;,&quot;用户的信息是：$user&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建依赖注入组件</p>
<p>到这一步，依赖项的提供方和需求方都有了，只需要第三者将提供方的数据注入到需求方即可，就像医生(依赖注入组件)将药品(依赖提供方)注射到患者(依赖需求方)体内即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">interface Maincomponent &#123;</span><br><span class="line">    fun inject(activity: MainActivity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的实现是在编译时系统帮我们完成的，会生成对应的一个子类DaggerMaincompnent(根据命名来拼接的)</p>
</li>
<li><p>最后在使用时完成注入，即调用inject方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DaggerMainComponent.builder()</span><br><span class="line">    .build()</span><br><span class="line">    .inject(this)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>以上步骤完成了没有参数的依赖注入，显然在实际开发中User是需要传入参数的，@Inject注解只能提供无参的依赖项，如果要提供有参的依赖项需要自定义依赖提供方</strong></p>
<h3 id="四-Dagger的进阶使用"><a href="#四-Dagger的进阶使用" class="headerlink" title="四.Dagger的进阶使用"></a>四.Dagger的进阶使用</h3><ol>
<li><p>自定义有参的依赖提供方</p>
<p>使用<code>@Module</code>注解定义提供方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">class MainUserModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    fun provideUser() = User(1,&quot;cx&quot;)</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">class User (val id:Int,val name:String)&#123;</span><br><span class="line">    override fun toString(): kotlin.String &#123;</span><br><span class="line">        return &quot;(id:$id-name:$name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Component关联依赖提供方Module</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component(modules = [MainUserModule::class])</span><br><span class="line">interface MainComponent &#123;</span><br><span class="line">    fun inject(activity:MainActivity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用同无参数时相同</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/module%E8%87%AA%E5%AE%9A%E4%B9%89.png"></p>
</li>
<li><p>@Name注解的使用</p>
<p>如果你需要注入不同的User，此时你必须对它们进行分类，标识</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    @Named(&quot;xw&quot;)</span><br><span class="line">    @Provides</span><br><span class="line">    public User getUser1()&#123;</span><br><span class="line">        return new User(1,&quot;小王&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Named(&quot;xl&quot;)</span><br><span class="line">    @Provides</span><br><span class="line">    public User getUser2()&#123;</span><br><span class="line">        return new User(2,&quot;小李&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">MainActivity中使用</span><br><span class="line">@Named(&quot;xw&quot;)</span><br><span class="line">    @Inject</span><br><span class="line">    User xw;</span><br><span class="line"></span><br><span class="line">    @Named(&quot;xl&quot;)</span><br><span class="line">    @Inject</span><br><span class="line">    User xl;</span><br></pre></td></tr></table></figure>

<p><strong>注：此处我使用的是java版本，相同的代码Kotlin会编译出错，目前原因未知</strong></p>
</li>
<li><p>@Qualifier</p>
<p>@Name注解是建立在@Qualifier的基础上实现的，但Name注解需要传入字符串容易写错，所以很多时候还是优先考虑使用Qualifier自定义标识符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Retention(AnnotationRetention.RUNTIME)</span><br><span class="line">annotation class QualifierXW</span><br><span class="line"></span><br><span class="line">@Qualifier</span><br><span class="line">@Retention(AnnotationRetention.RUNTIME)</span><br><span class="line">annotation class QualifierXL</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@QualifierXW</span><br><span class="line">    @Provides</span><br><span class="line">    fun getUser1() = User(1,&quot;小王&quot;)</span><br><span class="line"></span><br><span class="line">    @QualifierXL</span><br><span class="line">    @Provides</span><br><span class="line">    fun getUser2() = User(1,&quot;小李&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>@Singleton实现单例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">class SingleUserModule &#123;</span><br><span class="line">    @Singleton</span><br><span class="line">    @Provides</span><br><span class="line">    fun getSingleInstance() = User(4,&quot;Unique&quot;)</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = [SingleUserModule::class])</span><br><span class="line">interface SingleComponent &#123;</span><br><span class="line">    fun inject(activity: MainActivity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来注入的对象都会是同一个</p>
<p>另外也可以使用自定义的@Scope(即自定义作用域)来实现单例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@MustBeDocumented</span><br><span class="line">@Retention(value = AnnotationRetention.RUNTIME)</span><br><span class="line">annotation class MyCustomScope</span><br></pre></td></tr></table></figure>

<p>然后在依赖项提供源和依赖项提供者之间使用该注解就会注入同一对象，和使用@Singleton方式一样</p>
</li>
</ol>
<h3 id="四-Hilt实现依赖注入"><a href="#四-Hilt实现依赖注入" class="headerlink" title="四.Hilt实现依赖注入"></a>四.Hilt实现依赖注入</h3><p>在了解了Dagger实现依赖注入后，再来学Hilt会很轻松，通过以上的步骤，发现Dagger其实使用有点繁琐，在Activity中也有类似于手动注入的代码，不够简洁，而Hilt便解决了这个问题</p>
<ol>
<li><p>添加配置</p>
<p>1⃣️将 <code>hilt-android-gradle-plugin</code> 插件添加到项目的根级 <code>build.gradle</code> 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath &#x27;com.google.dagger:hilt-android-gradle-plugin:2.28-alpha&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2⃣️应用 Gradle 插件并在 <code>app/build.gradle</code> 文件中添加以下依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#x27;kotlin-kapt&#x27;</span><br><span class="line">apply plugin: &#x27;dagger.hilt.android.plugin&#x27;</span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;</span><br><span class="line">    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3⃣️Hilt 使用 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/write/java8-support?hl=zh-cn">Java 8 功能</a>。如需在项目中启用 Java 8，请将以下代码添加到 <code>app/build.gradle</code> 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@HiltAndroidApp定义Hilt应用类，该注解会触发Hilt的代码生成操作，该基类充当应用级依赖项容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@HiltAndroidApp</span><br><span class="line">class MyApp :Application()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在Manifest文件中进行配置</p>
</li>
<li><p>@AndroidEntryPoint将依赖项注入 Android 类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@AndroidEntryPoint</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义数据类，通过@Inject实现注入，和Dagger的用法相同，不过此种方式不能用于传参的构造函数</p>
</li>
<li><p>如果需要注入有参数的对象，则需要定义Module具体提供，和Dagger用法相同，不过，Hilt不需要Component这个中间着，直接通过@InstallIn(ActivityComponent::class)注解进行指定由谁来完成依赖注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Word @Inject constructor(val word:String,val meaning:String) &#123;</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;Word(word=&#x27;$word&#x27;, meaning=&#x27;$meaning&#x27;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@Module</span><br><span class="line">@InstallIn(ActivityComponent::class)</span><br><span class="line">class MainModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    fun provideWord() = Word(&quot;hello&quot;,&quot;你好&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Binds注解，上面我们提供的注入都是某个具体的类，如果想注入一个借口对象，则只能使用@Binds注解来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface APIService &#123;&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">class MyService:APIService &#123;&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@Module</span><br><span class="line">@InstallIn(ActivityComponent::class)</span><br><span class="line">abstract class MainModule &#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        @Provides</span><br><span class="line">        fun provideWord() = Word(&quot;hello&quot;,&quot;你好&quot;)</span><br><span class="line"></span><br><span class="line">        @Provides</span><br><span class="line">        fun provideAPIService() = MyService()</span><br><span class="line">    &#125;</span><br><span class="line">    @Binds</span><br><span class="line">    abstract fun bindService(myService: MyService):APIService</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来就可以在Activity中注入接口对象</p>
</li>
</ol>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>历时两天，踩了很多坑，Dagger和Hilt的相似度很高，只是Hilt更加简洁而已，个人感觉重点是要会自定义Module提供数据源，可以搭配网络访问框架Retrofit和Okhttp进行组合练习</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Dagger-Hilt%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html" data-id="clchki9j7000st0qh3x99goqc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-error-src-refspec-master-does-not-match-any" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/error-src-refspec-master-does-not-match-any.html" class="article-date">
  <time datetime="2021-05-19T11:08:34.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/error-src-refspec-master-does-not-match-any.html">error: src refspec master does not match any.</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>可以说Git版本控制在项目开发中相当重要，但有本地仓库还不够，还得将我们的仓库部署到远端，以实现合作，这类教程文章网上很多，在此不作赘述，小编今天在进行本地仓库部署到远端时发生了标题所示的错误，网上的博客都没效，经过两个小时的折腾才测试出问题所在，个人感觉是Windows系统的问题，只能说Mac从不会发生今天这种奇奇怪怪的问题。</p>
</blockquote>
<h3 id="二-原因分析"><a href="#二-原因分析" class="headerlink" title="二.原因分析"></a>二.原因分析</h3><p>小编按照某篇使用Mac实现本地仓库部署到远端的教程，在Github上创建了一个具有<strong>README.md、LISCENSE、.gitignore</strong>三个基本初始化的文件的一个仓库，问题就出在这儿，经过后面的测试，发现在Windows系统上将这样的一个仓库拷贝到本地，然后在push到远端时发生标题所示错误，这个时候本地仓库并不是空的，但就是推送失败，url也是正确的，所以强制要求在创建github仓库时必须创建一个空仓库，还挺无语的，不过没关系，上述的三个初始化文件可以后面自己手动添加，下面介绍一下从clone到push的完整过程。</p>
<h3 id="三-本地仓库和远端仓库clone-gt-push的全过程"><a href="#三-本地仓库和远端仓库clone-gt-push的全过程" class="headerlink" title="三.本地仓库和远端仓库clone-&gt;push的全过程"></a>三.本地仓库和远端仓库clone-&gt;push的全过程</h3><ol>
<li><p>在github上创建一个<strong>空仓库</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git1.png" style="zoom:50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git2.png" style="zoom: 33%;" /></li>
<li><p>将远端仓库clone到本地文件夹中(通常是某个Android项目的根目录)</p>
<p>通过<code>git clone 仓库地址</code>命令来下载远端仓库以及对应的文件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git3.png" style="zoom:50%;" /></li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git4.png" style="zoom: 50%;" />

<p>​        将拷贝的文件夹下的所有内容复制到项目根目录后，删除拷贝的文件夹，那么此时，项目根目录就是本地仓库，并且与远端仓库一一        对应</p>
<ol start="3">
<li><p>通过<code>git add .</code>将项目根目录的文件添加到缓存区中</p>
</li>
<li><p><code>git commit -m 推送说明</code>将缓存区中的文件提交到本地仓库中</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git5.png" style="zoom: 67%;" /></li>
<li><p>最后通过<code>git push origin master</code>将本地仓库部署到远端</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git6.png"></p>
</li>
</ol>
<p>经过以上步骤，我们就完成了本地仓库关联远端仓库并部署到远端的操作</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git7.png" style="zoom: 50%;" />

<p>可以看到README文件确实提交上去了，gitignore文件不需要手动创建，Android Studio会帮我们创建好的，所以只需要push即可，最后是LICSENSE文件的创建</p>
<p>①点击add file</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git8.png" style="zoom:50%;" />

<p>②填入文件类型后会出现选择对应模板的选项</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git9.png"></p>
<p>③具体创建</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git10.png" style="zoom: 50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git11.png" style="zoom:50%;" />

<p>④刷新后可以发现创建成功</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git12.png" style="zoom:50%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>可以说以上步骤算是Git版本控制的入门，基本的使用就是pull和push，如果还想了解如何创建分支以及使用分支(合并)等操作建议参考其他博客，但入门还是很重要的，得明白每一步到底做了些什么</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/error-src-refspec-master-does-not-match-any.html" data-id="clchki9jw002it0qh24lo2oje" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-买卖股票的最佳时机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html" class="article-date">
  <time datetime="2021-04-03T03:56:22.000Z" itemprop="datePublished">2021-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">买卖股票的最佳时机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>本题究其本质是求数组中两个数的最大差值，并且只能是索引大的数减去索引小的数，很容易想到两层for循环解决问题，一旦数据量很大就会超时，毕竟时间复杂度是O(n<sup>2</sup>)，下面介绍动态规划算法，此处不使用一维数组保存每次最大差值，因为也没必要增加空间复杂度，整体思路是：用<code>minPri</code>记录最小的那个价格，用<code>maxVal</code>记录每次最大的差值，因为作为买家，肯定希望在股价最低的那天买入，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">       int minPri = Integer.MAX_VALUE;</span><br><span class="line">       int maxVal = 0;</span><br><span class="line">       for(int i = 0; i&lt;prices.length;i++)&#123;</span><br><span class="line">           if(prices[i]&lt;minPri)&#123;</span><br><span class="line">               minPri = prices[i];</span><br><span class="line">           &#125;else if(prices[i]-minPri&gt;maxVal)&#123;</span><br><span class="line">               maxVal = prices[i]-minPri;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return maxVal;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果难以理解，可以举个例子，[3,2,7,4,1,5]，显然最大价值是5，只需要记住无论最低价格是多少，<code>maxVal</code>记录的始终是最大的差值，就算后面的1比前面的2价格更低，但1后面的价格差值不如2与7的大</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>小编刚开始没有想到动态规划，因为没有理清上一阶和下一阶的依赖关系，其实这里也谈不上依赖关系，只是不断比较<code>maxVal</code>的值罢了</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html" data-id="clchki9k40030t0qh24pxavdl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数组的最大子序和" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html" class="article-date">
  <time datetime="2021-04-01T08:52:06.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">数组的最大子序和</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><p>力扣官网通过贪心算法来解决此题，只需要一次遍历，大致思路如下：</p>
<ol>
<li>通过<code>curSum</code>记录上一次的序列和</li>
<li>如果上次序列和加上当前数字不如当前数字大，则舍弃之前的序列和，<code>curSum</code>等于当前数字</li>
<li>比较之前记录的<code>maxSum</code>和<code>curSum</code>，取最大值赋值给<code>maxSum</code></li>
</ol>
<blockquote>
<p>贪心算法的核心就是每次循环都取最好的结果，具体体现在上述的第二步</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int curSum =nums[0], maxSum = nums[0];</span><br><span class="line">        for(int i = 1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            curSum = Math.max(nums[i],curSum+nums[i]);</span><br><span class="line">            maxSum = Math.max(curSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>思路二：动态规划</p>
<blockquote>
<p>如果使用一维数组来存储每次的结果，你会发现代码和贪心算法很像，状态转移方程：<code>dp[i] = Math.max(dp[i-1]+nums[i]，nums[i])</code>，并且空间复杂度变成了O(n)，所以下面不使用一维数组，只是理解起来没有那么容易，但原理是一样的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int curSum = nums[0],maxSum = nums[0];</span><br><span class="line">        for(int i = 1;i &lt; nums.length;i++)&#123;</span><br><span class="line">            if(curSum&lt;0)&#123;</span><br><span class="line">                curSum = nums[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curSum+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = Math.max(curSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果之前的和为负数，那么它加上一个数，结果肯定会小于这个数本身，所以就舍弃之前的和</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>分享一下小编看到这道题时的想法，考虑的是暴力求解，但却不知每次子序列求和结束的条件是什么，束手无策，看了这贪心算法，确实很妙，所以不用在乎子序列，只需要挨个求和即可</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html" data-id="clchki9l0005gt0qh7oov0vgk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-最长回文子串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html" class="article-date">
  <time datetime="2021-04-01T03:29:55.000Z" itemprop="datePublished">2021-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">最长回文子串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><ol>
<li><p>暴力求解</p>
<p>看到这类题目首先暴力求解一波，使用两层for循环进行遍历字符串，外层记录子串左边界，内层记录子串右边界，通过一个函数进行判断该子串是否是回文，判断方式是从两边界向中间夹逼，只要左边不等于右边便返回false，退出循环返回true，即便当前子串是回文，还需要进行长度的判断，将当前长度和之前记录的长度进行比较，只有比之前的长才重新记录新的左边界以及长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">       int begin = 0;</span><br><span class="line">       int maxLen = 1;</span><br><span class="line">       for(int i = 0;i&lt;s.length()-1;i++)&#123;</span><br><span class="line">           for(int j = i+1;j&lt;s.length();j++)&#123;</span><br><span class="line">               if(isValidString(s,i,j)&amp;&amp;(j-i+1)&gt;maxLen)&#123;</span><br><span class="line">                   begin = i;</span><br><span class="line">                   maxLen = j-i+1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if(maxLen==s.length()) return s;</span><br><span class="line">       &#125;</span><br><span class="line">       return s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isValidString(String s,int left,int right)&#123;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(s.charAt(left)!=s.charAt(right))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>暴力求解的时间复杂度太高，所以想到通过空间换时间，使用动态规划算法，那么状态转移方程是什么呢，仔细思考，如果当前子串是回文的话，那么去掉首和尾肯定也是回文，据此建立了前后两步的依赖关系，通过一个二维数组的表进行状态记录，行是左边界，列是右边界，先按照列来填表，因为dp[i][j]会参考dp[i+1][j-1]即左下角的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">        if(s.length()&lt;2) return s;</span><br><span class="line">       int begin = 0;</span><br><span class="line">       int maxLen = 1;</span><br><span class="line">       boolean[][] dp = new boolean[s.length()][s.length()];</span><br><span class="line">        for(int i = 0;i&lt;s.length();i++)&#123;</span><br><span class="line">            dp[i][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1;j&lt;s.length();j++)&#123;</span><br><span class="line">            for(int i = 0;i&lt;j;i++)&#123;</span><br><span class="line">                if(s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(j-i&lt;3)&#123;</span><br><span class="line">                    //如果当前子串的长度小于3，肯定就是回文</span><br><span class="line">                        dp[i][j]=true;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        dp[i][j] = dp[i+1][j-1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               if(dp[i][j]&amp;&amp;(j-i+1)&gt;maxLen)&#123;</span><br><span class="line">                   begin = i;</span><br><span class="line">                   maxLen = j-i+1;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>这道题使用动态规划的话，关键点在于想到去掉首尾剩余的还是回文，然后就是填表，通过左边界和右边界确定二维表的行和列</p>
</blockquote>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html" data-id="clchki9l2005lt0qh5cou9ctr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-求解多个字符串的最长公共前缀" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%B1%82%E8%A7%A3%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html" class="article-date">
  <time datetime="2021-03-31T12:45:50.000Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%B1%82%E8%A7%A3%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html">求解多个字符串的最长公共前缀</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><p>看到这道题时，小编没有什么好的思路，最容易想到的就是暴力求解，此前你得熟悉什么是前缀，利用这一特性才能进行求解，显然暴力求解不现实，多个字符串，不确定数量，时间复杂度太高，代码也繁琐，下面介绍一位大佬提供的思路</p>
<blockquote>
<p>我们首先应该思考最终的解是怎样的，如果有公共最长前缀，那么肯定是最短的，随便取出一个字符串作为比较标准，通过增强for循环进行遍历字符串数组，内层通过一个while循环进行控制，只要这个标准字符串不是当前字符串的前缀，那么标准字符串的长度-1，直到满足前缀，那么如果不存在公共前缀，标准字符串最终肯定会变成空串，这时就要return，仔细想想，确实是这个道理，只要存在公共最长前缀，那么它肯定经过所有字符串削减后最短的那个公共前缀，满足了当前字符串，但它可能不是最长的，所以还得继续遍历削减</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs==null||strs.length==0) return &quot;&quot;;</span><br><span class="line">       String s = strs[0];</span><br><span class="line">       for(String str:strs)&#123;</span><br><span class="line">           if(s==&quot;&quot;) return &quot;&quot;;</span><br><span class="line">           while(!str.startsWith(s))&#123;</span><br><span class="line">               s = s.substring(0,s.length()-1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>这道题的思路确实之前没遇到过，没见过的，第一想法就是暴力，很多时候想想解的情况，说不定可以巧解</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%B1%82%E8%A7%A3%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html" data-id="clchki9l7005zt0qhgycshp56" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-堆排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%A0%86%E6%8E%92%E5%BA%8F.html" class="article-date">
  <time datetime="2021-03-30T13:01:20.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%A0%86%E6%8E%92%E5%BA%8F.html">堆排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>堆排序是建立在二叉树顺序存储的基础上进行的，使用顺序存储的进行排序不存在递归，下面小编将介绍堆排序的原理</p>
</blockquote>
<h3 id="二-堆排序原理分析"><a href="#二-堆排序原理分析" class="headerlink" title="二.堆排序原理分析"></a>二.堆排序原理分析</h3><p>堆排序中涉及到一个比较重要的概念即<strong>大顶堆和小顶堆</strong>，解释大顶堆即可，小顶堆如法炮制，大顶堆说的是父节点比左右孩子都要大，注意它不关注左右孩子谁大谁小，只要父节点比左右孩子大即可，那么显然位于堆顶(即根)的值是最大的，通常升序排序使用大顶堆，降序使用小顶堆</p>
<img src="https://img0.baidu.com/it/u=3536165523,376891020&fm=26&fmt=auto&gp=0.jpg" style="zoom:67%;" />

<p>介绍完大顶堆后，下面通过一个动画大致领略一下堆排序的原理，小编再配上文字解说</p>
<p><img src="https://www.pianshen.com/images/696/d2f3f4bc776b7d45daa73cad9f9370a0.gif"></p>
<p>根据上图可以发现大致分为以下两个步骤完成排序：</p>
<ol>
<li>首先建立大顶堆，自下而上，自左向右进行构建</li>
<li>交换堆顶元素和未排好序部分的最后一个元素，交换之后，继续调整大顶堆</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void heapSort(int[] arr)&#123;</span><br><span class="line">       for (int i = arr.length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">           adjustHeap(arr,i,arr.length);</span><br><span class="line">       &#125;</span><br><span class="line">       for (int j = arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">           int temp = arr[0];</span><br><span class="line">           arr[0] = arr[j];</span><br><span class="line">           arr[j] = temp;</span><br><span class="line">           adjustHeap(arr,0,j);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   static void adjustHeap(int[] arr,int i,int length)&#123;</span><br><span class="line">       int temp = arr[i];</span><br><span class="line">       for (int k = 2*i+1;k&lt;length;k=k*2+1)&#123;</span><br><span class="line">           if (k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (arr[k]&gt;temp)&#123;</span><br><span class="line">               arr[i] = arr[k];</span><br><span class="line">               i = k;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       arr[i] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>小编觉得堆排序中比较难理解的地方就是调整大顶堆，时间空间复杂度总结如下</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%A0%86%E6%8E%92%E5%BA%8F.html" data-id="clchki9ki0048t0qh5se2equr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-滑动窗口求解无重复字符的最长子串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E8%A7%A3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html" class="article-date">
  <time datetime="2021-03-30T10:27:53.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E8%A7%A3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html">滑动窗口求解无重复字符的最长子串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>看到这道题目时，小编的想法是通过一个<code>LinkedHashMap</code>来存储不重复的字符，注：<code>LinkedHashMap</code>会按照添加元素的顺序进行存储，经过一次遍历后便将所有不重复的字符添加到<code>Map</code>中，key是字符，value是其对应的下标，然后通过遍历<code>Map</code>对前后两个<code>value</code>值的差值为1进行计数，如果发生断链，就重新计数，多次断链便取最大值，该想法可以满足部分例子，但如果中间出现连续的重复字符便没有用了，因为对于连续重复的字符不知该记录最前面还是最后面的下标，下面介绍力扣官方解题思路：<strong>滑动窗口</strong></p>
</blockquote>
<p>滑动窗口的意思是通过一个左指针进行记录每次不重复子串的第一个字符的位置，此处通过<code>HashMap</code>进行存储字符以及其对应的下标，无论重复与否，每次都会将本次的字符及其下标添加到<code>HashMap</code>中，key相同的话即覆盖，如果发生key值重复，就改变左指针，由于可能之前出现过一个新的左指针，所以需要通过一个<code>max</code>函数进行取最大值，每轮遍历都需保存当前子串的最大长度，下面上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">       if(s.length()==0) return 0;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = new HashMap();</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for(int i = 0; i&lt; s.length();i++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i))+1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>显然时间复杂度比暴力求解低太多，至于left指针的取法可以结合具体例子进行理解，该算法只能说很巧妙，通过一个left指针移动到下一个子串，所以称为滑动窗口</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E8%A7%A3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html" data-id="clchki9l80062t0qhgeuncvbg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-贪心算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html" class="article-date">
  <time datetime="2021-03-28T03:28:12.000Z" itemprop="datePublished">2021-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html">贪心算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍贪心算法，贪心算法是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法，但贪心算法的结果不一定是最优的，但是都相对接近最优解的结果</p>
</blockquote>
<h3 id="二-贪心法实例——集合覆盖问题"><a href="#二-贪心法实例——集合覆盖问题" class="headerlink" title="二.贪心法实例——集合覆盖问题"></a>二.贪心法实例——集合覆盖问题</h3><p>下面以一个小实例来阐释贪心法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B.png" style="zoom:80%;" />

<p>思路分析：</p>
<ol>
<li>通过一个Map来保存广播台以及它对应的覆盖区域</li>
<li>通过一个集合保存所有的地区</li>
<li>为了选出最佳的组合，肯定存在多次遍历，每遍历一次所有广播只能得到一个最佳的广播台，所以外层是<code>while</code>循环，根据贪心法的原理，那么每次都会选择覆盖还未被覆盖地区的最大值，因此每选出一个广播，就要将已覆盖的区域从所有地区中移除，所以外层<code>while</code>循环的结束条件就是所有地区覆盖完毕，即地区集合为空</li>
<li>此外还需定义一个<code>maxKey</code>来记录每次遍历获得的最佳广播台，遍历结束后，将其添加到结果集合中，以上过程为了不重复添加元素，所以都采用Set来保存数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static void GreedyAlgorithm()&#123;</span><br><span class="line">       Map&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap();</span><br><span class="line">       HashSet&lt;String&gt; hashSet1 = new HashSet();</span><br><span class="line">       hashSet1.add(&quot;北京&quot;);</span><br><span class="line">       hashSet1.add(&quot;上海&quot;);</span><br><span class="line">       hashSet1.add(&quot;天津&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet2 = new HashSet();</span><br><span class="line">       hashSet2.add(&quot;广州&quot;);</span><br><span class="line">       hashSet2.add(&quot;北京&quot;);</span><br><span class="line">       hashSet2.add(&quot;深圳&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet3 = new HashSet();</span><br><span class="line">       hashSet3.add(&quot;成都&quot;);</span><br><span class="line">       hashSet3.add(&quot;上海&quot;);</span><br><span class="line">       hashSet3.add(&quot;杭州&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet4 = new HashSet();</span><br><span class="line">       hashSet4.add(&quot;上海&quot;);</span><br><span class="line">       hashSet4.add(&quot;天津&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet5 = new HashSet();</span><br><span class="line">       hashSet5.add(&quot;杭州&quot;);</span><br><span class="line">       hashSet5.add(&quot;大连&quot;);</span><br><span class="line"></span><br><span class="line">       broadcasts.put(&quot;K1&quot;,hashSet1);</span><br><span class="line">       broadcasts.put(&quot;K2&quot;,hashSet2);</span><br><span class="line">       broadcasts.put(&quot;K3&quot;,hashSet3);</span><br><span class="line">       broadcasts.put(&quot;K4&quot;,hashSet4);</span><br><span class="line">       broadcasts.put(&quot;K5&quot;,hashSet5);</span><br><span class="line">       HashSet&lt;String&gt; allAreas = new HashSet();</span><br><span class="line">       allAreas.add(&quot;北京&quot;);</span><br><span class="line">       allAreas.add(&quot;上海&quot;);</span><br><span class="line">       allAreas.add(&quot;天津&quot;);</span><br><span class="line">       allAreas.add(&quot;广州&quot;);</span><br><span class="line">       allAreas.add(&quot;深圳&quot;);</span><br><span class="line">       allAreas.add(&quot;成都&quot;);</span><br><span class="line">       allAreas.add(&quot;杭州&quot;);</span><br><span class="line">       allAreas.add(&quot;大连&quot;);</span><br><span class="line">       //开始遍历</span><br><span class="line">       HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;();//记录当前广播可以覆盖的还未被覆盖的城市</span><br><span class="line">       String maxKey = null; //记录覆盖城市最多的那个广播</span><br><span class="line">       HashSet&lt;String&gt; selects = new HashSet&lt;&gt;();//保存选择的城市</span><br><span class="line">       while(!allAreas.isEmpty())&#123;</span><br><span class="line">           maxKey = null;</span><br><span class="line">           for (String key:broadcasts.keySet())&#123;</span><br><span class="line">               tempSet.clear();</span><br><span class="line">               tempSet = broadcasts.get(key);</span><br><span class="line">               //求当前广播可以覆盖的未被覆盖的城市</span><br><span class="line">               tempSet.retainAll(allAreas);</span><br><span class="line">               if (!tempSet.isEmpty() &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                   maxKey = key;</span><br><span class="line">               &#125;</span><br><span class="line">               if (maxKey!=null)&#123;</span><br><span class="line">                   selects.add(maxKey);</span><br><span class="line">                   allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (String city:selects) System.out.print(city+&quot; &quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>使用贪心法求解问题的关键在于找到贪心规律，每次找出最优的匹配结果，文章开篇也提到过贪心法的解不一定是最优解，因为现实问题还可能存在很多因素，比如成本</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html" data-id="clchki9lt007ut0qh0ood2pxx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">Android重要组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%A1%B9%E7%9B%AE/">Android项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html%E5%AD%A6%E4%B9%A0/">html学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/">系统控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%B3%BB%E5%88%97/">组件化系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">hexo博客搭建问题总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" rel="tag">学年设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" rel="tag">系统高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 18px;">Android常用琐碎知识点</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" style="font-size: 10px;">Android开发小Demo</a> <a href="/tags/Android%E9%AB%98%E7%BA%A7UI/" style="font-size: 16px;">Android高级UI</a> <a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 10px;">hexo博客搭建问题总结</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 10px;">发布开源库</a> <a href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">学年设计</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" style="font-size: 20px;">算法篇</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" style="font-size: 12px;">系统高级UI</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 14px;">网络开源库</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
          </li>
        
          <li>
            <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
          </li>
        
          <li>
            <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
          </li>
        
          <li>
            <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
          </li>
        
          <li>
            <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 EngineerOfFinger<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/%20%7C%7C%20fas%20fa-home" class="mobile-nav-link">主页</a>
  
    <a href="/archives/%20%7C%7C%20fas%20fa-archive" class="mobile-nav-link">时间轴</a>
  
    <a href="/tags/%20%7C%7C%20fas%20fa-tags" class="mobile-nav-link">标签</a>
  
    <a href="/categories/%20%7C%7C%20fas%20fa-folder-open" class="mobile-nav-link">分类</a>
  
    <a href="/link/%20%7C%7C%20fas%20fa-link" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>