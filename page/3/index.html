<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>梦幻泡影</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="success&#x3D;persistence">
<meta property="og:type" content="website">
<meta property="og:title" content="梦幻泡影">
<meta property="og:url" content="https://wiwiyiyi.com/page/3/index.html">
<meta property="og:site_name" content="梦幻泡影">
<meta property="og:description" content="success&#x3D;persistence">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EngineerOfFinger">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="梦幻泡影" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wiwi.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦幻泡影</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/%20%7C%7C%20fas%20fa-home">主页</a>
        
          <a class="main-nav-link" href="/archives/%20%7C%7C%20fas%20fa-archive">时间轴</a>
        
          <a class="main-nav-link" href="/tags/%20%7C%7C%20fas%20fa-tags">标签</a>
        
          <a class="main-nav-link" href="/categories/%20%7C%7C%20fas%20fa-folder-open">分类</a>
        
          <a class="main-nav-link" href="/link/%20%7C%7C%20fas%20fa-link">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wiwiyiyi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Binder机制浅谈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Binder%E6%9C%BA%E5%88%B6%E6%B5%85%E8%B0%88.html" class="article-date">
  <time datetime="2021-12-14T08:50:59.000Z" itemprop="datePublished">2021-12-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Binder%E6%9C%BA%E5%88%B6%E6%B5%85%E8%B0%88.html">Binder机制浅谈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>说起Binder的跨进程，百般挠头，个人感觉很难想通的是通信的具体流程，以及代码中如何体现的，每一个类具体扮演什么样的角色，折磨一番也只能暂时理解一个大概</p>
</blockquote>
<h3 id="二-理论基础"><a href="#二-理论基础" class="headerlink" title="二.理论基础"></a>二.理论基础</h3><blockquote>
<p>看了Binder也才理解为什么面试官喜欢挖操作系统，基本的进程概念，以及传统的IPC(进程间通信方式)有哪些，如何进行的通信，内核态/用户态…….下面简单聊一下传统的IPC和Binder的优劣</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-2160e70ca6e813ff28c34eec5ae8209c_1440w.jpg"></p>
<p>此前还得先补充一下进程隔离以及数据是如何传递的</p>
<ol>
<li><p>进程隔离</p>
<img src="https://pic3.zhimg.com/80/v2-38e2ea1d22660b237e17d2a7f298f3d6_1440w.jpg" style="zoom:51%;" />

<ul>
<li><p>所谓进程间的通信就是进程1中的类可以调用进程2中的类的方法进行数据传递或其他响应</p>
</li>
<li><p>每个进程间内存隔离，互不干扰，所以进程1中的类A是无法持有进程2中类B的引用，更无法调用类B的方法</p>
</li>
<li><p>上图呈现了进程空间的划分，多个进程间无法通信，但通过内核空间就可以实现中转然后通信，下面简单介绍一下用户空间和内核空间的划分问题</p>
<p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<img src="https://pic2.zhimg.com/80/v2-3c719337413b9c5c4ad0b6c6b8eb0291_1440w.jpg" style="zoom:75%;" />

<p>简单说内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。用户空间内部分多个互不干扰的进程，而内核空间是共享的，用户进程可以通过<strong>系统调用</strong>和内核空间进行通信，所以说内核空间就是一层中转</p>
<p>常用的系统调用：</p>
<ul>
<li>copy_from_user() //将数据从用户空间拷贝到内核空间</li>
<li>copy_to_user() //将数据从内核空间拷贝到用户空间</li>
</ul>
</li>
</ul>
</li>
<li><p>传统的IPC通信方式</p>
<p>有了上面的基本理解，下面就开始具体介绍传统IPC是如何实现进程间通信的</p>
<img src="https://pic1.zhimg.com/80/v2-aab2affe42958a659ea8a517ffaff5a0_1440w.jpg" style="zoom:51%;" />

<p>​    注：上述看到的内存空间都是虚拟地址，虚拟地址映射真实的物理地址，就像栈中的指针引用对应堆上的实例对象，下面以     Socket/管道/消息队列的通信方式来演示(发送方和接收方都有自己的内存管理)</p>
<ol>
<li>发送方将数据从自己管辖的物理空间中拷贝数据到内核空间-copy_from_user</li>
<li>接收方将数据从内核空间拷贝到自己管辖的物理空间-copy_to_user</li>
</ol>
<p>所以没有内存共享就是拷贝两次，下面再看一下完全的内存共享方式</p>
<p><img src="https://img-blog.csdn.net/20170522210722671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2t5cm9iZW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>这里直接扒了一张图，简单说就是两个进程的虚拟地址都指向同一片物理内存空间，所以一个进程对这片共享的区域修改，另一个进程就可以同步修改，因此就不需要进行数据拷贝</p>
</li>
<li><p>Binder通信</p>
<img src="https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_1440w.jpg" style="zoom:51%;" />

<p>Binder通信是基于内存映射(mmap)来实现的，mmap在接收进程的用户空间和内核空间建立内存映射，简单说就是接收进程的指定虚拟地址指向了内核空间的数据缓存区，所以现在只需要发送进程拷贝数据到内核空间即可</p>
</li>
</ol>
<p>上面通过概念图的方式对比了传统IPC和Binder之间的差异，下面总结一下Binder的优势：</p>
<img src="https://pic3.zhimg.com/80/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" style="zoom:51%;" />

<h3 id="三-手撸一个跨进程通信示例"><a href="#三-手撸一个跨进程通信示例" class="headerlink" title="三.手撸一个跨进程通信示例"></a>三.手撸一个跨进程通信示例</h3><p>为了能够展示码代码的基本思路，下面先附上一张Binder通信的基本流程图</p>
<img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" style="zoom:51%;" />

<img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" style="zoom:51%;" />

<p>需要的类以及对应的功能：</p>
<ol>
<li>IInterface：标识服务端进程(习惯这样说)对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>
<li>Client：客户端需要拿到服务端的一个对象(这里拿到的是代理对象)，因为IInterface规定了服务端提供了哪些通信方式(说白了就是方法，调用服务端的方法进行数据传递达到通信目的)，所以容易想到Client需要持有IInterface的对象</li>
<li>Server：服务端通常是Service的实现类来扮演，比如说服务端用来存储数据，那肯定需要暴露接口给外部用于添加数据，这也是IInterface中要提供的功能</li>
<li>Stub : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类，这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力，Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。其实通过后面代码实现来看，Stub就是Server端具体实现功能的工具，这里抽象一层，便于区分处理代理对象发送的数据操作请求和具体的数据操作</li>
<li>Proxy：Binder通信使用了代理模式，就算通过Binder驱动-&gt;ServiceManager找到了具体的服务端进程，也不可能返回真实的服务端进程中类的对象引用，如果客户端都能持有服务端的引用了，也说不上是跨进程了，所以这里通过链接返回的代理对象，很显然要调用服务端的功能，Proxy必然也是IInterface实现类</li>
</ol>
<p>注：IInterface是系统提供的一种标识，具体定义服务端提供哪些功能，中间还需要提供一层接口用于定义功能</p>
<p>下面就不贴代码了，通过一张图结合Binder的通信过程来理解为什么要这样撸码</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/777501da5c06a7309589e0af92ec1dfadf0a6898">代码链接</a></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Binder%E9%80%9A%E4%BF%A1.png" style="zoom:35%;" />

<p>这里就省去了用户进程通过open/io_ctl和Binder驱动通信的流程，简单描绘了一个大致流程，仅一己之见</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>Binder理解起来实在复杂，特别是搭配底层C++源码，其实很多时候疑惑的是自己写的代码是如何体现Binder通信的流程，以及为什么要这样写，下面推荐一篇博客，个人感觉写得很详细了，如果能搭配代码，将代码中的每个类扮演的角色，以及通过方法发起的链接流程理清楚就很棒了。这里再简单提一下吧，从宏观角度来说，Client通过bindService向Server发送一个连接请求，那Server应该在onBind中返回一个自己的实例，然后Client就可以在onServiceConnected拿到这个实例，然后就可以通信了，只不过因为跨进程，所以不能拿到Server的一个实例，需要通过第三者来封装，因为是Binder通信，所以就必须是能够在Binder驱动中来去自如的IBinder的实现类，还需实现我们规定给Server端的功能接口，这也就是Stub存在的意义，此外因为跨进程，所以还必须返回一个代理对象，所以就有了Proxy，Proxy内部持有连接成功返回的Binder对象，这么一说其实就很清晰了，从宏观到细节。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585">博客链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Binder%E6%9C%BA%E5%88%B6%E6%B5%85%E8%B0%88.html" data-id="clchkr8mj000k5oqhcwqt7xmx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Handler原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Handler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" class="article-date">
  <time datetime="2021-12-12T06:13:51.000Z" itemprop="datePublished">2021-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Handler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html">Handler原理分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>日常开发中免不了线程切换，子-&gt;主或主-&gt;子，最经典的就是Handler实现的线程切换了，它也占据了系统源码的很大一部分，没有它就跑不起来，下面娓娓道来</p>
</blockquote>
<h3 id="二-组成与运作"><a href="#二-组成与运作" class="headerlink" title="二.组成与运作"></a>二.组成与运作</h3><p>先来通过一张图体现Handler相关体系的组成</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Handler%E7%BB%93%E6%9E%84.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val handler = object : Handler()&#123;</span><br><span class="line">        override fun handleMessage(msg: Message) &#123;</span><br><span class="line">            //切换到主线程做事情</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Thread&#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            Looper.loop()</span><br><span class="line">            handler.sendEmptyMessage(0)</span><br><span class="line">        &#125;.start()    </span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" style="zoom:50%;" />

<p>上图已经比较清楚的解释了子线程发送消息如何回到handleMessage中处理结果的流程，主要成员也比较清楚</p>
<ol>
<li><p>无论是SendMessage还是post都是发送一个消息，并且最终汇流于sendMessageAtTime此函数，开始入队</p>
</li>
<li><p>最终发送消息时，会将Handler的对象赋值给target，消息出队后才知道让哪个Handler来处理</p>
</li>
<li><p>Looper在此过程中充当动力源，内部就是一个死循环，不断取消息，然后分发，Handler就像入口，MessageQueue做一个缓存中转，所以这就是一个典型的生产者/消费者问题，消息队列满了，Handler的入队操作阻塞，消息队列为空，Looper的取操作阻塞，等待被唤醒</p>
</li>
<li><p>MessageQueue是一个优先级队列，上面提到最终汇流于sendMessageAtTime函数，无论你是否设置时间，系统会给一个默认的时间，入队时按照延迟的时间排序，显然延迟时间越短越靠前，正是要保证优先性，所以要出队和入队都要加锁</p>
</li>
<li><p>Looper如何跑起来的？</p>
<p>每一个线程只能有一Looper实例和消息队列，这就是通过ThreadLocal来实现的，因为每一个线程内部都有一个唯一的ThreadLocalMap，Looper这个类中保存了一个静态的ThreadLocal变量，作为公有的key，构造方法私有，只能通过<code>prepare()</code>来创建Looper对象，并保存在当前线程的ThreadLocalMap中，并且还需要调用Looper.loop将其跑起来，这里涉及到的<strong>Looper实例的存和取都是针对线程中的ThreadLocalMap</strong>，所以保证了唯一性</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Looper%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7.png" style="zoom:50%;" /></li>
<li><p>取消息时的阻塞，分两种</p>
<p>a. 没到延迟时间，会重新计算延迟时间，然后睡眠，达到时间自动唤醒</p>
<p>b. 消息队列为空，无限等待，直到有消息入队将它唤醒</p>
<p>上述搭配使用的方法是nativePollOnce睡眠、nativeWake唤醒</p>
</li>
<li><p>如何结束Looper.loop的死循环</p>
<p>MessageQueue提供了quit方法，当App退出时会调用此方法，修改mQuitting这个标志位，如果下次取消息时mQuitting为true，则返回空消息(null)，在Looper.loop中如果拿到的是空消息，则return结束循环</p>
</li>
<li><p>Handler存在内存泄漏</p>
<p>实例代码在IDE中会提示内存泄漏，这是因为内部类会持有外部类的引用，所以Handler持有了Activity的引用，而前面提到Msg的target就是Handler，所以相当于MessageQueue持有了Activity的引用，就导致了内存泄漏，因此开发中需要使用静态内部类+弱引用的方式</p>
</li>
<li><p>Handler实现线程切换或者说线程间的通信是通过共享内存实现的，那这里共享的内存自然就是<strong>Message</strong>，数据是共享的，比如在子线程发送消息，消息的入队操作是在子线程完成的，可以一路追踪，哪个线程的Handler，自然就会调用哪个线程的MessageQueue入队操作，一旦消息入队，并唤醒(如果需要)，子线程的任务就完成了，既然消息已经进入了Handler对应的MessageQueue，剩余的就是对应的Looper取消息并分发的过程了，移动的就是Message，细思甚秒！</p>
</li>
</ol>
<h3 id="三-内存屏障-barrier"><a href="#三-内存屏障-barrier" class="headerlink" title="三.内存屏障-barrier"></a>三.内存屏障-barrier</h3><blockquote>
<p>内存屏障的作用很重要，屏障简单说就是阻塞，对于普通的消息都是按照时间排序后顺序被取出，但如果有一个紧急消息需要立即被执行，岂不是还要等待前面的消息执行完毕，显然不合理，这也就是内存屏障的意义</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E6%B6%88%E6%81%AF%E5%B1%8F%E9%9A%9C.png"></p>
<ol>
<li><p>先解释一下这里的同步消息和异步消息，小编感觉有点混乱，这里应该是针对消息队列来看，普通消息必须排队按次序被取出，所以普通消息称为同步消息，需要立即被处理的消息称为异步消息，所以如此来理解为什么立即被处理的消息的标志位为isAsynchronous就比较容易了，遍历查找异步消息</p>
</li>
<li><p>如何插入的屏障</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = true;</span><br><span class="line">            //插入内存屏障</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            //发送异步消息</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在ViewRootImpl中有示例，内存屏障也是考虑到了UI刷新问题，显然UI刷新是需要立即被处理的，另外屏幕也会每隔一定时间就会刷新，比如60HZ，就是说1秒内刷新60次，约等于16ms刷新一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void postCallbackDelayedInternal(int callbackType,</span><br><span class="line">            Object action, Object token, long delayMillis) &#123;</span><br><span class="line">        if (DEBUG_FRAMES) &#123;</span><br><span class="line">            Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType</span><br><span class="line">                    + &quot;, action=&quot; + action + &quot;, token=&quot; + token</span><br><span class="line">                    + &quot;, delayMillis=&quot; + delayMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            final long dueTime = now + delayMillis;</span><br><span class="line">            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">            if (dueTime &lt;= now) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">                msg.arg1 = callbackType;</span><br><span class="line">                //设置标志位</span><br><span class="line">                msg.setAsynchronous(true);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>设置了内存屏障后，发送异步消息时只需要通过setAsynchronous(true)设置标志位即可</p>
</li>
<li><p>如果不移除内存屏障就会反复遍历寻找，所以一旦不需要了，立即移除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br></pre></td></tr></table></figure>

<p>mTraversalBarrier是插入的屏障的标识</p>
</li>
</ol>
<blockquote>
<p>内存屏障东西不多，理解它的工作原理，以及使用即可，插入和移除搭配使用，移除一定要及时，否则会影响效率</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Handler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html" data-id="clchkr8mp000x5oqhfpmhbr3d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-性能优化-数据结构优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96.html" class="article-date">
  <time datetime="2021-12-10T08:29:12.000Z" itemprop="datePublished">2021-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96.html">性能优化-数据结构优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>本篇是性能优化的开章，下面先简单聊聊性能优化的目的：</p>
<ol>
<li><p>更快</p>
<p>流畅性：</p>
<ul>
<li><p>启动速度</p>
</li>
<li><p>页面显示速度(显示和切换)</p>
</li>
<li><p>响应速度</p>
</li>
</ul>
</li>
<li><p>更稳定</p>
<p>稳定性：</p>
<ul>
<li>避免出现应用崩溃(Crash) </li>
<li>避免出现应用无响应(ANR)</li>
</ul>
</li>
<li><p>更省</p>
<p>资源节省性：</p>
<ul>
<li>内存大小</li>
<li>安装包大小</li>
<li>耗电量</li>
<li>网络流量</li>
</ul>
</li>
</ol>
<p>那么选择合适的数据结构既可以避免空间换时间的资源浪费，同时还可以提高流畅度，下面递进介绍</p>
<h3 id="二-合适的数据结构演化"><a href="#二-合适的数据结构演化" class="headerlink" title="二.合适的数据结构演化"></a>二.合适的数据结构演化</h3><p><strong>线性表：</strong>在存储数据时首先想到的就是线性结构-列表，分两种</p>
<ol>
<li><p>连续内存的ArrayList</p>
<p>内部就是保存了一个数组</p>
<ul>
<li>优点：查询和修改效率高(通过下表Index访问元素，因为连续，所以通过首地址+index*一个元素所占内存空间直接访问到地址)</li>
<li>缺点：增加和删除效率低，因为涉及到元素移动，具体操作是<code>System.arraycopy</code></li>
</ul>
</li>
<li><p>离散存储的LinkedList(链式结构)</p>
<ul>
<li>优点：增加和删除效率高，直接通过改变指针指向即可</li>
<li>缺点：查询和修改效率低，因为是离散只能通过指针来轮询，有点像顺藤摸瓜</li>
</ul>
</li>
</ol>
<p>经过以上对比，在实际开发中，比如RecyclerView，请求下来的数据通常只是展示作用，也可能对某个元素的状态标志位做修改，很少有增加和删除操作，这种情况显然使用ArrayList效率更高。还记得之前模仿着写Okhttp的一个网络访问框架，内部需要维护一个承载Runnable任务的这么一个队列，显然只关心take和offer，所以使用链式结构更好(阻塞式)</p>
<p><strong>哈希表：</strong>哈希表采用了数组+链表的形式将二者的优势结合起来，效率提高很明显，但是有点浪费空间</p>
<p>JDK1.8以前使用数组+链表，1.8以后使用数组+链表+红黑树，因为如果链表太长会影响查找效率</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/hashmap%E7%BB%93%E6%9E%84.png" style="zoom: 25%;" />

<p>HashMap的基本结构如上，table是一个数组，存储的元素类型是Node结点，一个结点包括hash值，key，value和next指针</p>
<ol>
<li><p>如何快速定位node在一维数组中的位置</p>
<p>基本思想就是求模运算，每一个Key都有一个hashCode，用这个hashCode模上数组的长度就能确定索引位置，由于计算机最终都是二进制的运算，所以位运算比普通的求模运算%效率更高，因此<code>index = (length - 1) &amp; hash</code></p>
</li>
<li><p>哈希冲突的解决</p>
<p>根据求模运算不同的hashCode得到的index值可能会相同，就产生了冲突，HashMap采用了链地址法，所以就有数组+链表一说，如果有冲突，则将新加入的节点插入到冲突index位置链表的末尾，即尾插法</p>
</li>
<li><p>扩容问题</p>
<p>HashMap也会有“装满”，只不过并没有满就会扩容</p>
<p>加载因子：0.75</p>
<p>阈值：HashMap默认大小是16(table大小)，并且源码中规定必须是2的次幂，那么阈值就等于 <strong>加载因子*HashMap大小</strong>，默认是12，当前所有元素的数量超过阈值就会扩容</p>
</li>
<li><p>及最大努力避免哈希冲突</p>
<p>在没有引入红黑树前，肯定要尽量避免哈希冲突，最坏的情况就是所有元素都冲突在一起，也就是一条单链表，显然就失去了HashMap的优势，所以需要避免冲突，明显，如果table的长度越大发生冲突的可能性就越小，源码中进行扩容时将table的<strong>length*2</strong>，所以尽可能扩大阈值，你传入真时的size最好是 size/0.75+1，虽然不一定是2的次幂，但系统会进行一层处理，让它靠向2的次幂，即向上扩大</p>
</li>
<li><p>为什么size尽量是2的次幂</p>
<p>前面提到index的计算方式<code>(length - 1) &amp; hash</code>，如果size是2的次幂，那么length-1转换成2进制一定是全1，如(32-1)=&gt;11111，下面具体感受一下全1的好处</p>
<p>length：14  (14-1) =&gt;1101                  length：16  (16-1) =&gt;1111</p>
<p>hash值1：110        =&gt;0100                                                  =&gt;0110</p>
<p>hash值2：101        =&gt;0100                                                  =&gt;0101</p>
<p>同一个hash值分别按位与，明显感觉到长度为14的方式只有三位起作用，所以无论是110还是101都是相同的结果，而长度为16的结果没有冲突，所以这也就是为什么要使用2的次幂的长度</p>
</li>
<li><p>内存浪费</p>
<p>因为有阈值的存在，所以必定会浪费25%的内存空间，空间换时间的代价有点大，另外就是数组扩容时直接翻倍，这也会浪费空间</p>
</li>
</ol>
<p><strong>SparseArray：</strong>稀疏数组，采用的是双数组的方式，一个数组存Key，一个数组存Value，一一对应</p>
<ul>
<li><p>优势：</p>
<ol>
<li>查找效率高：二分查找，key是Int类型，所以采用二分只能说超快</li>
<li>越用越快：如果要删除值，并非要通过<code>System.arraycopy</code>移动元素，只需要置一个标志位即可，这样的好处是下次如果要在次插入值直接就可以覆盖之前的值</li>
<li>相对于HashMap来说极大地节省了内存</li>
</ol>
</li>
<li><p>不足：</p>
<p>因为Key只能是Int型，所以限制太大</p>
</li>
</ul>
<p><strong>ArrayMap：</strong>Android针对SparseArray创造了ArrayMap，补足了SparseArray只能存储Int型key的缺陷，但由于Android开发中的数据量并不是很大，所以很少见到使用，比较经典的是Bundle，内部就是通过ArrayMap存储键值对</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>确实在实际开发中很少考虑到数据结构的优化，因为数据量不大，差距不明显，个人感觉还是针对特定的场景吧，比如增删和改查这种对立的场景</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96.html" data-id="clchkr8og00595oqhd5j344hn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ViewPager实现Banner轮播图效果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/ViewPager%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C.html" class="article-date">
  <time datetime="2021-12-07T05:57:14.000Z" itemprop="datePublished">2021-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/ViewPager%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C.html">ViewPager实现Banner轮播图效果</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>电商类App基本上都会有一个Banner(轮播图)来展示图片广告信息，日常开发中有时也用得着，所以就抽空去玩了玩，github上已经有封装好的Banner供使用，下面先从一般的ViewPager实现开始，主要是介绍用法</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/Banner%E6%95%88%E6%9E%9C.gif"></p>
<h3 id="二-ViewPager实现Banner轮播图片"><a href="#二-ViewPager实现Banner轮播图片" class="headerlink" title="二.ViewPager实现Banner轮播图片"></a>二.ViewPager实现Banner轮播图片</h3><blockquote>
<p>要说轮播，RecyclerView和ViewPager都可以轻松实现，搞一个定时器不断变化当前的Position即可，但是要无限轮播还要搭配指示器的变化还是得费点功夫</p>
</blockquote>
<p>这里就不粘代码了，附上代码链接，下面主要理一下思路</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/49062104ab8a6f51c5c450d936099eaa8b2dd21c">ViewPager实现Banner链接</a></p>
<ol>
<li>准备一个存储所有ImageView的数组，这是后续添加到ViewPager中的数据源，遍历添加的同时添加一个指示器(点)，每个指示器有两种状态，通过selector的xml配置即可</li>
<li>通过一个线程无限轮询，每隔一段时间切换到主线程改变当前展示的Item，因为是无限轮播，所以当前的Index索引会不断累加</li>
<li>实现PagerAdapter，在<strong>instantiateItem</strong>提供视图的方法中通过取余的方式拿到当前应该展示哪个ImageView，在添加之前还得在<strong>destroyItem</strong>视图移除方法中将当前ImageView的parent移除，否则无法添加进去，PagerAdapter的功能就是提供视图来源</li>
<li>添加页面滑动监听，在轮询线程中通过改变当前展示视图的Index，这是动力源，切换到下一个视图时，需要更新文本信息和指示器的状态，所以需要一个全局变量用来标识上一个索引值</li>
</ol>
<blockquote>
<p>此方式可以实现无限轮播且改变相应信息的效果，但缺点很明显，没有移植性，封装性也没有，让Activity中的代码难以管理，但理解了基本原理即可：轮询线程改变索引(动力源)+PagerAdapter(视图来源)+页面滑动监听(信息更新)</p>
</blockquote>
<h3 id="三-Banner的封装以及高级用法"><a href="#三-Banner的封装以及高级用法" class="headerlink" title="三.Banner的封装以及高级用法"></a>三.Banner的封装以及高级用法</h3><p>上面实现的Banner不仅缺点明显，并且效果也普通，因为没有动画和其他附加效果，下面介绍一下github上比较🔥的一个Banner开源库，看源码其实就是封装加扩展，下面还是介绍用法</p>
<ol>
<li><p>指示器</p>
<p>该开源库提供了如下几种指示器的样式，原理就是自定义View，根据当前的选中Index做绘制</p>
<ul>
<li>NumIndicator：数字指示器，自定义的，1/6的样式，比较简单，就是绘制文本</li>
<li>CircleIndicator：圆形指示器，如果需要定义自己的样式，比如选中和非选中的大小，指示器间的间距，需要继承并自定义，这是不太好的地方，应该提供一个接口供用户配置</li>
<li>DrawableIndicator：将某个小的icon图标作为指示器样式</li>
<li>RectangleIndicator：不连贯的圆角矩形指示器</li>
<li>RoundLinesIndicator：圆形线条指示器</li>
</ul>
<p>注：DrawableIndicator有坑，它只能外置，单独作为一个View，然后获取到indicator对象赋值给Banner，其他三个都可以通过new的方式注入给Banner</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">binding.banner.setAdapter(ImageAdapter(bannerModels))</span><br><span class="line">						//.setIndicator(RoundLinesIndicator(context))</span><br><span class="line">            .setIndicator(binding.indicator,false)</span><br><span class="line">                //添加画廊效果</span><br><span class="line">            .setBannerGalleryEffect(50, 10)                        </span><br></pre></td></tr></table></figure>

<p>对比可以看到区别，一个是来自XML布局</p>
</li>
<li><p>页面的切换动画</p>
<ul>
<li>AlphaPageTransformer：透明度变化的切换效果</li>
<li>ScaleInTransformer：当前图片缩小退出</li>
<li>RotateDownPageTransformer：以下边界的中点为圆心进行旋转切换</li>
<li>RotateUpPageTransformer：以上边界边界的中点为圆心进行旋转切换</li>
<li>DepthPageTransformer：当前图片淡出，下一张图片从后面放大展示，营造一种由里向外的感觉</li>
<li>RotateYTransformer：围绕Y轴旋转，整体效果类似于方块于方块之间的切换</li>
<li>ZoomOutPageTransformer：当前图片先缩小再放大，同时伴随平移，有点向进入房间后再出房间</li>
<li>MZScaleInTransformer：内部实现魅族效果使用的，单独使用可能效果不一定好，和Scale效果有点类似</li>
</ul>
<p>注：官网上说可以相互搭配使用，但是会有叠加影响，推荐和AlphaPageTransformer搭配使用，有了透明度的变化可能会更酷</p>
</li>
<li><p>关联视图(Fragment/Activity的生命周期)</p>
<p>当前的视图已经不可见的时候就应该停止轮播</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">banner.addBannerLifecycleObserver(LifecycleOwner owners)</span><br></pre></td></tr></table></figure>

<p>如此更便于管理</p>
</li>
</ol>
<p>总的来说，该库用于实现基本的图片轮播还是很方遍的，我是踩过一点坑，只要效果好也还行</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/banner%E6%95%88%E6%9E%9C.gif"></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>这个库还是蛮不错的，里面的效果都推荐尝试尝试，日常开发基本够用了</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/03e8196762c61bd8df824afc7ac69f6798258e19">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/ViewPager%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C.html" data-id="clchkr8n9002b5oqh7upx7wbg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-volatile关键字和ThreadLocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8CThreadLocal.html" class="article-date">
  <time datetime="2021-12-05T12:23:48.000Z" itemprop="datePublished">2021-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8CThreadLocal.html">volatile关键字和ThreadLocal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>对于线程同步/安全是一定要通过加锁的方式来实现，下面将介绍使用较多的volatile关键字和ThreadLocal(线程本地变量)</p>
</blockquote>
<h3 id="二-volatile关键字"><a href="#二-volatile关键字" class="headerlink" title="二.volatile关键字"></a>二.volatile关键字</h3><blockquote>
<p>volatile的功能简单说就是线程间可见，有以下特性：</p>
</blockquote>
<ol>
<li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ol>
<p>volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2</p>
<p>注：所以volatile只是保证数据的可见性，并不保证安全性，使用场景，一写多读，volatile是比较轻量的一种同步机制</p>
<p>使用比较简单，直接在声明变量时加上该关键字即可，这里一笔带过，Kotlin中是通过注解的方式来标识</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Volatile</span><br><span class="line">var i = 0</span><br></pre></td></tr></table></figure>

<h3 id="三-ThreadLocal"><a href="#三-ThreadLocal" class="headerlink" title="三.ThreadLocal"></a>三.ThreadLocal</h3><blockquote>
<p>ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。与加锁完全不同，加锁是同一时刻只能让一个线程访问变量</p>
</blockquote>
<ol>
<li><p>ThreadLocal的基本使用</p>
<ul>
<li><p>void set(Object value) </p>
<p>设置当前线程的线程局部变量的值。</p>
</li>
<li><p>public Object get() </p>
<p>该方法返回当前线程所<strong>对应的线程</strong>局部变量。</p>
</li>
<li><p>public void remove() </p>
<p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p>
</li>
<li><p>protected Object initialValue() </p>
<p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TestThread(val intLocal: ThreadLocal&lt;Int&gt;,val mId: Int): Thread() &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        println(&quot;$&#123;currentThread().name&#125;---intLocalValue:$&#123;intLocal.get()&#125;&quot;)</span><br><span class="line">        intLocal.set(intLocal.get()+mId)</span><br><span class="line">        println(&quot;$&#123;currentThread().name&#125;---intLocalValue:$&#123;intLocal.get()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val intLocal = object : ThreadLocal&lt;Int&gt;()&#123;</span><br><span class="line">        override fun initialValue(): Int &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i in 1..3) &#123;</span><br><span class="line">        TestThread(intLocal,i).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadLocal</p>
<p>每个线程内部都有一个ThreadLocalMap，key是ThreadLocal实例，value是其保存的值</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/ThreadLocal%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>在线程内部存存值时，首先拿到当前线程的ThreadLocalMap，然后将当前的ThreadLocal作为key，ThreadLocal包裹的值为value存入，所以就有了上图，多个线程的key是同一个ThreadLocal实例，但value是不同，因为是新建的一个副本，可以看到上面<code>initialValue</code>方法中返回值都是新建的副本，如果没有重写这个方法，或者在赋初值时不是new出来的副本，同样不是线程安全的</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/Entry%E7%BB%93%E6%9E%84.png"></p>
<p>观察一下Entry的结构，继承了弱引用，这点很关键，即便如此也会存在内存泄漏</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png"></p>
<p>根据上面的分析，很容易得出上面的两个引用链，图中的虚线就是Entry继承了弱引用的缘故，如果外部对ThreadLocal的引用解除，发生垃圾回收时ThreadLocal的实例就会被回收，那么此时Entry中的Key就会为null，正因此下次赋值前若发现key==Null,就会对value进行回收，就可以减少内存泄漏，如果ThreadLocal使用完，最好调用remove移除</p>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>volatile比较简单，平时开发中也常用，ThreadLocal倒用的很少，开源框架如EventBus中有见过，需要注意的两个问题就是保存一定要是副本才能保证线程安全，用完后一定要调用remove进行移除防止内存泄漏</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8CThreadLocal.html" data-id="clchkr8nf002p5oqhc6al0g65" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java阻塞队列和线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.html" class="article-date">
  <time datetime="2021-12-05T02:49:36.000Z" itemprop="datePublished">2021-12-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.html">Java阻塞队列和线程池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>关于阻塞队列和线程池以往用得少，如果写自己的框架就需要很熟悉，下面系统地介绍一下</p>
</blockquote>
<h3 id="二-阻塞队列"><a href="#二-阻塞队列" class="headerlink" title="二.阻塞队列"></a>二.阻塞队列</h3><blockquote>
<p>阻塞队列在实际开发中基本都是用来解决生产者和消费者问题，当队列满了，所有生产者都会阻塞等待被唤醒，队列为空，所有消费者都会阻塞等待被唤醒</p>
</blockquote>
<p>阻塞队列-&gt;BlockingQueue接口，下面看一下它提供的放入和取出方法，都是成对的</p>
<ol>
<li>add()和remove()，都是非阻塞的，当队列满了，add会抛异常，队列为空，remove会抛异常</li>
<li>offer()和poll()，当队列满了，offer返回false，队列为空，poll返回null，同样是非阻塞</li>
<li>put()和take()，当队列满了，放不进则阻塞，队列为空，取不到则阻塞</li>
</ol>
<p>下面简单介绍一下阻塞队列的几个实现：</p>
<ol>
<li><p>ArrayBlockingQueue：由数组结构组成的有界阻塞队列，初始化时必须传入容量</p>
<p>初始化时还可以传入fair参数指定是否是公平访问，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列</p>
</li>
<li><p>LinkedBlockingQueue：由链表结构组成的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE</p>
</li>
</ol>
<blockquote>
<p>简单提一下Array和Link两种实现方式的区别：</p>
<ol>
<li><p>队列中锁的实现不同<br>ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁</p>
<p>LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock</p>
</li>
<li><p>在生产或消费时操作不同<br>ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的<br>LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node<E>进行插入或移除，会影响性能</p>
</li>
<li><p>队列大小初始化方式不同<br>ArrayBlockingQueue实现的队列中必须指定队列的大小<br>LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE</p>
</li>
</ol>
</blockquote>
<ol start="3">
<li><p>PriorityBlockingQueue：支持优先级的无界阻塞队列，默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
</li>
<li><p>DelayQueue：支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，就算队列中有元素也只有在延迟期满时才能从队列中提取元素。</p>
<p>运用场景：缓存系统的设计-&gt;可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程，队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
</li>
<li><p>LinkedTransferQueue：新增transfer和tryTransfer方法<br>（1）transfer方法<br>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。<br>（2）tryTransfer方法<br>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
</li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<br>新增addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p>
</li>
</ol>
<p>以上介绍的阻塞队列常用的就是数组和链表实现的，使用简单，下面通过DelayQueue简单模拟订单的限时支付</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">data class Order(val orderNo: String, val orderMoney: Int)</span><br><span class="line">class PutOrderThread(private val delayQueue: DelayQueue&lt;ItemVo&lt;Order&gt;&gt;): Thread() &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val order = Order(&quot;123&quot;,12)</span><br><span class="line">        val itemVo =</span><br><span class="line">            ItemVo&lt;Order&gt;(5, order)</span><br><span class="line">        delayQueue.offer(itemVo)</span><br><span class="line">        println(&quot;订单5秒后超时: $&#123;order.orderMoney&#125;---$&#123;order.orderNo&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        val order2 = Order(&quot;1234&quot;,123)</span><br><span class="line">        val itemVo2 =</span><br><span class="line">            ItemVo&lt;Order&gt;(8, order2)</span><br><span class="line">        delayQueue.offer(itemVo2)</span><br><span class="line">        println(&quot;订单8秒后超时: $&#123;order.orderMoney&#125;---$&#123;order.orderNo&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FetchOrderThread(private val delayQueue: DelayQueue&lt;ItemVo&lt;Order&gt;&gt;): Thread()&#123;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            print(&quot;开始取数据&quot;)</span><br><span class="line">            val itemVo = delayQueue.take()</span><br><span class="line">            val order = itemVo.data</span><br><span class="line">            println(&quot;取出的数据：$&#123;order.orderNo&#125;----$&#123;order.orderMoney&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ItemVo&lt;T&gt;(expirationTime: Long, data: T) : Delayed &#123;</span><br><span class="line">    //到期时间,但传入的数值代表过期的时长，传入单位毫秒</span><br><span class="line">    val activeTime: Long</span><br><span class="line">    val data: T//业务数据，泛型</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这个方法返回到激活日期的剩余时间，时间单位由单位参数指定。</span><br><span class="line">     */</span><br><span class="line">    override fun getDelay(unit: TimeUnit): Long &#123;</span><br><span class="line">        return unit.convert(activeTime - System.currentTimeMillis(), unit</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     *Delayed接口继承了Comparable接口，按剩余时间排序，实际计算考虑精度为纳秒数</span><br><span class="line">     */</span><br><span class="line">    override fun compareTo(other: Delayed): Int &#123;</span><br><span class="line">        val d = (getDelay(TimeUnit.MILLISECONDS)</span><br><span class="line">                - other.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">        return if (d == 0L) &#123;</span><br><span class="line">            0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (d &lt; 0) &#123;</span><br><span class="line">                -1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //传入过期时长,单位秒，内部转换</span><br><span class="line">    init &#123;</span><br><span class="line">        activeTime = expirationTime * 1000 + System.currentTimeMillis()</span><br><span class="line">        this.data = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val delayQueue = DelayQueue&lt;ItemVo&lt;Order&gt;&gt;()</span><br><span class="line">    PutOrderThread(delayQueue).start()</span><br><span class="line">    FetchOrderThread(delayQueue).start()</span><br><span class="line">    //每隔500毫秒，打印个数字</span><br><span class="line"></span><br><span class="line">    //每隔500毫秒，打印个数字</span><br><span class="line">    for (i in 1..14) &#123;</span><br><span class="line">        Thread.sleep(500)</span><br><span class="line">        println(i * 500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-线程池"><a href="#三-线程池" class="headerlink" title="三.线程池"></a>三.线程池</h3><p><strong>为什么需要使用线程池：</strong></p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ol>
<p><strong>创建线程池的参数解析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize<br>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；<br>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li>maximumPoolSize<br>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</li>
<li>keepAliveTime<br>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</li>
<li>TimeUnit<br>keepAliveTime的时间单位</li>
<li>workQueue<br>workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。<br>一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：<br>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。<br>2）由于1，使用无界队列时maximumPoolSize将是一个无效参数。<br>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。<br>4）更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</li>
<li>threadFactory<br>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。<br>Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</li>
<li>RejectedExecutionHandler<br>线程池的饱和(拒绝)策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<br>（1）AbortPolicy：直接抛出异常，默认策略；<br>（2）CallerRunsPolicy：用调用者所在的线程来执行任务；<br>（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>（4）DiscardPolicy：直接丢弃任务；<br>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</li>
</ol>
<p><strong>线程池的工作机制：</strong></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" style="zoom:50%;" />

<p><strong>常用的线程池：</strong></p>
<p>即便知道每个参数的含义，平时开发中也很少自己创建线程池，因为jdk已经为我们提供了常用的线程池</p>
<ol>
<li><p>newCachedThreadPool</p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>这种类型的线程池特点是：</p>
<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
</li>
<li><p>newFixedThreadPool</p>
<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
</li>
<li><p>newSingleThreadExecutor</p>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
</li>
<li><p>newScheduleThreadPool</p>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>
</li>
</ol>
<p><strong>最后需要合理使用线程池：</strong></p>
<p>首先分析任务的特性：CPU密集型任务、IO密集型任务和混合型任务。</p>
<ol>
<li><p>任务的优先级：高、中和低。</p>
</li>
<li><p>任务的执行时间：长、中和短。</p>
</li>
<li><p>任务的依赖性：是否依赖其他系统资源，如数据库连接。</p>
</li>
</ol>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu，可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>从以往的开发经验来说，对于耗时任务的处理，小编见过线程池处理和HandlerThread处理两种方式，关于线程池，需要知道大概的工作流程，以及常用的几种线程池，无论使用哪种，在个人开发中其实影响不大</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.html" data-id="clchkr8mu00155oqh38r02s2u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于Java并发的总结以及CAS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%85%B3%E4%BA%8EJava%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8ACAS.html" class="article-date">
  <time datetime="2021-12-04T14:29:19.000Z" itemprop="datePublished">2021-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%85%B3%E4%BA%8EJava%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8ACAS.html">关于Java并发的总结以及CAS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>关于java并发，这里对以往做一个小结，以及补充一些新的东西</p>
</blockquote>
<h3 id="二-Java多线程小结"><a href="#二-Java多线程小结" class="headerlink" title="二.Java多线程小结"></a>二.Java多线程小结</h3><ol>
<li><p>开启线程的方式只有两种：①继承Thread ②实现Runnable并交付Thread，<strong>JDK源码是这样标识的，Callable不算，本质还是Runnable</strong>，Thread是对线程的抽象，Runnable是对任务的抽象</p>
</li>
<li><p>同一个线程对象不能两次调用start启动，否则抛异常，因为存在是否是首次启动的标志判断</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/thread_start.png" style="zoom:50%;" /></li>
<li><p>关于中断线程，不要使用stop、destroy方法，而应该将业务代码放在<code>isInterrupted()</code>判断的代码块中执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(isInterrupted()) &#123;</span><br><span class="line"> 	只有没有被设置中断位才执行逻辑</span><br><span class="line"> 	另外如果有休眠操作，还需要捕获异常，并在catch语句中再次interrupt()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>外部调用interrupt()标识要中断线程不再执行业务代码，而Thread.interrupted()不会改变中断标志位，所谓的中断方法并非真正中断了线程，而是改变标识，这里不要通过手动设置一个变量来控制线程是否中断，因为如果存在sleep或者其他阻塞式调用，不起作用</p>
</li>
<li><p>使用join()可以让多个线程<strong>顺序执行</strong></p>
</li>
<li><p>通过setDaemon()可以让用户级线程变成守护线程，当所有用户线程结束，守护线程才会结束，fianlly代码块在守护线程中不一定会执行，但在用户线程是一定会执行</p>
</li>
<li><p>finalize()方法用来进行资源的回收，但系统不推荐在这里面进行，因为有可能不会执行</p>
</li>
<li><p>设置线程的优先级有可能没有意义，取决于操作系统怎么调度，不过可以用，像IO操作、下载操作的优先级可以弄高点</p>
</li>
</ol>
<h3 id="三-关于锁的小结"><a href="#三-关于锁的小结" class="headerlink" title="三.关于锁的小结"></a>三.关于锁的小结</h3><p>关于死锁的原因：</p>
<ol>
<li>存在多个操作者争夺资源，并且操作者的数量大于资源数量</li>
<li>争夺资源的顺序不对</li>
<li>拿到资源不放手</li>
</ol>
<p>官方:</p>
<ol>
<li>互斥条件</li>
<li>请求与保持</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ol>
<p>锁的分类：</p>
<ol>
<li>内置锁(隐式锁)：通过synchronized关键字来实现，要么锁方法，要么锁代码块，出了synchronized的范围才会自动释放锁资源，这里需要注意的是一定要锁同一个对象才会起作用</li>
<li>显示锁：常用的就是ReentrantLock，通过调用lock和unlock来使得这区间的代码块同步</li>
</ol>
<p>根据产生死锁的原因来说，要解决死锁问题，我们可以从2和3入手，通过synchronized改变请求资源的顺序可以解决死锁问题，通过显示锁手动释放资源解决死锁，下面分别简单演示一下</p>
<p>①synchronized合理安排请求顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程一</span><br><span class="line">synchronized(A资源) &#123;</span><br><span class="line">		synchronized(B资源) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程二</span><br><span class="line">synchronized(A资源) &#123;</span><br><span class="line">		synchronized(B资源) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的顺序就是合理的，同一时间只有一个线程才能拿到A锁，进而拿到B锁，如果线程二先拿B锁，那就会发生死锁，相互之间占有锁资源，而又相互请求对方手里的资源</p>
<p>②显示锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程一</span><br><span class="line">if(LockA.tryLock()) &#123;</span><br><span class="line">		try&#123;</span><br><span class="line">				if(LockB.tryLock()) &#123;</span><br><span class="line">						try&#123;</span><br><span class="line">								都拿到了，做业务</span><br><span class="line">						&#125;finally&#123;</span><br><span class="line">							LockB.unLock()</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">					//没拿到B锁，就将A锁释放</span><br><span class="line">					LockA.unLock()</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程二</span><br><span class="line">if(LockB.tryLock()) &#123;</span><br><span class="line">		try&#123;</span><br><span class="line">				if(LockA.tryLock()) &#123;</span><br><span class="line">						try&#123;</span><br><span class="line">								都拿到了，做业务</span><br><span class="line">						&#125;finally&#123;</span><br><span class="line">							LockA.unLock()</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">					//没拿到A锁，就将B锁释放</span><br><span class="line">					LockB.unLock()</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到他们请求的资源顺序其实是不合理的，但是如果另外一个资源被对方拿到，那么就将自己已经拿到的锁资源释放，也就是打破拿到资源不放手</p>
<h3 id="四-关于CAS"><a href="#四-关于CAS" class="headerlink" title="四.关于CAS"></a>四.关于CAS</h3><blockquote>
<p>首先先提一下原子操作，原子操作简单说一气呵成，中间不能被打断，synchronized实现的就是一种原子操作，所以用锁可以实现原子操作</p>
</blockquote>
<p>CAS的全称是Compare And Swap，基本原理是循环一条指令，直到成功为止</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/CAS%E5%8E%9F%E7%90%86.png" style="zoom:50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/CAS.%E5%AE%9E%E4%BE%8Bpng.png" style="zoom:50%;" />

<p>结合基本流程和一个实例来分析多个线程对一个基本变量的++操作，橙色部分就是CAS指令执行区，只能一个线程执行，箭头标识线程，首先比较原始值是否为0也就是是否有线程已经对它++操作，如果没有，就将它的值更改为1进行++操作。那么下一个线程发现值不等于0，则重新取值，重新计算，重复上述流程，有点类似于一个死循环来控制操作的同步性</p>
<p>根据上面的描述，发现CAS有以下弊端：</p>
<ol>
<li><p>ABA问题：就是说如果有一个线程执行速度很快，先将0变成1，再将1变成0，那么下一个线程看到结果是“值没变，没有线程对它操作”，解决这个问题可以通过打标识的方式，有如下两种：</p>
<p>a.AtomicMarkableReference-&gt;仅仅标识发生了ABA现象</p>
<p>b.AtomicStampedReference-&gt;可以知道发生了几次ABA现象</p>
</li>
<li><p>开销问题：不断地重复操作，肯定会带来一定的开销</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
</li>
</ol>
<p>后续JDK提供了基于CAS的原子类型：AutomicInteger、AutomicBoolean…..</p>
<p>那么我们为什么需要使用到这种原子类型？很多时候如果只是对一个变量简单加加减减操作，使用加锁的方式未免有些重了，这个时候就可以考虑使用原子类型，如果你需要改变多个变量，可以进行封装，通过AtomicReference来管理</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>关于同步的方式，这里介绍了两种，加锁和CAS实现的Automic类型，后续会介绍ThreadLocal，再进行对比三者的优劣，下面再简单说一下线程的几种操作对锁的影响</p>
</blockquote>
<ol>
<li>yield()只是让出时间片，并不会让出其他系统资源，不会释放锁</li>
<li>sleep()同样不会释放当前线程持有的锁</li>
<li>wait()会释放锁</li>
<li>notify/notifyAll对锁不会有影响</li>
</ol>
<p>上面提到两种锁方式，同样也是两种类型</p>
<ol>
<li>synchronized/Lock是悲观锁，考虑最坏的情况，担心会有线程同时修改数据，所以一上来就先锁上</li>
<li>Automic是乐观锁：不管怎样先把数据操作做了，如果有线程修改了重做就是，判断部分是同步过程</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%85%B3%E4%BA%8EJava%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8ACAS.html" data-id="clchkr8nq003d5oqhhfas2kew" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ViewBinding的高级用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/ViewBinding%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html" class="article-date">
  <time datetime="2021-12-02T03:01:31.000Z" itemprop="datePublished">2021-12-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/ViewBinding%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html">ViewBing的高级用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>在以前的日常开发中，免不了对每个控件的初始化-&gt;findViewById，使用Kotlin的扩展可以避免，但是xml中的id值通常以下划线分割，所以在实际使用时对于我这种强迫症患者来说不友好，很多时候还是会选择findViewById来初始化控件，使用Kotlin扩展还有一个不方便的地方，多个xml可能会存在id重复的情况，管理不方便，所以后续Google不推荐此方式，而是推出了ViewBinding，原理很简单，开启ViewBinding后，会根据xml的命名编译生成对应的Binding类，这个Binding类会和对应的xml进行绑定，解析时只需传入LayoutInflater即可，解析工作交给了Binding类，返回的ViewBinding对象就可以拿到所有的控件信息，个人觉得蛮好用的</p>
</blockquote>
<h3 id="二-ViewBinding的用法升级"><a href="#二-ViewBinding的用法升级" class="headerlink" title="二.ViewBinding的用法升级"></a>二.ViewBinding的用法升级</h3><blockquote>
<p>经过上面的介绍，发现一个问题，通过ViewBinding的解析，不用再使用findViewById，但ViewBinding也是需要我们自己初始化的，因为是编译期生成的Binding类，所以我们只能动态初始化，貌似没有一个模板可以用，前两天，小编在Github上发现了一个ViewBinding的工具类，只能说非常好用，通过指定泛型的方式就可以实现一个模板解析，下面先看用法，改造BaseActivity</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract class BaseActivity&lt;VIEW: ViewBinding&gt;: AppCompatActivity() &#123;</span><br><span class="line">    lateinit var binding: VIEW</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = inflateBindingWithGeneric(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        initData()</span><br><span class="line">        initListener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun initData()</span><br><span class="line"></span><br><span class="line">    abstract fun initListener()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类Activity中就可以直接通过binding这个属性来访问控件，免去了一个动态初始化的过程，因为Binding类是编译生成的，所以我们并不知道具体用哪个Binding类来解析，所以肯定会用到泛型，但是它仅仅是一个泛型而已，如何能通过这个泛型来解析呢，这个问题其实就是<strong>泛型+反射</strong>的解决方案</p>
<h3 id="三-原理探析"><a href="#三-原理探析" class="headerlink" title="三.原理探析"></a>三.原理探析</h3><blockquote>
<p>上面提到Binding类是编译生成的，所以运行时一定就存在，存在即可反射调用其内部的方法，通过查看生成的Binding类文件，内部其实就是一些解析方法，并且是静态的，所以传入类型直接反射调用得到具体的Binding对象，反射不难，这里的关键点是<strong>传入具体的Binding类型</strong>，可以看到上面的使用用例，子类在使用时肯定会指定具体的Binding类型，所以这时候我们就可以拿到具体的类型，下面看一下具体操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private fun &lt;VB : ViewBinding&gt; withGenericBindingClass(any: Any, block: (Class&lt;VB&gt;) -&gt; VB): VB &#123;</span><br><span class="line">    var genericSuperclass = any.javaClass.genericSuperclass</span><br><span class="line">    var superclass = any.javaClass.superclass</span><br><span class="line">    while (superclass != null) &#123;</span><br><span class="line">        if (genericSuperclass is ParameterizedType) &#123;</span><br><span class="line">            genericSuperclass.actualTypeArguments.forEach &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return block.invoke(it as Class&lt;VB&gt;)</span><br><span class="line">                &#125; catch (e: NoSuchMethodException) &#123;</span><br><span class="line">                &#125; catch (e: ClassCastException) &#123;</span><br><span class="line">                &#125; catch (e: InvocationTargetException) &#123;</span><br><span class="line">                    throw e.targetException</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        genericSuperclass = superclass.genericSuperclass</span><br><span class="line">        superclass = superclass.superclass</span><br><span class="line">    &#125;</span><br><span class="line">    throw IllegalArgumentException(&quot;There is no generic of ViewBinding.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法就是拿到父类中被指定的具体的泛型类型，可能存在多层继承的情况，所以需要通过一个循环来获取，便捷是便捷了许多，但效率不高，试想如果父类可指定的泛型很多，下面的循环是两层，不仅要遍历所有的父类，还要遍历父类可指定的所有泛型类型，而且每次都会invoke，将拿到的Class对象回调出去，所以会看到多个catch异常处理，但是使用已经很方便了，日常开发中损耗一点效率并无大碍</p>
<p><a target="_blank" rel="noopener" href="https://github.com/DylanCaiCoding/ViewBindingKTX">工具地址</a></p>
<h3 id="四-关于反思"><a href="#四-关于反思" class="headerlink" title="四.关于反思"></a>四.关于反思</h3><blockquote>
<p>小编刚开始没想过去看这个原理，因为和泛型、反射挂钩，过于抽象，日常开发中也很少用到反射，说白了就是一种恐惧感罢了，近日心血来潮，偶然接触到关于反射的一些理解，搭配注解进行一些改造，突发觉得反射也就那么回事，多练练手就好，比如下面的ID注入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object ViewIdInject &#123;</span><br><span class="line">    fun injectView(activity: Activity) &#123;</span><br><span class="line">        activity.javaClass.declaredFields.forEach &#123; field -&gt;</span><br><span class="line">            if (field.isAnnotationPresent(AutoWired::class.java)) &#123;</span><br><span class="line">                val autoWiredId = field.getAnnotation(AutoWired::class.java)</span><br><span class="line">                val view = activity.findViewById&lt;View&gt;(autoWiredId.id)</span><br><span class="line">                field.isAccessible = true</span><br><span class="line">                field.set(activity,view)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了一遍，基本能够想象出基本流程，再写一遍，嗯，就挺好的，对于java高级编程这块只能说多看，多用，多理解，多练手，更憧憬的是APT随心所欲搞一个自己的框架</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/ViewBinding%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html" data-id="clchkr8n800275oqheito3fvo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-访问者模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html" class="article-date">
  <time datetime="2021-11-23T09:30:13.000Z" itemprop="datePublished">2021-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html">访问者模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>访问者模式稍稍有点绕，它的应用场景是针对一个集合中存在不同类型的对象，它们有共同的父类，如果说只是简单的通过方法参数重载的方式来遍历这个集合中的元素，都会统一当成它们的父类类型类处理，无法识别具体的类型</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF.png"></p>
<p>现在需要统计库存中的所有水果总价格，很容易想到直接遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Visit &#123;</span><br><span class="line"></span><br><span class="line">	//苹果计价</span><br><span class="line">	public int sell(Apple apple)&#123;</span><br><span class="line">		System.out.println(&quot;apple&#x27;s price: ￥50&quot;);</span><br><span class="line">		return 50;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//桔子计价</span><br><span class="line">	public int sell(Orange orange)&#123;</span><br><span class="line">		System.out.println(&quot;orange&#x27;s price: ￥20&quot;);</span><br><span class="line">		return 20;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//香蕉计价</span><br><span class="line">	public int sell(Banana banana)&#123;</span><br><span class="line">		System.out.println(&quot;banana&#x27;s price: ￥30&quot;);</span><br><span class="line">		return 30;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//其它水果计价</span><br><span class="line">	public int sell(Fruit fruit)&#123;</span><br><span class="line">		System.out.println(&quot;other price: ￥10&quot;);</span><br><span class="line">		return 10;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//直接访问</span><br><span class="line">private static int price() &#123;</span><br><span class="line">        int total = 0;</span><br><span class="line">        for (Fruit fruit : list) &#123;</span><br><span class="line">            total += visit.sell(fruit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;总价值：&quot; + total);</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是问题很明显，就算传入了具体的类型，也无法识别，统一当做Fruit类型来处理，也就是调用的其他水果计价的方法，下面通过双重分派做一层中转</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E5%8F%8C%E9%87%8D%E5%88%86%E6%B4%BE.png"></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:50%;" />

<p>Fruit中新增一个accept方法并接收一个Visit对象进行转接访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line">   //省略冗余代码</span><br><span class="line">    public int accept(Visit visit)&#123;</span><br><span class="line">        return visit.sell(this);//指针可以传递真实类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历是通过调用Fruit的accept方法，传入Visit对象，内部再调Visit的sell方法进行计价，结果才符合预期，也就是说只有传入<strong>this指针</strong>才能具体区分实际类型，这也就是双重分派，所以访问者模式解决的具体问题如下</p>
<ol>
<li><p>集合中有不同类型的对象，通过方法重载（形参），无法识别它们的具体类型（出错）</p>
</li>
<li><p>通过双重委派，可以实现遍历识别，达成目标</p>
</li>
</ol>
<p>多态的方法重载是静态的</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>此番分析，访问者模式就是在被访问者内部新增一个接收访问者的一个方法，传入this指针，供其分辨具体类型，在实际遍历访问是，通过被访者的accept方法遍历即可</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html" data-id="clchkr8pd007p5oqh4j935ysa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-命令模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html" class="article-date">
  <time datetime="2021-11-23T09:30:02.000Z" itemprop="datePublished">2021-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html">命令模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>命令模式的核心就是面向接口编程，依赖接口，比如说客户端的一个列表页面，需要请求数据，如果说某一天后端返回的数据类型有变，导致样式改变，这时候就需要更改之前的请求代码，显然不优雅，如果将请求数据的功能抽离出来，通过注入接口类型的方式来请求不同类型的数据，改动小，并且符合开闭原则，拆卸容易</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>根据上面的描述，模拟列表请求不同类型的数据，中间抽离一个Command层</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%9E%8B.png"></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Command &#123;</span><br><span class="line">    public abstract String execute();</span><br><span class="line">&#125;</span><br><span class="line">public class DiscountCommand extends Command &#123;</span><br><span class="line"></span><br><span class="line">    private DiscountHandler handler = new DiscountHandler();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() &#123;</span><br><span class="line">        return handler.getDiscounts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DiscountHandler &#123;</span><br><span class="line">    public String getDiscounts()&#123;</span><br><span class="line">        System.out.println(&quot;返回优惠商品列表&quot;);</span><br><span class="line">        return &quot;优惠商品列表&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ListView &#123;</span><br><span class="line"></span><br><span class="line">    private Command command; //维持一个抽象命令对象的引用</span><br><span class="line"></span><br><span class="line">    //为功能键注入命令</span><br><span class="line">    public void setCommand(Command command) &#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //请求列表</span><br><span class="line">    public void getList() &#123;</span><br><span class="line">        System.out.print(&quot;首页请求&quot;);</span><br><span class="line">        String result = command.execute();</span><br><span class="line">        System.out.println(&quot;当前列表：&quot;+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">ListView listView = new ListView();</span><br><span class="line">listView.setCommand(new DiscountCommand());</span><br><span class="line">listView.getList();</span><br></pre></td></tr></table></figure>

<p>通过新增一层命令层，如果需要新的数据形式，直接新增对应的命令以及具体的数据请求即可，动态注入</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>命令模式在平常使用可能不会在意它是否是标准的，只要符合基本原则，拆卸容易，使用优雅，理解它的基本思想即可</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html" data-id="clchkr8ny003y5oqh60rd59ke" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">Android重要组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%A1%B9%E7%9B%AE/">Android项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html%E5%AD%A6%E4%B9%A0/">html学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/">系统控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%B3%BB%E5%88%97/">组件化系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">hexo博客搭建问题总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" rel="tag">学年设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" rel="tag">系统高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 18px;">Android常用琐碎知识点</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" style="font-size: 10px;">Android开发小Demo</a> <a href="/tags/Android%E9%AB%98%E7%BA%A7UI/" style="font-size: 16px;">Android高级UI</a> <a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 10px;">hexo博客搭建问题总结</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 10px;">发布开源库</a> <a href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">学年设计</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" style="font-size: 20px;">算法篇</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" style="font-size: 12px;">系统高级UI</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 14px;">网络开源库</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
          </li>
        
          <li>
            <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
          </li>
        
          <li>
            <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
          </li>
        
          <li>
            <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
          </li>
        
          <li>
            <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 EngineerOfFinger<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/%20%7C%7C%20fas%20fa-home" class="mobile-nav-link">主页</a>
  
    <a href="/archives/%20%7C%7C%20fas%20fa-archive" class="mobile-nav-link">时间轴</a>
  
    <a href="/tags/%20%7C%7C%20fas%20fa-tags" class="mobile-nav-link">标签</a>
  
    <a href="/categories/%20%7C%7C%20fas%20fa-folder-open" class="mobile-nav-link">分类</a>
  
    <a href="/link/%20%7C%7C%20fas%20fa-link" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>