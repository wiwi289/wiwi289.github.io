<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>梦幻泡影</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="success&#x3D;persistence">
<meta property="og:type" content="website">
<meta property="og:title" content="梦幻泡影">
<meta property="og:url" content="https://wiwiyiyi.com/page/2/index.html">
<meta property="og:site_name" content="梦幻泡影">
<meta property="og:description" content="success&#x3D;persistence">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="EngineerOfFinger">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="梦幻泡影" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wiwi.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦幻泡影</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/%20%7C%7C%20fas%20fa-home">主页</a>
        
          <a class="main-nav-link" href="/archives/%20%7C%7C%20fas%20fa-archive">时间轴</a>
        
          <a class="main-nav-link" href="/tags/%20%7C%7C%20fas%20fa-tags">标签</a>
        
          <a class="main-nav-link" href="/categories/%20%7C%7C%20fas%20fa-folder-open">分类</a>
        
          <a class="main-nav-link" href="/link/%20%7C%7C%20fas%20fa-link">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wiwiyiyi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android设计模式-MVVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVVM.html" class="article-date">
  <time datetime="2020-11-30T01:12:05.000Z" itemprop="datePublished">2020-11-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVVM.html">Android设计模式-MVVM搭配LiveData的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><p>在熟悉了MVC和MVP两种设计模式后，你可能会迷茫到底使用哪种，并且两种都有优缺点，实在难以决策，本文将介绍MVVM架构模式，相信看完本文后，你将会喜欢上MVVM的架构方式</p>
<h3 id="二-MVVM概述"><a href="#二-MVVM概述" class="headerlink" title="二.MVVM概述"></a>二.MVVM概述</h3><p>MVVM是 <strong>Model</strong>(数据模型)-<strong>View</strong>(视图)-<strong>ViewModel</strong>(视图模型)的简称</p>
<ul>
<li>View在此处指XML布局文件</li>
<li>将View与ViewModel进行关联主要是用于保存View中的数据，比如界面旋转导致Activity重构</li>
<li>ViewModel可以感知Activity的生命周期，既可以保存View中的数据，又不会让数据的生命周期过长</li>
</ul>
<p>下面先演示ViewModel的使用，然后再讲解ViewModel搭配LiveData，目的是减少Activity中的逻辑以及和View的数据交互，达到减轻Activity/Fragment的负担</p>
<h3 id="三-ViewModel的使用"><a href="#三-ViewModel的使用" class="headerlink" title="三.ViewModel的使用"></a>三.ViewModel的使用</h3><ol>
<li><p>添加依赖</p>
<p>ViewModel是JetPack组件，使用得在app模块中添加如下依赖</p>
<p><code> def lifecycle_version = &quot;2.2.0&quot;  implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/viewModel%E4%BE%9D%E8%B5%96.png" style="zoom: 50%;" /></li>
<li><p>创建一个类继承ViewModel，并添加一个与XML中关联的一个变量用于保存数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel:ViewModel() &#123;</span><br><span class="line">    var content:String = &quot;Android开发&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Activity/Fragment中通过<code>ViewProvider</code>加载<code>MyViewModel</code>的一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val viewModel = ViewModelProvider(this).get(MyViewModel::class.java)</span><br></pre></td></tr></table></figure></li>
<li><p>将ViewModel中的数据和View进行绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showText.text = viewModel.content</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>经过上面的步骤发现，通过一个ViewModel保存View中的数据(即绑定)，Activity/Fragment中只需处理逻辑业务</p>
</blockquote>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ViewModelShow.gif" style="zoom: 33%;" />

<p>可以看到当屏幕旋转后，View(XML)中的数据依旧还在，而不需要像之前那样在Activity销毁之前通过<strong>Bundle</strong>对象将值保存起来，再在Activity创建时取出来展示到界面上</p>
<h3 id="四-自定义Factory"><a href="#四-自定义Factory" class="headerlink" title="四.自定义Factory"></a>四.自定义Factory</h3><p>有些时候，我们希望在创建ViewModel对象的时候，传入一些参数，但根据上面的反射创建对象是无法传参数的，这时我们需要自定义Factory继承真正在创建ViewModel对象的<code>NewInstanceFactory</code>，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ViewModelProviderFactory:ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line">    override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        return MyViewModel(&quot;指尖上的工程师&quot;) as T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val viewModel = ViewModelProvider(this,ViewModelProviderFactory()).get(MyViewModel::class.java)</span><br></pre></td></tr></table></figure>

<p>在创建<code>ViewModel</code>时只需要把自定义的工厂类传入即可</p>
<h3 id="五-LiveData"><a href="#五-LiveData" class="headerlink" title="五.LiveData"></a>五.LiveData</h3><blockquote>
<p>MVVM的灵魂是将LiveData和ViewModel相结合，这样才能真正减轻Activity/Fragment的逻辑业务和数据处理的负担</p>
</blockquote>
<ol>
<li><p>首先在app模块中添加依赖</p>
<p><code>implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&quot;</code></p>
</li>
<li><p>在ViewModel创建<code>MutableLiveData</code>类型的变量</p>
<p>①存值</p>
<p>②监听值的改变</p>
</li>
<li><p>给<code>MutableLiveData</code>设置监听事件，这也是标准的监听者模式</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel():ViewModel() &#123;</span><br><span class="line">    var content:MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">    var name:MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">&#125;</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        val viewModel = ViewModelProvider(this).get(MyViewModel::class.java)</span><br><span class="line">        viewModel.content.observe(this)&#123;</span><br><span class="line">            showText.text = it</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.name.observe(this)&#123;</span><br><span class="line">            //具体操作</span><br><span class="line">        &#125;</span><br><span class="line">        convert.setOnClickListener &#123;</span><br><span class="line">            viewModel.content.value = &quot;我爱Android&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：一个界面中的元素很多，所以很多值都是活的，因此ViewModel中<code>MutableLiveData</code>的数量可以很多</p>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><blockquote>
<p>将LiveData和ViewModel结合后，Activity/Fragment不用直接操纵View，确实减轻了不少负担，并且还减少了很多事件回调，只能说MVVM真的很香</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/android-design-pattern-mvvm">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVVM.html" data-id="clchkr8mh000j5oqhbjdc327p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-自定义PhotoView处理手势" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html" class="article-date">
  <time datetime="2022-01-29T12:43:41.000Z" itemprop="datePublished">2022-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面比较完善的介绍了触摸事件的分发流程，也简单进行了实战，本文也是进行一个补充，在复杂的UI中会用到手势处理以及多点滑动，下面会重点介绍用到的API</p>
</blockquote>
<h3 id="二-手势处理API"><a href="#二-手势处理API" class="headerlink" title="二.手势处理API"></a>二.手势处理API</h3><blockquote>
<p>下面通过自定义PhotoView来使用手势处理的相关API，代码就不贴了，对于缩放是有一些逻辑的，这里就不详解了，重点在于介绍手势处理API</p>
</blockquote>
<p>Android中有一个类专门管理和处理手势：<code>GestureDetector</code>，需要传入一个<code>OnGestureListener</code>对象，其实具体手势的处理就是交给这个<code>OnGestureListener</code>去处理的，通常选择传入<code>SimpleOnGestureListener</code>的一个实例，因为<code>SimpleOnGestureListener</code>实现了几个接口，功能比较齐全，而且我们可以有选择性的重写想要的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">inner class PhotoGestureDetector : GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">				// 在ACTION_DOWN时触发，必定触发</span><br><span class="line">        override fun onDown(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">				// 延时100ms，处理点击效果</span><br><span class="line">        override fun onShowPress(e: MotionEvent) &#123;</span><br><span class="line">            super.onShowPress(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// up时触发，单击或双击的第一次，不是双击和长按</span><br><span class="line">        override fun onSingleTapUp(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onSingleTapUp(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 滚动，后面会详解参数</span><br><span class="line">        override fun onScroll(e1: MotionEvent, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean &#123;</span><br><span class="line">            return super.onScroll(e1, e2, distanceX, distanceY)</span><br><span class="line">        &#125;</span><br><span class="line">				// 长按触发，默认达到300ms就会触发</span><br><span class="line">        override fun onLongPress(e: MotionEvent) &#123;</span><br><span class="line">            super.onLongPress(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 手指松开后，惯性滑动，大于50dp/s</span><br><span class="line">        override fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean &#123;</span><br><span class="line">            return super.onFling(e1, e2, velocityX, velocityY)</span><br><span class="line">        &#125;</span><br><span class="line">				// 单击按下时触发，双击不触发，up和down都有可能触发</span><br><span class="line">				// 延时300ms触发TAP事件</span><br><span class="line">				// 300ms以内抬手才会触发TAP</span><br><span class="line">				// 300ms以后抬手，不是双击，不是长按就触发</span><br><span class="line">        override fun onSingleTapConfirmed(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onSingleTapConfirmed(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 双击，在ACTION_DWON中处理，触发时间 40-300ms</span><br><span class="line">        override fun onDoubleTap(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onDoubleTap(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 双击的第二次Down、move、up都会触发这个</span><br><span class="line">        override fun onDoubleTapEvent(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onDoubleTapEvent(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onContextClick(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onContextClick(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注：上述方法必须重写的是<code>onDown</code>，如果决定处理就必须返回true，其他的按需重写，返回值可以不用重写</p>
<p>上述代码中粗略的补齐了每个方法大致的调用时机，其实继承<code>SimpleOnGestureListener</code>有很多好处，这个类还帮我们实现类其他几个接口，并且很常用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static class SimpleOnGestureListener implements OnGestureListener, OnDoubleTapListener,</span><br><span class="line">            OnContextClickListener</span><br></pre></td></tr></table></figure>

<p>然后再回到<code>GestureDetector</code>的构造函数中来，看这样继承的好处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public GestureDetector(Context context, OnGestureListener listener, Handler handler) &#123;</span><br><span class="line">        if (handler != null) &#123;</span><br><span class="line">            mHandler = new GestureHandler(handler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mHandler = new GestureHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        if (listener instanceof OnDoubleTapListener) &#123;</span><br><span class="line">            setOnDoubleTapListener((OnDoubleTapListener) listener);</span><br><span class="line">        &#125;</span><br><span class="line">        if (listener instanceof OnContextClickListener) &#123;</span><br><span class="line">            setContextClickListener((OnContextClickListener) listener);</span><br><span class="line">        &#125;</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现系统会自动识别当前是否实现了OnDoubleTapListener和OnContextClickListener，就不用我们自己后续在进行注入了</p>
<p>另外需要注意的一个点是，如果<code>GestureDetector</code>是在子线程中创建的，还必须得调用<code>Looper.prepare()</code>，因为如果我们不手动传入一个handler实例，系统就会帮我们new一个，而Handler是会和所在线程进行一个绑定，必须进行prepare，而这个handler就是来处理触摸事件的，下面通过一张图来进行描述它们之间的关系</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" style="zoom: 33%;" />

<p>剩下的事情就是实际撸码来完成回调函数的逻辑了，比如双击放大，双击缩小</p>
<h3 id="三-展示双击放大-缩小-的回调逻辑处理"><a href="#三-展示双击放大-缩小-的回调逻辑处理" class="headerlink" title="三.展示双击放大(缩小)的回调逻辑处理"></a>三.展示双击放大(缩小)的回调逻辑处理</h3><p>基本思路：</p>
<p>通过一个变量来标识当前是放大还是缩小状态，每次取反即可</p>
<p>此前还有一些准备工作，譬如在<code>onSizedChange</code>中定义缩小状态和放大状态，这是由图片的尺寸比和承载它的View的尺寸比来决定的，具体逻辑不深究，有点烧脑吧，详情看代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private var isEnlarge = false</span><br><span class="line">var currentScale = 0f</span><br><span class="line">         set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">val scaleAnimator: ObjectAnimator by lazy &#123;</span><br><span class="line">        ObjectAnimator.ofFloat(this, &quot;currentScale&quot;, smallScale,bigScale)</span><br><span class="line">    &#125;</span><br><span class="line">inner class PhotoGestureDetector : GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        override fun onDown(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        override fun onDoubleTap(e: MotionEvent): Boolean &#123;</span><br><span class="line">            isEnlarge = !isEnlarge</span><br><span class="line">            if (isEnlarge) &#123;</span><br><span class="line">                offsetX = e.x - width / 2f - (e.x - width / 2f) * bigScale / smallScale</span><br><span class="line">                offsetY = e.y - height / 2f - (e.y - height / 2f) * bigScale / smallScale</span><br><span class="line">                fixOffsets()</span><br><span class="line">                scaleAnimator.start()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scaleAnimator.reverse()</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onDoubleTap(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面就展示关键代码即可，为了让缩放更顺滑，通过一个属性动画来管理，所以思维不要局限，要知道属性动画就是<strong>针对属性</strong>的，并不是说一定要View自带的系统属性才能做属性动画，只需要在set值的时候做一个invalidate刷新即可，其他的处理，譬如偏移值，就不介绍了，因为我们总不能以图片或者View的中心点做为缩放的中心，应该以触摸点做缩放才合理，所以需要偏移</p>
<blockquote>
<p>这种所谓的缩放平移处理，就是让画布进行缩放平移，并且提供有相应的API，我们无需考虑</p>
</blockquote>
<p>值得注意的几点：</p>
<ol>
<li><p>滚动</p>
<p>滚动其实使用<code>onScroll</code>函数提供的distance参数即可，因为distance和画布translate的方向相反，所以需要取负数，不断的invalidate刷新即可，然后控制一下滚动的边界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetX = Math.min(offsetX, (bitmap.width * bigScale - width) / 2)</span><br><span class="line">    offsetX = Math.max(offsetX, -(bitmap.width * bigScale - width) / 2)</span><br><span class="line">    offsetY = Math.min(offsetY, (bitmap.height * bigScale - height) / 2)</span><br><span class="line">    offsetY = Math.max(offsetY, -(bitmap.height * bigScale - height) / 2)</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E8%8C%83%E5%9B%B4%E7%BA%A6%E6%9D%9F.png" style="zoom:33%;" /></li>
<li><p>惯性滑动Fling</p>
<p>需要借助OverScroller，不过Scroller也可以，但是OverScroller还可以额外滚动，添加over值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">override fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean &#123;</span><br><span class="line">            // overX overY就是为什么使用overScroller的原因</span><br><span class="line">            if (isEnlarge) &#123;</span><br><span class="line">                overScroller.fling(offsetX.toInt(), offsetY.toInt(), velocityX.toInt(), velocityY.toInt(),</span><br><span class="line">                    -((bitmap.width * bigScale - width) / 2).toInt(), ((bitmap.width * bigScale - width) / 2).toInt(),</span><br><span class="line">                    -((bitmap.height * bigScale - height) / 2).toInt(), ((bitmap.height * bigScale - height) / 2).toInt()</span><br><span class="line">                ,300, 300)</span><br><span class="line">                //下一帧的动画的时候执行</span><br><span class="line">                postOnAnimation(FlingRunnable())</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return super.onFling(e1, e2, velocityX, velocityY)</span><br><span class="line">        &#125;</span><br><span class="line">inner class FlingRunnable : Runnable &#123;</span><br><span class="line">        override fun run() &#123;</span><br><span class="line">            if (overScroller.computeScrollOffset()) &#123;</span><br><span class="line">                offsetX = overScroller.currX.toFloat()</span><br><span class="line">                offsetY = overScroller.currY.toFloat()</span><br><span class="line">                invalidate()</span><br><span class="line">                postOnAnimation(this)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此外还需提供一个惯性滚动的刷新任务，不断调用自己，每时每刻进行刷新偏移值</p>
</li>
<li><p>双指缩放</p>
<p>这里的双指缩放并没有使用多点触摸处理，系统为我们提供了相应的API做处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inner class PhotoScaleGesture : ScaleGestureDetector.OnScaleGestureListener &#123;</span><br><span class="line">        private var initScale = 0f</span><br><span class="line">        override fun onScale(detector: ScaleGestureDetector): Boolean &#123;</span><br><span class="line">            if ((currentScale &gt; smallScale &amp;&amp; !isEnlarge) || (currentScale == smallScale &amp;&amp; !isEnlarge)) &#123;</span><br><span class="line">                isEnlarge = !isEnlarge</span><br><span class="line">            &#125;</span><br><span class="line">            // 缩放因子</span><br><span class="line">            currentScale = initScale * detector.scaleFactor</span><br><span class="line">            invalidate()</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        override fun onScaleBegin(detector: ScaleGestureDetector?): Boolean &#123;</span><br><span class="line">            initScale = currentScale</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        override fun onScaleEnd(detector: ScaleGestureDetector?) &#123; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只不过这里和普通的手势处理由冲突，只能满足一个，所以在onTouchEvent里面需要判断使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        // 响应事件优先考虑双指缩放</span><br><span class="line">        var result = scaleGestureDetector.onTouchEvent(event)</span><br><span class="line">        if (!scaleGestureDetector.isInProgress) &#123;</span><br><span class="line">            result = gestureDetector.onTouchEvent(event)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四-多点触摸事件处理"><a href="#四-多点触摸事件处理" class="headerlink" title="四.多点触摸事件处理"></a>四.多点触摸事件处理</h3><p>上述都是系统为我们提供了常用手势处理的API，而之前梳理的事件分发都是单点触摸，下面对多点触摸进行一个补充</p>
<ul>
<li><p>单点触摸在onTouchEvent中使用的是action作为分支判断，而多点触摸使用的是<code>actionMasked</code></p>
</li>
<li><p>系统会为每一根手指分配一个index和id</p>
</li>
<li><p>一根手指抬起，后续的index会往前移动，id值必须是连续的，如果id为0的手指抬起了，后面的手指的index往前移，现在又按下一根手指，那么就补齐id为0的位置进行插入</p>
</li>
<li><p>这里补充说明一下offset累积的原因，当一个手指按下时，经历过dwon事件后，会立即经历move事件，所以如果不累积上次move的距离，那么offset就会从0开始计算，重绘的时候就会出现跳动情况，这里面稍微有点绕，需要慢慢理</p>
</li>
<li><p>ACTION_DWON永远只会触发一次，而ACTION_POINTER_DOWN有多次，所以每次down事件都需要更新触摸点的位置以及offset的值，否则跳动</p>
</li>
<li><p>剩余的事情就是如何管理多指触摸，如果我们需要实现让最后一根按下的手指可以响应滑动，那么就得通过id来进行标识，每按下一根手指都更新<strong>currentId</strong>，然后在move事件中通过<strong>currentId</strong>来拿取index的值，获取x/y坐标时通过index来获取，那么此时就是根据最后一根按下的手指来进行滑动处理了</p>
</li>
<li><p>实现了按下处理的逻辑，抬起手指又该作何处理，经过实验证明抬起没有生效的手指是不会发生数组越界的异常的，比如你按下3根，那么生效的一定是最后一个手指，此时你抬起1和2是不会有影响的，因为<strong>currentId</strong>没有改变，改变的只是index，那么不是抬起1和2，而是抬起生效的手指也就是第三根手指，就会崩溃，因为我们没有更新<strong>currentId</strong>的值，此时的<strong>currentId</strong>为2(从0开始计算)，所以我们只需要处理抬起生效手指的逻辑即可</p>
</li>
<li><p>有了上面的分析，这里就简单贴一下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        when(event.actionMasked) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                downX = event.x</span><br><span class="line">                downY = event.y</span><br><span class="line">                lastOffsetX = offsetX</span><br><span class="line">                lastOffsetY = offsetY</span><br><span class="line">                currentId = 0</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                val index = event.findPointerIndex(currentId)</span><br><span class="line">                offsetX = lastOffsetX + event.getX(index) - downX</span><br><span class="line">                offsetY = lastOffsetY + event.getY(index) - downY</span><br><span class="line">                invalidate()</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_POINTER_DOWN -&gt; &#123;</span><br><span class="line">                val pointerIndex = event.actionIndex</span><br><span class="line">                currentId = event.getPointerId(pointerIndex)</span><br><span class="line">                downX = event.getX(pointerIndex)</span><br><span class="line">                downY = event.getY(pointerIndex)</span><br><span class="line">                lastOffsetX = offsetX</span><br><span class="line">                lastOffsetY = offsetY</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_POINTER_UP -&gt; &#123;</span><br><span class="line">                var upIndex = event.actionIndex</span><br><span class="line">                val id = event.getPointerId(upIndex)</span><br><span class="line">                if (id == currentId) &#123;</span><br><span class="line">                    if (upIndex == event.pointerCount - 1) &#123;</span><br><span class="line">                        upIndex = event.pointerCount - 2</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        upIndex++</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentId = event.getPointerId(upIndex)</span><br><span class="line">                    downX = event.getX(upIndex)</span><br><span class="line">                    downY = event.getY(upIndex)</span><br><span class="line">                    lastOffsetX = offsetX</span><br><span class="line">                    lastOffsetY = offsetY</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单说一下抬起的处理思路，如果当前抬起的id为currentId才会做处理，然后再根据当前生效手指在手指数组中的位置做处理，如果是数组末尾也就是最后一根按下的手指，那么就交给它前面的一根手指做处理，否则交给它后面的手指做处理，明白index的插入原理后，就可以随意做处理了。</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/aaefbd048bcba786b6797addc23a66b5bc9be364">完整代码见链接</a></p>
</li>
</ul>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>多点触控很少用到吧，手势处理用的多一点，可以实现一些比较炫酷的效果。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html" data-id="clchkr8p4006v5oqh5pjicw6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-首次开源库-不一样的文字渐变效果" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html" class="article-date">
  <time datetime="2022-01-26T09:12:37.000Z" itemprop="datePublished">2022-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>此前也常有自定义View，其实功能都是建立在自定义绘制的基础上，这次记录一下，顺便发布到MavenCentral中去，本次要发布的是一个文字渐变效果的TextView，所以算是对系统控件的一个扩展，使用场景比较巧合，当时首次使用用作一段文本的渐变效果，思虑一番，发现对文本做渐变效果的控件貌似还没有，下面会通过两种方式来实现相同的效果</p>
</blockquote>
<h3 id="二-自定义View搭配自定义ViewGroup实现文本渐变"><a href="#二-自定义View搭配自定义ViewGroup实现文本渐变" class="headerlink" title="二.自定义View搭配自定义ViewGroup实现文本渐变"></a>二.自定义View搭配自定义ViewGroup实现文本渐变</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%96%87%E6%9C%AC%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9Cshow.gif" style="zoom:50%;" />

<p>首先来感受一下效果，哎，发现貌似还挺简单的，不过实际处理起来真不简单，如果没有找到合适的切入点，对于这种段落式效果，很容易想到分行嘛，外层是线性布局，所以就有了第一版，也许会很好奇，段落，一个TextView不就搞定了吗，确实是，但是你要如何实现逐行的动画，每一行作为一个单元，还能单独测量每一行，区分每一行的标志就是换行，如果纯自定义的话又如何能实现，所以这里只能先分两步，自定义单元行，以及容器，下面简单展示一下代码结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">class ClipAbleTextView @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : View(context, attr, style) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        parseAttr(attr)</span><br><span class="line">    &#125;</span><br><span class="line">    //记录外设属性</span><br><span class="line">    private var textBgColor: Int = 0</span><br><span class="line">    private var textForeColor: Int = 0</span><br><span class="line">    private var mTextSize: Float = 0f</span><br><span class="line">    private lateinit var mContent: String // 聚宝坑</span><br><span class="line">//    private var mContent: String = &quot; &quot;</span><br><span class="line"></span><br><span class="line">    //背景起始画笔</span><br><span class="line">    private var textBgPaint = Paint().apply &#123;</span><br><span class="line">        color = textBgColor</span><br><span class="line">        textSize = mTextSize</span><br><span class="line">        setStyle(Paint.Style.FILL)</span><br><span class="line">    &#125;</span><br><span class="line">    //渐变画笔</span><br><span class="line">    private var textForePaint = Paint().apply &#123;</span><br><span class="line">        color = textForeColor</span><br><span class="line">        textSize = mTextSize</span><br><span class="line">        setStyle(Paint.Style.FILL)</span><br><span class="line">    &#125;</span><br><span class="line">    //行高</span><br><span class="line">    private val lineHeight: Float by lazy &#123;</span><br><span class="line">        val rect = Rect()</span><br><span class="line">        textBgPaint.getTextBounds(mContent, 0, mContent.length, rect)</span><br><span class="line">        rect.height().toFloat()</span><br><span class="line">    &#125;</span><br><span class="line">    //渐变因子</span><br><span class="line">    private var gradualFactor = 0f</span><br><span class="line"></span><br><span class="line">    private fun parseAttr(attr: AttributeSet?) &#123;</span><br><span class="line">        if (attr == null) &#123;</span><br><span class="line">            Log.e(TAG,&quot;attr is null!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        val typedArray: TypedArray = context.obtainStyledAttributes(attr, R.styleable.ClipAbleTextView)</span><br><span class="line">        textBgColor = typedArray.getColor(R.styleable.ClipAbleTextView_background_text_color, Color.BLACK)</span><br><span class="line">        textForeColor = typedArray.getColor(R.styleable.ClipAbleTextView_foreground_text_color, Color.BLACK)</span><br><span class="line">        mTextSize = typedArray.getDimension(R.styleable.ClipAbleTextView_textSize, 20f)</span><br><span class="line">        mContent = typedArray.getString(R.styleable.ClipAbleTextView_text_content) ?: &quot;&quot;</span><br><span class="line">        typedArray.recycle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">        val width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        val height = lineHeight + Utils.dp2px(context, 9)</span><br><span class="line">        setMeasuredDimension(width, height.toInt())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDraw(canvas: Canvas?) &#123;</span><br><span class="line">        drawBgText(canvas)</span><br><span class="line">        drawForeText(canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //绘制背景文字</span><br><span class="line">    private fun drawBgText(canvas: Canvas?) &#123;</span><br><span class="line">        canvas?.save()</span><br><span class="line">        canvas?.clipRect(measuredWidth * gradualFactor,0f,measuredWidth.toFloat(), measuredHeight.toFloat())</span><br><span class="line">        canvas?.drawText(mContent, 0f, lineHeight, textBgPaint)</span><br><span class="line">        canvas?.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //绘制渐变前景文字</span><br><span class="line">    private fun drawForeText(canvas: Canvas?) &#123;</span><br><span class="line">        canvas?.save()</span><br><span class="line">        canvas?.clipRect(0f,0f,measuredWidth * gradualFactor, measuredHeight.toFloat())</span><br><span class="line">        canvas?.drawText(mContent, 0f, lineHeight, textForePaint)</span><br><span class="line">        canvas?.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var textAnimator: ValueAnimator? = null</span><br><span class="line"></span><br><span class="line">    fun startGradualDraw(task: (()-&gt;Unit)?) &#123;</span><br><span class="line">        textAnimator = ValueAnimator.ofFloat(0f,1f).apply &#123;</span><br><span class="line">            addUpdateListener &#123;</span><br><span class="line">                gradualFactor = it.animatedValue as Float</span><br><span class="line">                invalidate()</span><br><span class="line">            &#125;</span><br><span class="line">            addListener(object : Animator.AnimatorListener&#123;</span><br><span class="line">                override fun onAnimationStart(p0: Animator?) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onAnimationEnd(p0: Animator?) &#123;</span><br><span class="line">                    task?.invoke()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onAnimationCancel(p0: Animator?) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onAnimationRepeat(p0: Animator?) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            duration = 7000</span><br><span class="line">        &#125;</span><br><span class="line">        textAnimator?.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun resetStatus() &#123;</span><br><span class="line">        gradualFactor = 0f</span><br><span class="line">        invalidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cancelAnimation() &#123;</span><br><span class="line">        textAnimator?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TAG = &quot;ClipAbleTextView&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class ClipTextViewContainer @JvmOverloads constructor(context: Context, attr: AttributeSet? = null, style: Int = 0)</span><br><span class="line">    : LinearLayout(context, attr, style) &#123;</span><br><span class="line"></span><br><span class="line">    private val clipChildContainer: MutableList&lt;ClipAbleTextView&gt; by lazy &#123;</span><br><span class="line">        mutableListOf&lt;ClipAbleTextView&gt;().apply &#123;</span><br><span class="line">            for (i in 0 until childCount) &#123;</span><br><span class="line">                this.add(getChildAt(i) as ClipAbleTextView)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private var index = 0</span><br><span class="line">    var animationEnded = false</span><br><span class="line">    init &#123;</span><br><span class="line">        orientation = VERTICAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun playText() &#123;</span><br><span class="line">        if (clipChildContainer.size == 0) return</span><br><span class="line">        clipChildContainer[index].startGradualDraw &#123;</span><br><span class="line">            index++</span><br><span class="line">            if (index &lt; childCount) &#123;</span><br><span class="line">                playText()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index = 0</span><br><span class="line">                animationEnded = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun reset() &#123;</span><br><span class="line">        clipChildContainer.forEach&#123;</span><br><span class="line">            it.resetStatus()</span><br><span class="line">        &#125;</span><br><span class="line">        animationEnded = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cancelAllAnimation() &#123;</span><br><span class="line">        clipChildContainer.forEach&#123;</span><br><span class="line">            it.cancelAnimation()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是比较关键性的代码了，纯自定义每行的View，只能实现文字渐变效果，不能换行，其实应该有实现方案，不过很麻烦，当时时间紧迫只能先这样了，然后外层容器也得自定义，控制每行的动画，其他的部分就很简单了，然后想说的是，上述的方案局限性超大，因为没有自动换行的功能，所以只能手动控制每一行的内容，特别呆，如果说仅仅是为了实现功能，都还只能说将就能用</p>
<h3 id="三-扩展系统的TextView实现文本渐变"><a href="#三-扩展系统的TextView实现文本渐变" class="headerlink" title="三.扩展系统的TextView实现文本渐变"></a>三.扩展系统的TextView实现文本渐变</h3><p>其实上面那个版本的缺点就是不能自动换行，说到自动换行，肯定首选系统的TextView，那么就得研究一下系统的TextView是如何实现每一行文本测量以及换行了</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F.png" style="zoom:30%;" />

<p>在onMeasure里面有一个<code>mLayout</code>的变量，上述截图前会通过<code>mLayout</code>拿到文本宽高的测量值，显然，第一次Measure的时候，它为空，所以进入<code>makeNewLayout</code>构造一个实例</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F2.png"></p>
<p>随后进入到<code>makeSingleLayout</code>方法中</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F3.png" style="zoom:33%;" />

<p>经过调试，发现<code>mLayout</code>会通过<code>StaticLayout</code>来生成，下面进入到它的构造函数里，会看到末尾有执行了<code>generate</code>方法，里面的流程稍微复杂，只需要找和行数相关的代码即可，随后定位到<code>out</code>函数的调用处</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F4.png" style="zoom:33%;" />

<p>看到这里其实也就差不多了，具体换行的逻辑貌似是通过<code>LineBreaker</code>来管理的，大致流程走通后，对于自定义一个TextView就很简单了，只需要通过<code>mLayout</code>来获取到行数，每一行的具体内容，都有相应的api供使用，剩余的工作就是绘制了，这里一笔带过</p>
<p>这个自定义的文本渐变效果，为了让功能更加健全，也是做了一些处理的</p>
<p>坑点：</p>
<ol>
<li>在实现动画的过程中，发现cancel结束后是会走end的，这种情况就需要额外的标志判断</li>
<li>在暂停动画，也就是取消动画后，再次开始需要在上次完成的进度基础上来设置动画时长，否则会变得很慢</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>这是首次发布的开源库，还是蛮有意思的吧，上述的原理也是一个探索的过程，下面通过添加依赖体验不一样的文本段落式渐变</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;io.github.wiwi289:GradualShowTextView:1.0.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/wiwi289/GradualShowTextView">仓库地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html" data-id="clchkr8pk00895oqhcelr23ov" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CoordinatorLayout原理分析以及自定义Behavior入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html" class="article-date">
  <time datetime="2022-01-26T05:22:05.000Z" itemprop="datePublished">2022-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面有整理过MD的用法，想要实现高级的效果，那还是得自定义，现在很多App都会使用到CoordinatorLayout来实现滚动关联的炫酷效果，至少体验感很好，下面会先从原理开始探讨，然后体验简单的自定义效果</p>
</blockquote>
<h3 id="二-CoordinatorLayout协调的原理分析"><a href="#二-CoordinatorLayout协调的原理分析" class="headerlink" title="二.CoordinatorLayout协调的原理分析"></a>二.CoordinatorLayout协调的原理分析</h3><p>CoordinatorLayout是建立在NestedScrolling机制的基础上的，但是NestedScroling仅限于父View和子View之间的交互，不能实现子View之间的交互效果，可以说CoordinatorLayout是兼容NestedScroling机制的</p>
<p>分析原理前，先过一遍View的生命周期</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/View%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" style="zoom:50%;" />

<ul>
<li>addView是添加到content区域</li>
<li>整个页面的层级是：activity-&gt;window-&gt;view</li>
<li>attach之后会触发makeVisible方法，setView之后会通过WMS开始绘制</li>
</ul>
<p>所以onAttachedToWindow是开始，那么CoordinatorLayout源码分析也是从此开始</p>
<ol>
<li><p>通过ViewTreeObserver添加绘制监听</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%861.png" style="zoom:33%;" /></li>
<li><p>开始绘制时，回调到<code>onPredraw</code>方法，进而调用<code>onChildViewsChanged</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">         final View child = mDependencySortedChildren.get(i);</span><br><span class="line">         final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">			//...省略部分代码</span><br><span class="line">         // Update any behavior-dependent views for the change</span><br><span class="line">         for (int j = i + 1; j &lt; childCount; j++) &#123;</span><br><span class="line">             final View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">             final LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">             final Behavior b = checkLp.getBehavior();</span><br><span class="line">   </span><br><span class="line">             if (b != null &amp;&amp; b.layoutDependsOn(this, checkChild, child)) &#123;</span><br><span class="line">                 if (type == EVENT_PRE_DRAW &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                     // If this is from a pre-draw and we have already been changed</span><br><span class="line">                     // from a nested scroll, skip the dispatch and reset the flag</span><br><span class="line">                     checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">   </span><br><span class="line">                 final boolean handled;</span><br><span class="line">                 switch (type) &#123;</span><br><span class="line">                     case EVENT_VIEW_REMOVED:</span><br><span class="line">                         // EVENT_VIEW_REMOVED means that we need to dispatch</span><br><span class="line">                         // onDependentViewRemoved() instead</span><br><span class="line">                         b.onDependentViewRemoved(this, checkChild, child);</span><br><span class="line">                         handled = true;</span><br><span class="line">                         break;</span><br><span class="line">                     default:</span><br><span class="line">                         // Otherwise we dispatch onDependentViewChanged()</span><br><span class="line">                         handled = b.onDependentViewChanged(this, checkChild, child);</span><br><span class="line">                         break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>省略了开头部分代码，此处的核心就是两层for循环，第二层是寻找依赖第一层for循环中定下的child，所以第一层是dependency(被依赖)，第二层是依赖方，如果存在依赖关系就通过behavior做更新逻辑的处理，switch里面有两种情况，一是dependency被移除时，二是默认情况下的视图更新(dependency改变时)</p>
</li>
<li><p>现在还有一个问题，mDependencySortedChildren是在什么时候初始化的，这个就得到onMeasure里面去看了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void prepareChildren() &#123;</span><br><span class="line">        mDependencySortedChildren.clear();</span><br><span class="line">        mChildDag.clear();</span><br><span class="line"></span><br><span class="line">        for (int i = 0, count = getChildCount(); i &lt; count; i++) &#123;</span><br><span class="line">            final View view = getChildAt(i);</span><br><span class="line"></span><br><span class="line">            final LayoutParams lp = getResolvedLayoutParams(view);</span><br><span class="line">            lp.findAnchorView(this, view);</span><br><span class="line"></span><br><span class="line">            mChildDag.addNode(view);</span><br><span class="line"></span><br><span class="line">            // Now iterate again over the other children, adding any dependencies to the graph</span><br><span class="line">            for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                if (j == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final View other = getChildAt(j);</span><br><span class="line">                if (lp.dependsOn(this, view, other)) &#123;</span><br><span class="line">                    if (!mChildDag.contains(other)) &#123;</span><br><span class="line">                        // Make sure that the other node is added</span><br><span class="line">                        mChildDag.addNode(other);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Now add the dependency to the graph</span><br><span class="line">                    mChildDag.addEdge(other, view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally add the sorted graph list to our list</span><br><span class="line">        mDependencySortedChildren.addAll(mChildDag.getSortedList());</span><br><span class="line">        // We also need to reverse the result since we want the start of the list to contain</span><br><span class="line">        // Views which have no dependencies, then dependent views after that</span><br><span class="line">        Collections.reverse(mDependencySortedChildren);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在onMeasure开始时调用<code>prepareChildren</code>方法进行收集CoordinatorLayout<strong>直接子View之间</strong>的依赖关系，看到这种依赖关系肯定是通过图来管理的，邻接矩阵是常用方式，这里深究的话，用的是dfs深度优先，再看就有点秃头了，这里主要是理解流程，可以看到，这里添加的顺序是(依赖方,dependency)的元组方式，显然我们得将它们反转，拿到dependency后再去遍历和它又依赖关系的View，这里还是很好理解的</p>
</li>
<li><p>有了2和3两步其实对它的原理也是蛮清晰的了，当dependency改变时一定会触发重绘，一旦重绘就会调用<code>onChildViewsChanged</code></p>
<p>去更新和它有依赖关系的View，而具体的更新操作，自然是在Behavior里面了，下面会进行一个小示例的展示来体现更新逻辑</p>
</li>
<li><p>此外，还得研究一下怎么监听到dependency被移除的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%862.png" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private class HierarchyChangeListener implements OnHierarchyChangeListener &#123;</span><br><span class="line">        HierarchyChangeListener() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChildViewAdded(View parent, View child) &#123;</span><br><span class="line">            if (mOnHierarchyChangeListener != null) &#123;</span><br><span class="line">                mOnHierarchyChangeListener.onChildViewAdded(parent, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChildViewRemoved(View parent, View child) &#123;</span><br><span class="line">            onChildViewsChanged(EVENT_VIEW_REMOVED);</span><br><span class="line"></span><br><span class="line">            if (mOnHierarchyChangeListener != null) &#123;</span><br><span class="line">                mOnHierarchyChangeListener.onChildViewRemoved(parent, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中设置了监听，所以视图被移除时可以感知到</p>
</li>
</ol>
<h3 id="三-自定义Behavoir入门实战"><a href="#三-自定义Behavoir入门实战" class="headerlink" title="三.自定义Behavoir入门实战"></a>三.自定义Behavoir入门实战</h3><blockquote>
<p>上面的分析大致缕清了CoordinatorLayout的工作原理，下面通过一个小例子来体验一下自定义Behavior实现的效果</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95behavoir%E7%A4%BA%E4%BE%8B.gif" style="zoom:50%;" />

<p>可以看到这个简单例子就很形象的展示了当dependency改变时，其他和它关联的子View的行为改变，这里代码比较简单，直接贴上对应的Behavior</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 颜色改变的behavior</span><br><span class="line">class ChangeColorBehavior @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;TextView&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    private val mArgbEvaluator = ArgbEvaluator()</span><br><span class="line"></span><br><span class="line">    override fun layoutDependsOn(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        return dependency is DefineDragView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;ResourceAsColor&quot;)</span><br><span class="line">    override fun onDependentViewChanged(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        val color = mArgbEvaluator.evaluate(dependency.y / parent.height, Color.WHITE, Color.BLACK) as Int</span><br><span class="line">        child.setTextColor(color)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 跟随dependency的behavior</span><br><span class="line">class ChildFollowBehavior@JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;TextView&gt;() &#123;</span><br><span class="line">    override fun layoutDependsOn(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        return dependency is DefineDragView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDependentViewChanged(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        child.y = (dependency.bottom + 50).toFloat()</span><br><span class="line">        child.x = dependency.x</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，这里必须重写的两个方法，<code>layoutDependsOn</code>用于筛选是否具有依赖关系，<code>onDependentViewChanged</code>用于做dependency改变的更新逻辑，其实在上述分析源码流程时就有看到这两个方法的身影</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>到这里，其实CoordinatorLayout的高级用法已经结束了，就是理解透它的协调流程，子View之间是如何联动的，下面进行两个问题的总结</p>
</blockquote>
<ol>
<li>使用behavior的View必须是CoordinatorLayout的直接子View，因为收集时并不是递归形式的查找</li>
<li>NestedScrolling机制的View不一定是直接子View，因为会递归查找，CoordinatorLayout实现了NestedScrollingParent系列接口</li>
</ol>
<p>后续会在项目实战中推出比较高级的自定义Behavior，这里只是一个入门，这里还有一个小坑，自定义的Behavior必须提供类似上述的构造函数，盲猜是需要第二个参数，因为在xml中使用，另外就是最好用类的全称，否则会抛异常</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/75f23d632ae87b1100e0a575f9f45c6dc6747510">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html" data-id="clchkr8ml000o5oqh5aftcpi9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NestedScrollView嵌套滑动原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html" class="article-date">
  <time datetime="2022-01-23T05:50:24.000Z" itemprop="datePublished">2022-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面回顾了View体系的事件分发机制，本文主要会介绍NestedScrollView的滑动嵌套原理，要知道事件分发的流程的是死的，怎么让事件的消费更加合理，才能更好的处理嵌套滑动的冲突，有一说一，NestedScrollView通过接口回调的方式做的很nice</p>
</blockquote>
<h3 id="二-使用传统的思路解决嵌套滑动"><a href="#二-使用传统的思路解决嵌套滑动" class="headerlink" title="二.使用传统的思路解决嵌套滑动"></a>二.使用传统的思路解决嵌套滑动</h3><blockquote>
<p>平常我们经常会用到纵向滑动内嵌套纵向滑动，外层的纵向滑动容器通常会选择NestedScrollView，那么现在先按照传统的思维来替代外层的NestedScrollView，观察可以得到什么样的效果</p>
</blockquote>
<p>这里采用外部拦截法，需要格外注意的是<code>super.onInterceptTouchEvent(ev)</code>默认情况下是不会拦截DOWN事件的，看源码也能看出这个拦截的条件是有多苛刻，所以直接return这个就好，不用手动return false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在滑动控制过程中，都有一个最小滑动距离，这里通过<code>ViewConfiguration.get(context).scaledTouchSlop</code>获取</p>
<p>为了模拟嵌套滑动效果，MOVE事件的拦截需要自定义规则，这里是以顶部的图片是否可见作为判断准则，具体代码下面会附上链接</p>
<p>基本规则：</p>
<ol>
<li>向上滑动时，如果顶部图片可见，则外层消费MOVE事件</li>
<li>向下滑动时，如果顶部图片不可见，则外层消费MOVE事件</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/5df6e3417781597964ffdced677dbf37dd96840d">传统嵌套滑动机制实现</a></p>
<p>下面看一下最终的效果如何</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E6%9C%BA%E5%88%B6show.gif" style="zoom:67%;" />

<p>可以看到，优先滑动的是外层，但是很明显，当外层不能再滑(顶部图片不可见)时，内层的RecyclerView不可滑动，显然不符合预期，不过根据原理确实也应该是这样的效果，外层容器一旦拿到了MOVE事件，就不可能再放给孩子了，因为前面的文章说到，只有内部拦截法，也就是孩子才可以决定时候放给父亲，只要父亲决定消费MOVE事件了，那么孩子肯定就消费不了了。</p>
<h3 id="三-分析NestedScroll机制"><a href="#三-分析NestedScroll机制" class="headerlink" title="三.分析NestedScroll机制"></a>三.分析NestedScroll机制</h3><blockquote>
<p>有了上面的铺垫，下面就来搞一搞NestedScroll，主要是通过接口回调的方式来灵活消费事件，值得强调的是NestedScroll机制没有改变事件分发的流程，只是在分发和消费流程中增加了接口回调</p>
</blockquote>
<h5 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h5><p>NestedScroll机制有两类接口：</p>
<ol>
<li><p>NestedScrollingParent</p>
<p>当可滑动的ViewGroup充当父View时实现该接口</p>
</li>
<li><p>NestedScrollingChild</p>
<p>当可滑动的ViewGroup充当子View时实现该接口</p>
</li>
</ol>
<p>先通过一张流程图来熟悉一下NestedScroll的基本工作大致流程</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B1.png" style="zoom:50%;" />

<p>上图还是比较清晰了，嵌套滑动流程都是从子View主动触发的，然后在分发和处理前去寻找和自己关联的可嵌套滑动的父View，简单说就是以父亲为尊，父View的回调也是很有特点的，都是on开头的方法回调</p>
<p>注：这里再强调一下事件消费的问题，在消费流程中会通过一个<code>consumed[2]</code>数组来保存消费的多少，<code>consumed[0]</code>表示水平方向消费的距离，<code>consumed[1]</code>表示竖直方向消费的距离，因为传递的是引用，所以父亲消费结束后，回到子View，子View再消费剩下的部分，如果子View没有完全消费完，那么还会再询问父亲要不要<strong>继续消费</strong>，分配到具体的阶段就是，预滚动和滚动阶段，会询问两次</p>
<h5 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h5><p>下面来具体分析一下上述两个接口中具体的方法，当然，随着后续的扩展还会有后缀2和3的对应接口，这里分析原始的接口</p>
<ol>
<li><p>NestedScrollingChild</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public interface NestedScrollingChild &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 启用或禁用嵌套滚动的方法，设置为true，并且当前界面的View的层次结构是支持嵌套滚动的</span><br><span class="line">    * (也就是需要NestedScrollingParent嵌套NestedScrollingChild)，才会触发嵌套滚动。</span><br><span class="line">    * 一般这个方法内部都是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    void setNestedScrollingEnabled(boolean enabled);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 判断当前View是否支持嵌套滑动。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    boolean isNestedScrollingEnabled();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 表示view开始滚动了,一般是在ACTION_DOWN中调用，如果返回true则表示父布局支持嵌套滚动。</span><br><span class="line">    * 一般也是直接代理给NestedScrollingChildHelper的同名方法即可。这个时候正常情况会触发Parent的onStartNestedScroll()方法</span><br><span class="line">    */</span><br><span class="line">    boolean startNestedScroll(@ScrollAxis int axes);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 一般是在事件结束比如ACTION_UP或者ACTION_CANCLE中调用,告诉父布局滚动结束。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    void stopNestedScroll();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 判断当前View是否有嵌套滑动的Parent。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    boolean hasNestedScrollingParent();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 在当前View消费滚动距离之后。通过调用该方法，把剩下的滚动距离传给父布局。如果当前没有发生嵌套滚动，或者不支持嵌套滚动，调用该方法也没啥用。</span><br><span class="line">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    * dxConsumed：被当前View消费了的水平方向滑动距离</span><br><span class="line">    * dyConsumed：被当前View消费了的垂直方向滑动距离</span><br><span class="line">    * dxUnconsumed：未被消费的水平滑动距离</span><br><span class="line">    * dyUnconsumed：未被消费的垂直滑动距离</span><br><span class="line">    * offsetInWindow：输出可选参数。如果不是null，该方法完成返回时，</span><br><span class="line">    * 会将该视图从该操作之前到该操作完成之后的本地视图坐标中的偏移量封装进该参数中，offsetInWindow[0]水平方向，offsetInWindow[1]垂直方向</span><br><span class="line">    * @return true：表示滚动事件分发成功,fasle: 分发失败</span><br><span class="line">    */</span><br><span class="line">    boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 在当前View消费滚动距离之前把滑动距离传给父布局。相当于把优先处理权交给Parent</span><br><span class="line">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可。</span><br><span class="line">	* dx：当前水平方向滑动的距离</span><br><span class="line">	* dy：当前垂直方向滑动的距离</span><br><span class="line">	* consumed：输出参数，会将Parent消费掉的距离封装进该参数consumed[0]代表水平方向，consumed[1]代表垂直方向</span><br><span class="line">	* @return true：代表Parent消费了滚动距离</span><br><span class="line">    */</span><br><span class="line">    boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,</span><br><span class="line">            @Nullable int[] offsetInWindow);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    *将惯性滑动的速度分发给Parent。内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">	* velocityX：表示水平滑动速度</span><br><span class="line">	* velocityY：垂直滑动速度</span><br><span class="line">	* consumed：true：表示当前View消费了滑动事件，否则传入false</span><br><span class="line">	* @return true：表示Parent处理了滑动事件</span><br><span class="line">	*/</span><br><span class="line">    boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 在当前View自己处理惯性滑动前，先将滑动事件分发给Parent,一般来说如果想自己处理惯性的滑动事件，</span><br><span class="line">    * 就不应该调用该方法给Parent处理。如果给了Parent并且返回true，那表示Parent已经处理了，自己就不应该再做处理。</span><br><span class="line">    * 返回false，代表Parent没有处理，但是不代表Parent后面就不用处理了</span><br><span class="line">    * @return true：表示Parent处理了滑动事件</span><br><span class="line">    */</span><br><span class="line">    boolean dispatchNestedPreFling(float velocityX, float velocityY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>NestedScrollingParent</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public interface NestedScrollingParent &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 当NestedScrollingChild调用方法startNestedScroll()时,会调用该方法。主要就是通过返回值告诉系统是否需要对后续的滚动进行处理</span><br><span class="line">    * child：该ViewParen的包含NestedScrollingChild的直接子View，如果只有一层嵌套，和target是同一个View</span><br><span class="line">    * target：本次嵌套滚动的NestedScrollingChild</span><br><span class="line">    * nestedScrollAxes：滚动方向</span><br><span class="line">    * @return </span><br><span class="line">    * true:表示我需要进行处理，后续的滚动会触发相应的回到</span><br><span class="line">    * false: 我不需要处理，后面也就不会进行相应的回调了</span><br><span class="line">    */</span><br><span class="line">    //child和target的区别，如果是嵌套两层如:Parent包含一个LinearLayout，LinearLayout里面才是NestedScrollingChild类型的View。这个时候，</span><br><span class="line">    //child指向LinearLayout，target指向NestedScrollingChild；如果Parent直接就包含了NestedScrollingChild，</span><br><span class="line">    //这个时候target和child都指向NestedScrollingChild</span><br><span class="line">    boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 如果onStartNestedScroll()方法返回的是true的话,那么紧接着就会调用该方法.它是让嵌套滚动在开始滚动之前,</span><br><span class="line">    * 让布局容器(viewGroup)或者它的父类执行一些配置的初始化的</span><br><span class="line">    */</span><br><span class="line">    void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 停止滚动了,当子view调用stopNestedScroll()时会调用该方法</span><br><span class="line">    */</span><br><span class="line">    void onStopNestedScroll(@NonNull View target);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 当子view调用dispatchNestedScroll()方法时,会调用该方法。也就是开始分发处理嵌套滑动了</span><br><span class="line">    * dxConsumed：已经被target消费掉的水平方向的滑动距离</span><br><span class="line">    * dyConsumed：已经被target消费掉的垂直方向的滑动距离</span><br><span class="line">    * dxUnconsumed：未被tagert消费掉的水平方向的滑动距离</span><br><span class="line">    * dyUnconsumed：未被tagert消费掉的垂直方向的滑动距离</span><br><span class="line">    */</span><br><span class="line">    void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 当子view调用dispatchNestedPreScroll()方法是,会调用该方法。也就是在NestedScrollingChild在处理滑动之前，</span><br><span class="line">    * 会先将机会给Parent处理。如果Parent想先消费部分滚动距离，将消费的距离放入consumed</span><br><span class="line">    * dx：水平滑动距离</span><br><span class="line">    * dy：处置滑动距离</span><br><span class="line">    * consumed：表示Parent要消费的滚动距离,consumed[0]和consumed[1]分别表示父布局在x和y方向上消费的距离.</span><br><span class="line">    */</span><br><span class="line">    void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 你可以捕获对内部NestedScrollingChild的fling事件</span><br><span class="line">    * velocityX：水平方向的滑动速度</span><br><span class="line">    * velocityY：垂直方向的滑动速度</span><br><span class="line">    * consumed：是否被child消费了</span><br><span class="line">    * @return</span><br><span class="line">    * true:则表示消费了滑动事件</span><br><span class="line">    */</span><br><span class="line">    boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 在惯性滑动距离处理之前，会调用该方法，同onNestedPreScroll()一样，也是给Parent优先处理的权利</span><br><span class="line">    * target：本次嵌套滚动的NestedScrollingChild</span><br><span class="line">    * velocityX：水平方向的滑动速度</span><br><span class="line">    * velocityY：垂直方向的滑动速度</span><br><span class="line">    * @return</span><br><span class="line">    * true：表示Parent要处理本次滑动事件，Child就不要处理了</span><br><span class="line">    */</span><br><span class="line">    boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 返回当前滑动的方向，一般直接通过NestedScrollingParentHelper.getNestedScrollAxes()返回即可</span><br><span class="line">    */</span><br><span class="line">    @ScrollAxis</span><br><span class="line">    int getNestedScrollAxes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①这里值得注意的是target和child的区别，target是可以嵌套滑动的子View，并不一定是直接子View，直接子View又称Child</p>
<p>②扩展的2接口新增了<code>type</code>参数，主要是为了区别事件类型：touch(触摸)和fling(惯性滑动)，3新增了cousumed引用</p>
</li>
</ol>
<p>上面提到，嵌套滑动的处理流程是从子View开始的，它会不断向上递归父View，寻找可嵌套滑动的父View，然后再自己消费，介绍了这么多，还是得回到如何使用这两个接口，下面通过一个小例子来展示效果</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8show.gif" style="zoom:50%;" />

<p>可以看到效果很明显，滚动的优先级以父View为尊，如果图片可见，并且向上滚动，则父View先消费，如果图片不可见，并且向下滚动，则父View先消费，剩余的才给子View消费，相比于传统的方式，传统的做不到把剩余的给子View消费，而这种接口回调的方式可以</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/57f7e45c3b5bba1c73d7c396e1a57ee1ad87c5ac">自定义嵌套滑动机制</a></p>
<p>其实代码实现也很少，很简单，接口中的方法都是交给各自对应的Helper类去管理，唯一要处理的就是预滚动和滚动中的逻辑</p>
<p>关于Helper，这里就不做介绍了，源码实在有点多，毕竟本文的关键在于看懂大致流程，并能使用，源码其实比较清晰，比如向上递归寻找可嵌套的父View就是交给Helper类来做的，另外就是，由于起点是子View，所以ChildHelper得源码会比较多一点，具体要调用哪些，可以参考我的代码链接，最后再附上NestedScroll机制的几张流程图，方便记忆</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B2.png" style="zoom:50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B3.png" style="zoom:30%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B4.png" style="zoom:25%;" />

<p>在文末还是留点东西，如果想更改开始的那个传统滑动嵌套机制又该如何实现，很明显内部的RecyclerView不就是NestedScrollingChild的实现类吗，所以只需要让外部的容器实现NestedScrollingParent就好了，方法什么的都和自定义的方式一模一样，附上代码链接</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/8ffefc87eecc398680673a3c4559d293b677c950">更改传统的嵌套滑动机制</a></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>有了事件分发的基础，其实理解NestedScroll很容易的，上面从传统-&gt;自定义-&gt;更改传统的链条展示了NestedScroll相关接口的用法，还是蛮有意思的，这为接下来的自定义Behavior打下基础</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html" data-id="clchkr8n0001l5oqh6lpz5vkr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APT-javapoet详细教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html" class="article-date">
  <time datetime="2022-01-16T13:52:04.000Z" itemprop="datePublished">2022-01-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍了注解处理器的相关概念以及工作流程，并且还搭建好了配置环境，本文将介绍通过javapoet来编写文件生成规则，从简到繁，当然也是借鉴官网的案例，途中可能有坑，小编先踩为敬</p>
</blockquote>
<h3 id="二-javapoet定义规则"><a href="#二-javapoet定义规则" class="headerlink" title="二.javapoet定义规则"></a>二.javapoet定义规则</h3><blockquote>
<p>前面也介绍了APT定义生成规则的两种方式，javapoet比较推崇，基本的写法流程也有提到，下面主要是定义一些比较高级的规则，比如生成带泛型的方法、类等等</p>
</blockquote>
<ol>
<li><p>定义控制流(for、if-else等等)</p>
<p>控制流在平常写代码中也极为常见，之前的小例子中仅仅为方法体添加了一行输出语句，当然了也可以添加定义变量的语句，后续会提到，这里先介绍控制流的规则写法</p>
<p>①通过<code>addCode</code>添加字符串形式的代码，有点类似于EventBus逐行手动写的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void addControlFlowByHardCode() &#123;</span><br><span class="line">        MethodSpec main = MethodSpec.methodBuilder(&quot;main2&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)</span><br><span class="line">                .returns(void.class)</span><br><span class="line">                .addCode(&quot;&quot;</span><br><span class="line">                        + &quot;int sum = 0;\n&quot;+</span><br><span class="line">                        &quot;for(int i = 0; i &lt; 20; i++) &#123; \n&quot; +</span><br><span class="line">                        &quot;        sum += i;\n&quot;+</span><br><span class="line">                                &quot;&#125;\n&quot;+</span><br><span class="line">                        &quot;&quot;)</span><br><span class="line">                .addStatement(&quot;$T.out.println(sum)&quot;,System.class)</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloApt2 = TypeSpec.classBuilder(&quot;HelloApt2&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(main)</span><br><span class="line">                .build();</span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt2)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述规则生成的类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt2 &#123;</span><br><span class="line">  public static void main2() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i &lt; 20; i++) &#123; </span><br><span class="line">            sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是通过硬编码的方式添加控制流，就等价于你一字不差的补充完整这个流程</p>
<p>②通过javapoet提供的流程控制api编写控制流程，这个的话感觉逻辑性更强一点，但肯定不如硬编码那么直观</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void addControlFlowByLogicAPI() &#123;</span><br><span class="line">        MethodSpec main = MethodSpec.methodBuilder(&quot;main3&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(int.class)</span><br><span class="line">                .addStatement(&quot;int sum = 0&quot;)</span><br><span class="line">                .beginControlFlow(&quot;for(int i = 0; i &lt; 20; i++)&quot;)</span><br><span class="line">                .addStatement(&quot;sum += i&quot;)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .addStatement(&quot;return sum&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt3&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(main)</span><br><span class="line">                .build();</span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt).build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt3 &#123;</span><br><span class="line">  public static int main3() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比硬编码和通过控制流的api两种方式创建控制流，明显发现只有硬编码才会末尾加**;**分号，并且还需要大括号标识代码块，而api帮我们自动添加，这样的好处是我们定义规则时只需要关心我们的逻辑是否可行，很方便，这里官网还提供了，传参的方式，传参也是有好处的，更具动态性，比如我们可以给一个注解添加start和end两个参数，那么我们在注解处理器中可以读取到这两个变量的值，然后根据客户端传入的start和end来创建一个范围的控制流，这个思路也是蛮好的，不过目前还没有想到应用场景</p>
<p>③生成if-else的控制流，按照官网的意思，if-else的控制可以无限生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void addIfElseFlowByLogicAPI() &#123;</span><br><span class="line">       MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;compareTimeStamp&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">               .addParameter(long.class,&quot;lastClickTime&quot;)</span><br><span class="line">               .addParameter(long.class, &quot;validLength&quot;)</span><br><span class="line">               .returns(boolean.class)</span><br><span class="line">               .addStatement(&quot;long now = $T.currentTimeMillis()&quot;,System.class)</span><br><span class="line">               .addStatement(&quot;long diff = now - lastClickTime&quot;)</span><br><span class="line">               .beginControlFlow(&quot;if ( diff &lt; validLength)&quot;)</span><br><span class="line">               .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;超级符合！！&quot;)</span><br><span class="line">               .addStatement(&quot;return true&quot;)</span><br><span class="line">               .nextControlFlow(&quot;else if (diff == validLength)&quot;)</span><br><span class="line">               .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;刚刚好，有点小失落。&quot;)</span><br><span class="line">               .addStatement(&quot;return true&quot;)</span><br><span class="line">               .nextControlFlow(&quot;else&quot;)</span><br><span class="line">               .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;超出范围，可以拜拜了。。&quot;)</span><br><span class="line">               .addStatement(&quot;return false&quot;)</span><br><span class="line">               .endControlFlow()</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       TypeSpec helloApt2 = TypeSpec.classBuilder(&quot;HelloApt4&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">               .addMethod(methodSpec)</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt2)</span><br><span class="line">               .build();</span><br><span class="line">       try &#123;</span><br><span class="line">           javaFile.writeTo(mFiler);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt4 &#123;</span><br><span class="line">  public static boolean compareTimeStamp(long lastClickTime, long validLength) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long diff = now - lastClickTime;</span><br><span class="line">    if ( diff &lt; validLength) &#123;</span><br><span class="line">      System.out.println(&quot;超级符合！！&quot;);</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else if (diff == validLength) &#123;</span><br><span class="line">      System.out.println(&quot;刚刚好，有点小失落。&quot;);</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;超出范围，可以拜拜了。。&quot;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次给生成的方法通过<code>addParamete</code>r添加了参数，有多个参数则多次添加即可，可以看到这种无限的控制流是通过<code>nextControlFlow</code>来控制的，最后记得<code>endControlFlow</code>就好</p>
<p>④生成try-catch控制流，类似于if-else，也可以无限流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void addTryCatchFlowByLogicAPI() &#123;</span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;exceptionCatch&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(void.class)</span><br><span class="line">                .beginControlFlow(&quot;try&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T($S)&quot;,ClassCastException.class,&quot;Failed&quot;)</span><br><span class="line">                .nextControlFlow(&quot;catch(ClassCastException e)&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T(e)&quot;,RuntimeException.class)</span><br><span class="line">                .nextControlFlow(&quot;catch(RuntimeException e)&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T($S)&quot;,ClassNotFoundException.class,&quot;class not found&quot;)</span><br><span class="line">                .nextControlFlow(&quot;catch(ClassNotFoundException e)&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T(e)&quot;,Exception.class)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt5&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt5 &#123;</span><br><span class="line">  public static void exceptionCatch() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      throw new ClassCastException(&quot;Failed&quot;);</span><br><span class="line">    &#125; catch(ClassCastException e) &#123;</span><br><span class="line">      throw new RuntimeException(e);</span><br><span class="line">    &#125; catch(RuntimeException e) &#123;</span><br><span class="line">      throw new ClassNotFoundException(&quot;class not found&quot;);</span><br><span class="line">    &#125; catch(ClassNotFoundException e) &#123;</span><br><span class="line">      throw new Exception(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码逻辑不一定正确，这里只是为了演示效果，从上面的例子可以看到，什么时候需要使用T变量来代替类，什么时候又可以直接在字符串中写入这个类，其实之所以要通过T变量来占位，是因为T变量的方式javapoet会自动帮我们导包，而不需要自己通过<code>addStatement</code>的方式来添加导包，所以如果前面有通过T变量的方式导入了，后续就可以直接通过字符串的形式写入，关于这个占位符下面也会介绍到</p>
</li>
<li><p>字符串拼接中的三个占位符</p>
<p>上面已经出现了一个占位符T，它是用来标识一个类型，那么还有L和S占位符等，下面一一介绍</p>
<p>①常量占位符</p>
<p>常量常见的有int、float、double等基本数据类型和字符串等</p>
<p>下面就先展示int类型的占位方式，其实基本类型的占位都一样，生成的结果或者使用差异，取决于你定义规则中字符串中的写入的类型是否是int或者其他类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void addLExpression(int from, int to) &#123;</span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;LExpression&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(int.class)</span><br><span class="line">                .addStatement(&quot;int sum = 0&quot;)</span><br><span class="line">                .beginControlFlow(&quot;for(int i = $L; i &lt; $L; i++)&quot;,from, to)</span><br><span class="line">                .addStatement(&quot;sum += i&quot;)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .addStatement(&quot;return sum&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt6&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt6 &#123;</span><br><span class="line">  public static int LExpression() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个的话，可以在APT处理过程中读取注解中携带的值，动态生成一个范围的控制流</p>
<p>②S和T占位符前面已经使用了很多次了，相信也不太陌生，S用于字符串变量的占位，T用于类型占位，关于T这里再稍微啰嗦一点吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br></pre></td></tr></table></figure>

<p>那么生成规则对应于</p>
<p><code>addStatement(&quot;$T obj = new $T&quot;, Object.class, Object.class)</code>或<code>addStatement(&quot;$T obj = new Object()&quot;, Object.class)</code></p>
<p>使用T占位类型的目的就是为了能够自动导入包，所以只要有一处导入，其他地方就不用再占位了</p>
<p>关于S的占位，小编试了试不用S占位，发现生成的文件依旧是正常的，所以貌似也可以，看官网的解释说是<strong>字符串变量</strong>才会使用到S占位，如果是写死的字符串的话，不需要占位</p>
<p>③方法名的占位符N，如果我们需要引用另外生成的方法来填充这行规则，就需要用到N来代替方法名占位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void addMethodNamePlaceCase() &#123;</span><br><span class="line">        MethodSpec method1 = MethodSpec.methodBuilder(&quot;getName&quot;)</span><br><span class="line">                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)</span><br><span class="line">                .returns(String.class)</span><br><span class="line">                .addStatement(&quot;return \&quot;cx\&quot;&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        ClassName testBean = ClassName.get(&quot;swu.cx.javaaptproject&quot;,&quot;TestBean&quot;);</span><br><span class="line">        MethodSpec method2 = MethodSpec.methodBuilder(&quot;generateObjWithName&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(testBean)</span><br><span class="line">                .addStatement(&quot;String name = $N()&quot;,method1)</span><br><span class="line">                .addStatement(&quot;return $T.createStringObj(name)&quot;,testBean)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt9&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method1)</span><br><span class="line">                .addMethod(method2)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .addStaticImport(testBean, &quot;createIntObj&quot;)</span><br><span class="line">                .addStaticImport(testBean, &quot;createStringObj&quot;)</span><br><span class="line">                .addStaticImport(Collection.class,&quot;*&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt9 &#123;</span><br><span class="line">  private static String getName() &#123;</span><br><span class="line">    return &quot;cx&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static TestBean generateObjWithName() &#123;</span><br><span class="line">    String name = getName();</span><br><span class="line">    return createStringObj(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关于类型的高级用法</p>
<p>在java中高级编程比较普遍，比如泛型的使用，那么，在生成文件的时候，如何生成带泛型的初始化表达式或者就是一个泛型的表达式，下面细细说来</p>
<p>①ClassName</p>
<p>ClassName比较重要，可以识别所有存在的类，就算是不存在的，也可以根据你提供的模板，自动导入生成</p>
<p>下面展示一下ArrayList的生成以及使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void addArrayListUseCase() &#123;</span><br><span class="line">        ClassName objType = ClassName.get(&quot;java.lang&quot;,&quot;Object&quot;);</span><br><span class="line">        ClassName list = ClassName.get(&quot;java.util&quot;, &quot;List&quot;);</span><br><span class="line">        ClassName arrayList = ClassName.get(&quot;java.util&quot;, &quot;ArrayList&quot;);</span><br><span class="line">        TypeName listOfObj = ParameterizedTypeName.get(list, objType);</span><br><span class="line"></span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;arrayListCase&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(listOfObj)</span><br><span class="line">                .addStatement(&quot;$T arrayList = new $T&lt;&gt;()&quot;, listOfObj, arrayList)</span><br><span class="line">                .addStatement(&quot;arrayList.add(new $T())&quot;, objType)</span><br><span class="line">                .addStatement(&quot;arrayList.add(new $T())&quot;, objType)</span><br><span class="line">                .addStatement(&quot;return arrayList&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt7&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt7 &#123;</span><br><span class="line">  public static List&lt;Object&gt; arrayListCase() &#123;</span><br><span class="line">    List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(new Object());</span><br><span class="line">    arrayList.add(new Object());</span><br><span class="line">    return arrayList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以对于泛型化的类型，需要获取到每一个具体的类型，然后通过<code>ParameterizedTypeName</code>进行组装</p>
<p>②导入静态代码块以及野蛮导入</p>
<p>对于静态方法，我们可以直接导入，然后生成的代码文件会变得简洁一点，同时import static也支持野蛮式导入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void addImportStaticCase() &#123;</span><br><span class="line">        ClassName testBean = ClassName.get(&quot;swu.cx.javaaptproject&quot;, &quot;TestBean&quot;);</span><br><span class="line">        ClassName list = ClassName.get(&quot;java.util&quot;, &quot;List&quot;);</span><br><span class="line">        ClassName arrayList = ClassName.get(&quot;java.util&quot;, &quot;ArrayList&quot;);</span><br><span class="line">        TypeName listOfTestBean = ParameterizedTypeName.get(list, testBean);</span><br><span class="line"></span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;importStaticCase&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(listOfTestBean)</span><br><span class="line">                .addStatement(&quot;$T list = new $T&lt;&gt;()&quot;,listOfTestBean, arrayList)</span><br><span class="line">                .addStatement(&quot;list.add($T.createIntObj(20))&quot;,testBean)</span><br><span class="line">                .addStatement(&quot;list.add($T.createStringObj(\&quot;hello testBean\&quot;))&quot;,testBean)</span><br><span class="line">                .addStatement(&quot;return list&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt8&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .addStaticImport(testBean, &quot;createIntObj&quot;)</span><br><span class="line">                .addStaticImport(testBean, &quot;createStringObj&quot;)</span><br><span class="line">                .addStaticImport(Collection.class,&quot;*&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt8 &#123;</span><br><span class="line">  public static List&lt;TestBean&gt; importStaticCase() &#123;</span><br><span class="line">    List&lt;TestBean&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(createIntObj(20));</span><br><span class="line">    list.add(createStringObj(&quot;hello testBean&quot;));</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现确实清爽了许多，import static是在生成JavaFile的时候使用，此外在定义规则的字符串中如果要<strong>标识一个字符串得用转义字符转义一下</strong></p>
</li>
<li><p>生成其他成员类型</p>
<p>只提到过方法的生成，以及添加参数等基本操作，下面补充其他类的成员结构</p>
<p>①生成构造函数</p>
<p>构造函数也是一个方法，只不过是通过<code>constructorBuilder</code>来生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void addConstructorCase() &#123;</span><br><span class="line">        MethodSpec cons = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addParameter(String.class, &quot;name&quot;)</span><br><span class="line">                .addStatement(&quot;this.$N = $N&quot;, &quot;name&quot;, &quot;name&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt10&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addField(String.class, &quot;name&quot;, Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(cons)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt10 &#123;</span><br><span class="line">  public final String name;</span><br><span class="line"></span><br><span class="line">  public HelloApt10(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里多了一个N的占位符，上面提到是给方法名做占位的，官网的解释说只要自身的一个东西需要自身的另一个东西来生成，就可以通过N进行占位处理，这里可以说是这种场景，其实构造函数也没啥特别的只是比构造普通函数替换了一个东西而已，然后添加参数，当然了这里还提前引入了Field(属性)的生成，下面会一笔带过</p>
<p>②给方法添加参数：使用<code>addParameter</code>添加，有两种添加方式，下面具体列出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void addParameterCase() &#123;</span><br><span class="line">        //方式一，通过ParameterSpec构造生成一个参数类型</span><br><span class="line">        ParameterSpec android = ParameterSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">                .addModifiers(Modifier.FINAL)</span><br><span class="line">                .build();</span><br><span class="line">        MethodSpec test = MethodSpec.methodBuilder(&quot;testAddParameter&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .addParameter(android)</span><br><span class="line">                .addParameter(int.class, &quot;age&quot;, Modifier.FINAL) //方式二</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt11&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(test)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt11 &#123;</span><br><span class="line">  public static void testAddParameter(final String android, final int age) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是比较简单的，一般来说，方式二就可以了，轻便</p>
<p>③添加Field(成员属性)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//添加属性</span><br><span class="line">   private void addFieldCase() &#123;</span><br><span class="line">       //方式一 通过FieldSpec构造</span><br><span class="line">       FieldSpec android = FieldSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt12&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">               .addField(android)</span><br><span class="line">               .addField(int.class, &quot;age&quot;, Modifier.PRIVATE, Modifier.FINAL) //方式二</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">               .build();</span><br><span class="line">       try &#123;</span><br><span class="line">           javaFile.writeTo(mFiler);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class HelloApt12 &#123;</span><br><span class="line">  public final String android;</span><br><span class="line"></span><br><span class="line">  private final int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和方法添加参数类似，通常使用第二种方式</p>
<p>当然了，第一种通过Build的方式构造是可以添加默认值的，通过<code>initializer</code>方法添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">        .initializer(&quot;\&quot;hello\&quot;&quot;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>还可以通过前面提到的S和L两个占位符进行模式拼接</p>
</li>
<li><p>生成接口</p>
<p>单独把生成接口列出来，因为要做开原框架，接口的生成是重点</p>
<p>生成接口也没啥特别的，就是将类的生成稍微替换一下就好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void addInterfaceCase() &#123;</span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;abstractFun&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">                .returns(void.class)</span><br><span class="line">                .addParameter(int.class, &quot;age&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec interfaceSpec = TypeSpec.interfaceBuilder(&quot;InterfaceTest&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, interfaceSpec)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceTest &#123;</span><br><span class="line">  void abstractFun(int age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>高级用法的补充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//高级用法补充</span><br><span class="line">  private void specialUse() &#123;</span><br><span class="line">   </span><br><span class="line">      MethodSpec methodImpl = MethodSpec.methodBuilder(&quot;abstractFun&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addAnnotation(Override.class)</span><br><span class="line">              .addParameter(int.class, &quot;age&quot;)</span><br><span class="line">              .addStatement(&quot;$T.out.println(\&quot;method implementation\&quot;)&quot;, System.class)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      //添加泛型</span><br><span class="line">      TypeVariableName typeVariableName = TypeVariableName.get(&quot;T&quot;);</span><br><span class="line">      //添加泛型方法</span><br><span class="line">      MethodSpec typeMethod = MethodSpec.methodBuilder(&quot;typeMethodCase&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .addParameter(typeVariableName, &quot;t&quot;)</span><br><span class="line">              .returns(typeVariableName)</span><br><span class="line">              .addStatement(&quot;return t&quot;)</span><br><span class="line">              .build();</span><br><span class="line">      //添加泛型约束型方法 extends 指定该泛型属于什么类型</span><br><span class="line">      TypeVariableName typeConstraint = TypeVariableName.get(&quot;U&quot;,ClassName.get(&quot;java.lang&quot;,&quot;Number&quot;));</span><br><span class="line">      MethodSpec typeConstraintMethod = MethodSpec.methodBuilder(&quot;typeConstraintMethod&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addTypeVariable(typeConstraint)</span><br><span class="line">              .build();</span><br><span class="line">      // 添加通配符 上限约束型 参数</span><br><span class="line">      TypeName typeExtends = WildcardTypeName.subtypeOf(ClassName.get(&quot;java.lang&quot;,&quot;Number&quot;));</span><br><span class="line">      TypeName parameterWithExtends = ParameterizedTypeName.get(ClassName.get(&quot;java.util&quot;,&quot;List&quot;),typeExtends);</span><br><span class="line">      MethodSpec typeConstraintMethod1 = MethodSpec.methodBuilder(&quot;typeConstraintMethod1&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addParameter(parameterWithExtends, &quot;list&quot;)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      //添加通配符 下限约束型 参数</span><br><span class="line">      TypeName typeExtends2 = WildcardTypeName.supertypeOf(ClassName.get(&quot;java.lang&quot;,&quot;Number&quot;));</span><br><span class="line">      TypeName parameterWithExtends2 = ParameterizedTypeName.get(ClassName.get(&quot;java.util&quot;,&quot;List&quot;),typeExtends2);</span><br><span class="line">      MethodSpec typeConstraintMethod2 = MethodSpec.methodBuilder(&quot;typeConstraintMethod2&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addParameter(parameterWithExtends2, &quot;list&quot;)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      TypeSpec implSpec = TypeSpec.classBuilder(&quot;InterfaceImpl&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .addSuperinterface(ClassName.get(PACKAGE_NAME,&quot;InterfaceTest&quot;)) //添加接口类型</span><br><span class="line">              .addTypeVariable(typeVariableName) //给类增加泛型，接口同理</span><br><span class="line">              .addMethod(methodImpl)</span><br><span class="line">              .addMethod(typeMethod)</span><br><span class="line">              .addMethod(typeConstraintMethod)</span><br><span class="line">              .addMethod(typeConstraintMethod1)</span><br><span class="line">              .addMethod(typeConstraintMethod2)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, implSpec)</span><br><span class="line">              .build();</span><br><span class="line">      try &#123;</span><br><span class="line">          javaFile.writeTo(mFiler);</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InterfaceImpl&lt;T&gt; implements InterfaceTest &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void abstractFun(int age) &#123;</span><br><span class="line">    System.out.println(&quot;method implementation&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T typeMethodCase(T t) &#123;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public &lt;U extends Number&gt; void typeConstraintMethod() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void typeConstraintMethod1(List&lt;? extends Number&gt; list) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void typeConstraintMethod2(List&lt;? super Number&gt; list) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高级用法还有一些，这里写到快窒息了，剩余的也不难，把上述的吃透，剩余的就信手拈来好吧，另外也推荐上<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25926518/purpose-of-using-super-t-or-t-super-someclass-in-generics">stackoverflow</a>上查看javapoet的高级用法，有很多朋友提过问的，站在前人的肩膀上看问题，只能说很爽</p>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>这篇长文写到这里算是告一段落，官网还剩下一点点没有补充，可以自行前往查看，不过都是平时很少用到的了，其实发现，很难的是高级写法，比如涉及到泛型，还是多练为主吧</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html" data-id="clchkr8ma00095oqhau1p4hwc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-APT-Java搭建环境以及入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/APT-Java%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8.html" class="article-date">
  <time datetime="2022-01-15T03:36:17.000Z" itemprop="datePublished">2022-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/APT-Java%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8.html">APT-Java搭建环境以及入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>APT的全称是<strong>Annotation Processing Tool</strong>，也就是注解处理器，很多开源框架都会使用，简单说它的作用就是在编译期根据模板生成我们所需要的类，用来写框架很合适，很具动态性，下面会从基础开始到能够写出一些我们想要的东西</p>
</blockquote>
<h3 id="二-注解处理器基本介绍"><a href="#二-注解处理器基本介绍" class="headerlink" title="二.注解处理器基本介绍"></a>二.注解处理器基本介绍</h3><blockquote>
<p>所谓注解处理器，顾名思义，需要注解，在编译期，注解处理会扫描源文件，找出我们指定的Annotation，根据注解以及我们提供的<strong>规则</strong>生成代码</p>
</blockquote>
<p>所以比较重要的就是规则了，下面进行一个简单介绍</p>
<p>先从APT的写法开始，要知道Java是面向对象的语言，所以我们写java的思路是：创建文件-&gt;创建类-&gt;创建方法</p>
<p>那么APT生成类的方式也类似，不过这里有两种方式(个人理解，为了方便叙述，暂且这样)：</p>
<ol>
<li><p>面向过程：通过文件流自顶向下生成类，也就是从import导包开始写，比如EventBus</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/APT1.png" style="zoom: 33%;" />

<p>这样写的好处是可读性好，一目了然功能是什么，但是容易出错，一个标点符号写错都不行</p>
</li>
<li><p>面向对象</p>
<p>这里所谓的面向对象和Java的写法是倒过来的，创建方法-&gt;创建类-&gt;创建文件，不过也倒挺符合封装的思想，实现这种写法，必须使用<a target="_blank" rel="noopener" href="https://github.com/square/javapoet">javapoet</a>这个库，下面也主要整理该库的使用方式</p>
</li>
</ol>
<p>既然通常选择面向对象的写法，那么自然需要清楚结构思路，先剖析一下java文件的结构</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/APT2.png" style="zoom:47%;" />

<ul>
<li>PackageElement：表示一个包程序元素。提供对有关包及其成员的信息的访问</li>
<li>ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序(静态或实例)</li>
<li>TypeElement：表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。</li>
<li>VariableElement：表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</li>
</ul>
<p>我们在写APT相关时，很重要的一个东西就是Element，也就是注解作用的元素(接口、类、属性、方法等)，系统提供了如下API供我们使用</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getEnclosedElements()</td>
<td align="center">返回该元素直接包含的子元素</td>
</tr>
<tr>
<td align="center">getEnclosingElement()</td>
<td align="center">返回包含该element的父element，与上一个方法相反</td>
</tr>
<tr>
<td align="center">getKind()</td>
<td align="center">返回element的类型，判断是哪种element</td>
</tr>
<tr>
<td align="center">getModifiers()</td>
<td align="center">获取修饰关键字,入public static final等关键字</td>
</tr>
<tr>
<td align="center">getSimpleName()</td>
<td align="center">获取名字，不带包名</td>
</tr>
<tr>
<td align="center">getQualifiedName()</td>
<td align="center">获取全名，如果是类的话，包含完整的包名路径</td>
</tr>
<tr>
<td align="center">getParameters()</td>
<td align="center">获取方法的参数元素，每个元素是一个VariableElement</td>
</tr>
<tr>
<td align="center">getReturnType()</td>
<td align="center">获取方法元素的返回值</td>
</tr>
<tr>
<td align="center">getConstantValue()</td>
<td align="center">如果属性变量被final修饰，则可以使用该方法获取它的值</td>
</tr>
</tbody></table>
<p>下面再介绍一下javapoet为我们提供的方法</p>
<table>
<thead>
<tr>
<th align="center">工具类</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MethodSpec</td>
<td align="center">代表一个构造函数或方法声明</td>
</tr>
<tr>
<td align="center">TypeSpec</td>
<td align="center">代表一个类，接口，或者枚举声明</td>
</tr>
<tr>
<td align="center">FieldSpec</td>
<td align="center">代表一个成员变量，一个字段声明</td>
</tr>
<tr>
<td align="center">JavaFile</td>
<td align="center">包含一个顶级类的Java文件</td>
</tr>
<tr>
<td align="center">ParameterSpec</td>
<td align="center">用来创建参数</td>
</tr>
<tr>
<td align="center">AnnotationSpec</td>
<td align="center">用来创建注解</td>
</tr>
<tr>
<td align="center">ClassName</td>
<td align="center">用来包装一个类</td>
</tr>
<tr>
<td align="center">TypeName</td>
<td align="center">类型，如在添加返回值类型是使用 TypeName.VOID</td>
</tr>
</tbody></table>
<p>比如MethodSpec，用来生成一个方法，后续会介绍它们的基本使用</p>
<h3 id="三-APT的使用搭建"><a href="#三-APT的使用搭建" class="headerlink" title="三.APT的使用搭建"></a>三.APT的使用搭建</h3><p>上面介绍了一堆APT相关概念和工具，这里就先进入正题，写任何一个东西都需要搭建一个环境，所以先搭建APT的环境，能够看到APT在工作，以及对应的产物</p>
<p>APT通常有如下三个模块：</p>
<ul>
<li>compiler：存放自定义注解处理器，代码编译生成规则在这里声明-&gt;<strong>java模块</strong></li>
<li>annotations：存放注解-&gt;<strong>java模块</strong></li>
<li>apt_api ：暴露给用户的api，我们生成的代码怎么调用，需要提供api支持-&gt;<strong>android 模块</strong></li>
</ul>
<ol>
<li><p>创建好上述三个模块后，建立相互间的依赖关系</p>
<p>compiler模块需要根据注解进行处理，所以需要依赖annotations模块</p>
<p>app和apt_api模块需要使用定义的注解并且通过注解处理器生成一些类，所以都需要依赖annotations模块，和通过annotationProcessor启用compiler中的注解处理器</p>
<p>app模块还需单独依赖apt_api，因为需要使用apt_api提供的一些api，这也是做SDK开发需要提供的api</p>
</li>
<li><p>自定义注解处理器以及相关配置</p>
<p>有了上述依赖，还得让compiler模块真正工作起来，那么就需要自定义注解处理器Processor</p>
<p>自定义注解处理器就是继承AbstractProcessor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须重写的是<code>process</code>方法，这个里面就是用来自定义生成类的规则，关于返回值</p>
<p>false : 表示没有出来完</p>
<p>true : 表示已经处理完了</p>
<p>但该方法无论如何都要执行两遍，第二次使用来检查是否有生成匹配规则的类文件</p>
<p>下面还得让编译期识别到我们自定义的注解处理器还有相关配置</p>
<ul>
<li><p>@SupportedAnnotationTypes：配置该注解处理器支持的注解</p>
</li>
<li><p>@SupportedSourceVersion：支持的版本号，通常是SourceVersion.RELEASE_7</p>
</li>
<li><p>@SupportedOptions：接收外部传入的参数</p>
</li>
<li><p>@AutoService(Process.class)：标识该注解处理器能够被编译期识别，需要额外的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</span><br><span class="line">annotationProcessor &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</span><br></pre></td></tr></table></figure>

<p>使用AutoService就不用通过javax.annotation.processing.Processor文件注册注解处理器，很方便</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;swu.cx.annotations.Test&quot;&#125;)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">@SupportedOptions(MyProcessor.PARAMS_CONFIG)</span><br><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    public static final String PARAMS_CONFIG = &quot;MODULE_NAME&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上工作处理完毕后，还需在MyProcessor的init方法中准备一些工具类，用于在写规则的时候使用</p>
<ul>
<li><p>Messager：日志打印工具</p>
<p>提供了ERROR、WARNING、MANDATORY_WARNING、NOTE OTHER五个级别的日志信息，常用的就是ERROR和NOTE了，不过使用ERROR会直接导致编译失败，强制性停止编译</p>
</li>
<li><p>Filer：文件生成器</p>
</li>
<li><p>Types：类信息工具类</p>
</li>
<li><p>Elements：节点工具类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">      super.init(processingEnv);</span><br><span class="line">      mElementUtils = processingEnv.getElementUtils();</span><br><span class="line">      mTypeUtils = processingEnv.getTypeUtils();</span><br><span class="line">      mFiler = processingEnv.getFiler();</span><br><span class="line">      mMessager = processingEnv.getMessager();</span><br><span class="line">      mModuleName = processingEnv.getOptions().get(PARAMS_CONFIG);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四-开始定义规则生成类文件"><a href="#四-开始定义规则生成类文件" class="headerlink" title="四.开始定义规则生成类文件"></a>四.开始定义规则生成类文件</h3><blockquote>
<p>有了以上的铺垫，现在就可以在process方法中定义生成文件的规则了，前面有说到使用javapoet生成文件，所以还需在compiler模块添加如下依赖</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com.squareup:javapoet:1.11.1&#x27;</span><br></pre></td></tr></table></figure>

<p>在开始生成文件前，可以通过增加打印信息来判断我们的注解处理器是否在工作，并且还可以输出处理过程中的一些重要信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">      mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;=======&gt; process处理ing&quot;);</span><br><span class="line">      //构造main方法</span><br><span class="line">      MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC,Modifier.STATIC)</span><br><span class="line">              .returns(TypeName.VOID)</span><br><span class="line">              .addParameter(String[].class, &quot;args&quot;)</span><br><span class="line">              .addStatement(&quot;$T.out.println($S)&quot;,System.class,&quot;hello apt java!&quot;)</span><br><span class="line">              .build();</span><br><span class="line">      //构造类</span><br><span class="line">      TypeSpec helloWord = TypeSpec.classBuilder(&quot;HelloApt&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC,Modifier.FINAL)</span><br><span class="line">              .addMethod(methodSpec)</span><br><span class="line">              .build();</span><br><span class="line">      //指定包路径</span><br><span class="line">      JavaFile javaFile = JavaFile.builder(&quot;swu.cx.HelloApt&quot;, helloWord)</span><br><span class="line">              .build();</span><br><span class="line">      //生成文件</span><br><span class="line">      try &#123;</span><br><span class="line">          javaFile.writeTo(mFiler);</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了javapoet官网一个简单的小例子，先体验一下后续后补充完整的使用方法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/APT3.png" style="zoom:25%;" />

<p>可以看到生成了对应的文件，以及输出的打印信息</p>
<p>这里有一个很大的坑点，就是在app模块或其他应用了注解处理器的模块必须使用了注解才能触发注解处理器，因为顾名思义，注解处理器是根据注解才工作的，如果都没有使用注解，那么默认是不工作的，这个超坑，另外就是配置注解处理器的时候要格外仔细，按照上面的配置方式是一定可以跑起来的，后续也会补充Kotlin方式的配置</p>
<p>此外这里抛出的FilerException就是二次调用process方法的结果，这个无关紧要，可以忽略，因为第二遍的检查机制</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>此篇为入门篇，先把环境搭好，后续的工作就是通过javapoet定义规则，规则有简单的，也有复杂的，想上述的例子就是格外简单的，后续会从简到繁定义规则，也方便后续查阅</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/APT-Java%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8.html" data-id="clchkr8m200035oqh743f8fzr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-发布开源库到MavenCentral" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0MavenCentral.html" class="article-date">
  <time datetime="2022-01-09T11:53:20.000Z" itemprop="datePublished">2022-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0MavenCentral.html">发布开源库到MavenCentral详细教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>本文将介绍发布自己的开源库到MavenCentral，之前是发布到JCenter，但JCenter已经停止发布开源库了，所以刚开始我去bintray的官网还找了半天的注册入口，蛮坑的，网页被魔改了，下面开始MavenCentral发布的流程</p>
</blockquote>
<h3 id="二-准备流程"><a href="#二-准备流程" class="headerlink" title="二.准备流程"></a>二.准备流程</h3><p>本文参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/guolin_blog/article/details/119706565">郭婶的发布流程博客</a>，只是郭婶的发布方式是通过自己购买的域名做路径，所以如果想使用io.github的形式免费发布开源库，还得参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FVR6_zMp5DxO5N4ptVuA6g">io.github形式</a>，好巧不巧，这篇文章是windows版本的，并且使用的是官方的maven-publish插件进行发布，会额外增加一些代码，郭婶的发布方式比较简洁，下面结合二者的优势吧，开始踩坑之旅。。</p>
<ol>
<li><p>在<a target="_blank" rel="noopener" href="https://issues.sonatype.org/secure/Dashboard.jspa">Sonatype平台</a>注册账号并创建工单</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%901.png"></p>
<p>注册账号，填密码的时候不要选择官方给你推荐什么Google浏览器会记住密码的推荐，使用自己的密码即可，因为后面在发布的时候需要使用到你的Sonatype账号和密码，另外，登录成功后，它会自动弹窗引导你创建一个issue，直接cancel吧，挺烦人的，然后就进入到上图所示的界面，点击create创建即可</p>
</li>
<li><p>填写工单信息，下面就展示一下我填写的信息吧</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%902.png" style="zoom:40%;" />

<blockquote>
<p>注：Group Id很重要，既然选择了io.github的形式，并且为了方便工作人员审查，所以最好是你的github账号倒过来，但不是com.github.用户名，我这里是io.github.wiwi289，并且在后面发布的时候也需要使用这个Group Id</p>
</blockquote>
</li>
<li><p>再提交工单后，一会儿就会在下面出现来自工作人员的评论</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%903.png" style="zoom:60%;" />

<p>我是周末提交的，但回的还是很快，不像郭婶说的那般非工作日很慢，很迷，第一个评论就是说要求我们在github上创建一个以<strong>工单号</strong>命名的空仓库，直接复制这个工单号去创建即可，比如这里是<code>OSSRH-77062</code>    </p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%904.png" style="zoom:40%;" />                                                            

<p>然后就可以如上图一样回复工作人员已经创建成功，等待检查</p>
</li>
<li><p>等待工作人员检查完毕，会有相应的回复，这里就不贴结果了，看到回复就表明我们的Maven仓库已经就可以使用了，下面要做的就是发布开源库到Maven仓库</p>
</li>
<li><p>创建秘钥，这里展示mac的方式，windows可以参考上面提到的windwos版本的方式，不过个人觉得只参考秘钥的创建即可</p>
<p><code>brew install gpg</code>，mac使用HomeBrew安装，这里也感觉蛮坑的吧，输入命令后会像下图一般，进入等待更新，一直等着，所以需要ctrl+c停止，否则真不知道要等到什么时候</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%905.png"></p>
</li>
<li><p>安装成功后，输入以下命令生成秘钥，并设置秘钥密码，这两个都很重要</p>
<p><code>gpg --full-generate-key</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%906.png" style="zoom:50%;" />

<p>弹出第一个信息很重要，一定要选择RSA加密的，前面的信息只有这一步需要注意，其他的回车即可，然后确认，并退出，退出的时候会让你设置密码，之后就可以看到生成的秘钥ID了</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%907.png"></p>
<p>可以看到这里生成的类型是RSA，这点很重要，否则在后面发布的时候会报加密异常，就是因为没有使用RSA加密方式</p>
</li>
<li><p>上传秘钥到GPG服务器，秘钥ID很长，但只需要最后8位，这点超重要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp://pgp.mit.edu --send-keys DC0B6B98</span><br></pre></td></tr></table></figure>

<p>这里可能会上传不成功，超坑，需要下面的命令进行检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver hkp://pool.sks-keyservers.net --search-keys DC0B6B98</span><br></pre></td></tr></table></figure>

<p>如果显示No Name，则上传不成功，不用再试了，感觉不会成功的，哭了，这时候就通过下面的网址手动上传秘钥</p>
<p><a target="_blank" rel="noopener" href="https://keys.openpgp.org/upload/">https://keys.openpgp.org/upload/</a></p>
<p>手动上传前还需要导出我们的秘钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --export 1111111@qq.com &gt; ~/Downloads/my_key.pub</span><br></pre></td></tr></table></figure>

<p>然后再通过网站手动上传，网站会提示上传成功的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%908.png" style="zoom:50%;" />

<p>上传成功后，通过终端命令查询还是查不到(我的是这样)，不过网站显示成功即可，后续的验证就不会有问题</p>
</li>
<li><p>最后一步是生成私钥文件，一行命令搞定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --export-secret-keys  -o 文件路径/secring.gpg</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三-发布流程"><a href="#三-发布流程" class="headerlink" title="三.发布流程"></a>三.发布流程</h3><blockquote>
<p>经过以上步骤的折磨，下面就稍微轻松很多了，唯一需要仔细的是AS中文件的信息填写</p>
</blockquote>
<p>发布的方式这里还是推崇使用<a target="_blank" rel="noopener" href="https://github.com/vanniktech/gradle-maven-publish-plugin">gradle-maven-publish-plugin</a>插件发布，只能说步骤少，效率高，超爽</p>
<p>使用方式也很简单、亲民</p>
<ol>
<li><p>在你要开源的库的所在模块的build.gradle中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.vanniktech:gradle-maven-publish-plugin:0.17.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//plugin ids放在这里</span><br><span class="line">allprojects &#123;</span><br><span class="line">    plugins.withId(&quot;com.vanniktech.maven.publish&quot;) &#123;</span><br><span class="line">        mavenPublish &#123;</span><br><span class="line">            sonatypeHost = &quot;S01&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &quot;com.vanniktech.maven.publish&quot;</span><br></pre></td></tr></table></figure>

<p>这里有一个坑点，buildscript{}闭合必须放在文件顶部，即所有插件的前面，否则报错，详情可以前往<a target="_blank" rel="noopener" href="https://github.com/wiwi289/GradualShowTextView/">我的github项目(本次开源对象)查看</a></p>
</li>
<li><p>在项目根目录下的gradle.properties文件增加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GROUP=io.github.wiwi289</span><br><span class="line">POM_ARTIFACT_ID=GradualShowTextView</span><br><span class="line">VERSION_NAME=1.0.0</span><br><span class="line"></span><br><span class="line">POM_NAME=GradualShowTextView</span><br><span class="line">POM_DESCRIPTION=A convenient text gradient TextView</span><br><span class="line">POM_INCEPTION_YEAR=2021</span><br><span class="line">POM_URL=https://github.com/wiwi289/GradualShowTextView/</span><br><span class="line"></span><br><span class="line">POM_LICENSE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">POM_LICENSE_URL=https://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">POM_LICENSE_DIST=repo</span><br><span class="line"></span><br><span class="line">POM_SCM_URL=https://github.com/wiwi289/GradualShowTextView/</span><br><span class="line">POM_SCM_CONNECTION=scm:git:git://github.com/wiwi289/GradualShowTextView.git</span><br><span class="line">POM_SCM_DEV_CONNECTION=scm:git:ssh://github.com/wiwi289/GradualShowTextView.git</span><br><span class="line"></span><br><span class="line">POM_DEVELOPER_ID=chenxiong</span><br><span class="line">POM_DEVELOPER_NAME=Chen Xiong</span><br><span class="line">POM_DEVELOPER_URL=https://github.com/wiwi289/</span><br><span class="line"></span><br><span class="line">signing.keyId=密钥ID的后8位(我的是DC0B6B98)</span><br><span class="line">signing.password=密钥密码(详情见上面的准备流程，生成秘钥时，系统让你设置的密码)</span><br><span class="line">signing.secretKeyRingFile=私钥文件路径(导出的路径)</span><br><span class="line"></span><br><span class="line">mavenCentralUsername=Sonatype账号</span><br><span class="line">mavenCentralPassword=Sonatype密码</span><br></pre></td></tr></table></figure>

<p>上面的前三项决定着你的开源库的包路径是什么，比如这里，我的开源包路径就变成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.github.wiwi289:GradualShowTextView:1.0.0</span><br></pre></td></tr></table></figure>

<p>其他的内容其实在准备阶段也有强调，可以进行回顾，特别注意的是这个gradle.properties文件有太多隐私信息，需要排除在版本控制外</p>
</li>
<li><p>最后就可以点击AS右边的Gradle下的publish进行发布了，当然了我发了好几次也没发出去，不过踩过的坑点都在上面了，如果按照我的格式来发布的话，应该能直接起飞</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%909.png" style="zoom:33%;" />

<p>成功的话，就显示Build Successfully，否则就看抛什么异常吧，仔细检查检查，一般都没问题</p>
</li>
<li><p>经过以上的发布步骤，虽然是发布出去了，但是还没有发布到MavenCentral中去，只是发送到了<a target="_blank" rel="noopener" href="https://s01.oss.sonatype.org/">https://s01.oss.sonatype.org/</a>这个仓库中，直接登录，账号和密码是前面申请的Sonatype账号，登录成功后点击左边的<strong>Staging Repositories</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9010.png" style="zoom:50%;" />

<p>可看到现在的状态是open的，就算你勾选了这个仓库，上面的Release按钮不可点击，所以我们需要勾选它，点击上面的close</p>
<p>，会有一个弹窗，点击Confirm即可，然后就等待它的校验流程，可以选中它，看到下面的Activity窗口，会展示校验流程，并且还可以查看失败日志，这个很重要，如果后面刷新发现状态还是open，说明没有关闭成功，这时候就得查日志，只有状态变成closed，Release按钮才可点击</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9011.png"></p>
<p>我之前就是因为秘钥上传不成功，才导致关闭失败，查日志才发现，坑炸了</p>
</li>
<li><p>如果后面点击Refresh，发现已关闭，那么就可点击Release进行发布了，会有弹窗，直接点Confirm即可，然后这个仓库就会消失，容易想到，消失的它正在被送往MavenCentral，所以过一会儿，你之前创建的工单下面会多一个评论</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9012.png"></p>
<p>好了，看到这个消息，总算可以松口气了，等待同步到MavenCentral即可，几个小时后，你就可以使用你发布的开源了，使用方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;io.github.wiwi289:GradualShowTextView:1.0.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步成功后也可以在<a target="_blank" rel="noopener" href="https://search.maven.org/">search.maven.org/</a>搜索Group Id就能搜出你发布的所有开源库了</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9013.png"></p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>怎么说呢，一路艰辛，疯狂踩坑，从JCenter到MavenCentral，再到最后的豁然开朗，不过JCenter被废弃的这一个事实算是记住了，关于下一次再发布开源库，直接跳过准备流程，直接走发布流程即可~</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0MavenCentral.html" data-id="clchkr8nw003r5oqhb6gh317t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-事件分发机制以及滑动冲突的处理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html" class="article-date">
  <time datetime="2021-12-21T07:15:02.000Z" itemprop="datePublished">2021-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html">事件分发机制以及滑动冲突的处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>Android UI中比较复杂的两个方面就是自定义和事件分发，此前没有过多时间来沉淀事件分发，这里做一个补充</p>
</blockquote>
<h3 id="二-源码分析"><a href="#二-源码分析" class="headerlink" title="二.源码分析"></a>二.源码分析</h3><p>对于时间分发可从两个维度去分析：</p>
<ol>
<li>从ViewGroup-&gt;View的分发过程：dispatchTouchEvent</li>
<li>从View-&gt;Activity的消费过程：onTouchEvent、onClick</li>
</ol>
<p>简单说就是从根到叶、叶回根的两个过程</p>
<p><strong>对于ViewGroup和View比较容易糊的一点：</strong></p>
<ul>
<li>从类的关系上来说：ViewGroup是View的孩子，所以在看源码的时候，一旦到了叶子节点，dispatchTouchEvent不是分发，而是消费的开始</li>
<li>从视图层级上来说：View是ViewGroup的孩子，Android的UI结构是视图树，所以是从ViewGroup开始的一个递归过程，无论是经典的测量、布局、绘制过程还是事件分发都是如此，因此在看源码的时候需要有这么一个层级关系</li>
</ul>
<p>本文对于事件分发考虑单点触摸：</p>
<ol>
<li>ACTION_DOWN事件：手指初次接触到屏幕时触发</li>
<li>ACTION_MOVE事件：手指在屏幕上滑动时触发，会<strong>多次触发</strong>，多次触发是重点</li>
<li>ACTION_UP事件：手指离开屏幕时触发</li>
<li>ACTION_CANCEL事件：事件被上层拦截时触发(源码中具体分析)</li>
</ol>
<p>只关心Down和Move事件，Down事件的分发是起始点，下图是基本流程，这里就带过了</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" style="zoom: 33%;" />

<p>ViewGroup：既可以处理事件也可以分发事件</p>
<p>View: 只能处理事件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:40%;" />

<p>这里为了好叙述，用上图为例</p>
<p>①Down事件处理流程</p>
<p>第一个层级：总经理(ViewGroup)</p>
<p>第二个层级：总监(ViewGroup)</p>
<p>第三个层级：清洁(View)</p>
<ol>
<li><p>总经理(DecorView)拿到Down事件-&gt;dispatchTouchEvent</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Down%E4%BA%8B%E4%BB%B6%E5%BC%80%E5%A7%8B.png" style="zoom:30%;" />

<p>点击事件是开端，所以需要重置之前的所有状态</p>
</li>
<li><p>判断事件是否拦截</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%BA%8C%E6%AD%A5.png" style="zoom:35%;" />

<p>第一次进来<code>disallowIntercept</code>必定为false，所以需要通过<code>onInterceptTouchEvent()</code>方法询问总经理是否要拦截此次点击事件</p>
</li>
<li><p>如果需要拦截事件，则需要进行分发或者处理</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%B8%89%E6%AD%A5.png" style="zoom:38%;" />

<p>所以是否进行处理在<code>dispatchTransformedTouchEvent()</code>此方法中，所以进到此方法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E5%9B%9B%E6%AD%A5.png" style="zoom:45%;" />

<p>所以如果拦截，就会调用父类的<code>dispatchTouchEvent</code>进行处理，ViewGroup的父类就是View，View中的处理方式就是OnTouchEvent或者OnClick，文末会进行补充</p>
</li>
<li><p>如果不拦截则分发</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%BA%94%E6%AD%A5.png" style="zoom:37%;" />

<p>可以看到上图，只有ACTION_DOWN事件才会进行分发，这里拿到总经理(DecorView)的<strong>直接子孩子</strong>数量进行遍历分发。比如这里总经理下面就有5个子孩子，对于这些子View肯定是有容器用来承载，装入的顺序也是有讲究的，仔细看后面，遍历其实是倒着来的，也就是说真正意义上的第一个子View是容器里的最后一个元素，具体排序规则是按照Z轴来排的，如果都没有设置Z轴则按先后顺序来倒序装入容器</p>
</li>
<li><p>拿到第一个孩子进行分发前还会进行判断是否可以接受点击事件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E5%85%AD%E6%AD%A5.png" style="zoom:36%;" />

<p>①<code>View#canReceivePointerEvents</code>方法用于判断当前孩子是否可见或者说看不到的话有没有设置过Animation动画</p>
<p>②<code>isTransformedTouchPointInView</code>判断触摸点是否在当前孩子内</p>
<p>如果不满足上述两个条件，就认为当前孩子没有能力进一步处理或分发该事件，就寻找下一个孩子</p>
</li>
<li><p>如果当前的第一个孩子可以接收点击事件，则进行分发，当前分发的ViewGroup对象肯定会从总经理变成总监，因此需要将当前的第一个孩子即总监传入进行新一轮的分发(递归)</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/dwon%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%B8%83%E6%AD%A5.png" style="zoom:35%;" />

<p>这个方法在拦截里面也会调用，因为是拦截所以传入的child为null，而这传入的是当前的第一个孩子，内部调用的是</p>
<p><code>child.dispatchTouchEvent(event)</code>，之后就会重复上述过程</p>
<p>如果总经理下有一个孩子消费了down事件，则会赋值<code>mFirstTouchTarget</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E5%85%AB%E6%AD%A5.png" style="zoom:35%;" />

<p>在<code>addTouchTarget(child, idBitsToAssign)</code>方法中进行标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br></pre></td></tr></table></figure>

<p>之后break退出遍历</p>
</li>
<li><p>那如果第一个孩子及其内部的孩子没有消费这个down事件，那么就得找总经理下面的第二个孩子(其他总监)，继续循环。如果总经理的孩子都没有处理这个事件，那<code>mFirstTouchTarget</code>还是为Null，就该自己处理，这和拦截是一样的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC9%E6%AD%A5.png" style="zoom:33%;" />

<p>如果有孩子处理了，那总经理肯定就不需要处理了，走上图流程，注意单点触摸的while循环只会循环一次，这个在addTouchTarget方法中可以看到target.next = null，此处的while循环是为了多点触摸设置的</p>
</li>
</ol>
<p>②Move事件的处理流程</p>
<p>经过down事件的分发，就可以确定一条处理链，比如：总经理-市场总监-市场研发，最终交由市场研发来处理事件，即便如此，move事件也会从总经理开始处理流程</p>
<ol>
<li><p>move事件也会检查当前ViewGroup是否拦截</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B61.png" style="zoom:33%;" /></li>
<li><p>down事件走过的分发流程move事件不会再走(这个过程是寻找谁处理可以处理事件)，进入下图分发给具体的孩子</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B62.png" style="zoom:33%;" />

<p><code>dispatchTransformedTouchEvent</code>此方法又是一个递归，最终调用叶节点的dispatchTouchEvent(event)即处理move事件</p>
</li>
</ol>
<p>③move事件的拦截(事件冲突的处理)</p>
<p>经过上述流程发现，down事件用于寻找谁处理，move事件直接递归分发给寻找到的孩子</p>
<p>这里单独将move事件的拦截抽离出来是为了解决事件冲突</p>
<p>所以大致有两个过程，对于拦截，都会想到孩子有一把尚方宝剑阻止父亲拦截孩子的事件，下面看一下源码</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B63.png" style="zoom:33%;" />

<p>这个图看了很多次了，在判断父亲是否拦截前，还得看孩子的意愿，但是孩子得有机会表达自己的意愿才行，所以父亲是不可以拦截down事件的，<code>disallowIntercept</code>这个标志位是在move分发时才有用，down事件是首次并且会清空标志位，所以只能是move事件才会有用，这个运算过程可以自行百度，就是普通的位运算，所谓的尚方宝剑就是下面的方法，孩子通过parent来调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</span><br><span class="line">            // We&#x27;re already in this state, assume our ancestors are too</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Pass it up to our parent</span><br><span class="line">        if (mParent != null) &#123;</span><br><span class="line">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面再看一下父容器拦截move事件后续的流程</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B64.png" style="zoom:33%;" />

<p>如果总经理要拦截，那么cancelChild就为true，进入到<code>dispatchTransformedTouchEvent</code>方法，会将cancelChild传入</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B65.png" style="zoom:30%;" />

<p>所以也就理解了ACTION_CANCEL事件如何触发的</p>
<p>如果本次move事件被父亲拦截了，那下一次move事件又该如何？</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B66.png" style="zoom:33%;" />

<p>因为上一次的move事件被父亲拦截了，那下一次move在经过父亲分发时就默认会被拦截</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B67.png" style="zoom:30%;" />

<p>所以总结一下第一个move事件的作用：</p>
<ol>
<li>因为父亲要拦截，所以调用孩子的cancel事件</li>
<li>将mFirstTouchTarget置为Null</li>
</ol>
<p>后续的move事件都会由父亲拦截，相当于走down事件的第3步，传入的child为null，自己处理</p>
<h3 id="三-滑动事件冲突的解决方案"><a href="#三-滑动事件冲突的解决方案" class="headerlink" title="三.滑动事件冲突的解决方案"></a>三.滑动事件冲突的解决方案</h3><blockquote>
<p>经过对源码的分析，这里做一个小结，其实得弄清楚down事件的寻找target过程，以及move事件的拦截(重点是第一次move事件的处理，第一次move事件其实还没有开始处理具体的业务逻辑，只是在处理标志位)，所以这两个首次很重要，首次down，首次move</p>
</blockquote>
<p>通过以上的分析再来处理滑动冲突就很简单了，两种方案：</p>
<ol>
<li><p>内部拦截(孩子拦截)</p>
<p>之前提到过尚方宝剑，孩子使用尚方宝剑是有前提的，父亲不能拦截down事件，所以在父亲的<code>onInterceptTouchEvent</code>方法中放过down事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123;</span><br><span class="line"> if (ev?.action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        super.onInterceptTouchEvent(ev)</span><br><span class="line">        return false</span><br><span class="line">     &#125;</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>孩子拿到了down事件，就需要使用尚方宝剑告诉父亲不要拦截move事件，当然不是所有事件都不拦截，是有条件的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">override fun dispatchTouchEvent(ev: MotionEvent?): Boolean &#123;</span><br><span class="line">        when(ev?.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(true)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">            		//如果是横向滑动就放出事件，让父亲处理</span><br><span class="line">                if (abs(ev.x-lastX) &gt; abs(ev.y-lastY)) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(false)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastX = ev?.x ?: 0f</span><br><span class="line">        lastY = ev?.y ?: 0f</span><br><span class="line">        return super.dispatchTouchEvent(ev)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以内部拦截法是孩子掌握了事件处理的优先权，给不给父亲处理由孩子决定</p>
</li>
<li><p>外部拦截法(父亲处理)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123;</span><br><span class="line">        when(ev?.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                lastX = ev.x</span><br><span class="line">                lastY = ev.y</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                if (abs(ev.x-lastX) &gt; abs(ev.y-lastY)) &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(ev)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里是以ViewPager嵌套ListView为例展示，只有横向滑动时才拦截，其他事件都可以放给孩子，末尾调用了super的方法，因为ViewPager内部做了处理，小编看了一下，ViewPager是可以拦截Down事件的，但是是横向拖拽的情况，经过调试，没有能触发此种情况，也就是说平常情况下ViewPager是不会拦截down事件的，上面也提到过，<strong>down事件必须可以让孩子拿到</strong>，因为如果孩子连down事件都拿不到，后续的move事件不可能拿到，因为会默认被拦截，详情看move事件的拦截</p>
</li>
</ol>
<p>小结：对比两种方案，如果真的遇到了滑动冲突，会首选外部拦截法，因为内部拦截法需要重写父亲和孩子，过于繁琐，但是如果我们希望上下滑动的同时可以左右滑动就必须使用内部拦截法，因为父亲可以抢孩子的事件，但孩子抢不了父亲的事件，一旦决定由父亲处理了，孩子是不可能拿到后续的move事件，这点通过上述的分析，相信很清晰</p>
<h3 id="四-孩子事件消费补充"><a href="#四-孩子事件消费补充" class="headerlink" title="四.孩子事件消费补充"></a>四.孩子事件消费补充</h3><blockquote>
<p>开头提到过会在文末补充事件的消费，常见的事件响应有onClick和onTouchEvent两个，但后者优先级更高，如果onTouchEvent返回来true，即把点击事件消费了，就不会再调用onClick的监听回调了，下面通过源码简单分析一下调用流程</p>
</blockquote>
<p>因为是View的事件消费，所以直接看dispatchTouchEvent方法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/View%E6%B6%88%E8%B4%B91.png" style="zoom:33%;" />

<p>可以看到上述的逻辑判断是短路&amp;连接，如果设置了onTouchListener，那一系列null的判断肯定不满足，一定会调用onTouch方法，如果onTouch返回了true，则onTouch消费了，那么result为true，自然就不会再调用onTouchEvent消费事件</p>
<p>进入到onTouchEvent中，因为onClick是在ACTION_UP中处理的，ACTION_UP中有一个函数<code>performClickInternal()</code>调用，内部接着调用performClick</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">        // We still need to call this method to handle the cases where performClick() was called</span><br><span class="line">        // externally, instead of through performClickInternal()</span><br><span class="line">        notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">        final boolean result;</span><br><span class="line">        final ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            li.mOnClickListener.onClick(this);</span><br><span class="line">            result = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(true);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里就看到了onClick的身影，onClick是没有返回值的，因为一但设置点击事件的监听回调，执行后默认被消费，可以自定义一个View进行测试可以很明显看到onTouch、onTouchEvent、onClick的调用优先级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class MyView @JvmOverloads constructor(context: Context, attr: AttributeSet? = null, style: Int = 0): View(</span><br><span class="line">    context,attr,style</span><br><span class="line">) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        initListener()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">        setMeasuredDimension(Utils.dp2px(50),Utils.dp2px(50))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;ClickableViewAccessibility&quot;)</span><br><span class="line">    private fun initListener() &#123;</span><br><span class="line">        setOnClickListener &#123;</span><br><span class="line">            Log.e(&quot;cx&quot;,&quot;OnClickListener&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        setOnTouchListener &#123; v, event -&gt;</span><br><span class="line">            Log.e(&quot;cx&quot;,&quot;OnTouchListener&quot;)</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onTouchEvent(event: MotionEvent?): Boolean &#123;</span><br><span class="line">        Log.e(&quot;cx&quot;,&quot;onTouchEvent&quot;)</span><br><span class="line">        //return true就不会调用onClick</span><br><span class="line">        return super.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onTouch&gt;onTouchEvent&gt;onClick</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/effee0768a5370ea281f02e234a0f1de85cf7d2c">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html" data-id="clchkr8ni002u5oqhd05lgyj4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Material-Design整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/Material-Design%E6%95%B4%E7%90%86.html" class="article-date">
  <time datetime="2021-12-16T02:58:45.000Z" itemprop="datePublished">2021-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/Material-Design%E6%95%B4%E7%90%86.html">Material Design整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>Material Design早在2014年就已经推出了，现在很多APP都会使用里面的控件布局UI，实现一些炫酷的布局效果很容易，本文旨在整理全套的基本使用，便于查阅</p>
</blockquote>
<h3 id="二-Material-Design使用示例"><a href="#二-Material-Design使用示例" class="headerlink" title="二.Material Design使用示例"></a>二.Material Design使用示例</h3><ol>
<li><p>底部工具栏</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Material%20Design/%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F.png" style="zoom:50%;" /></li>
</ol>
<p>使用场景：</p>
<ul>
<li>仅限移动设备</li>
<li>访问底部导航抽屉</li>
<li>有两到五个动作的屏幕</li>
</ul>
<p>注：不适用于带有底部导航栏的应用</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/59615210fbc6a0d75b22fe988ac8d2349f7c8d30">代码链接</a></p>
<p>FloatActionButton常用属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性值以及含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:layout_anchor</td>
<td align="center">相对于哪个控件的锚点</td>
</tr>
<tr>
<td align="center">app:layout_anchorGravity</td>
<td align="center">相对于锚点控件的位置(bottom|end|left…)</td>
</tr>
<tr>
<td align="center">app:rippleColor</td>
<td align="center">设置点击水波纹的颜色</td>
</tr>
<tr>
<td align="center">app:fabSize</td>
<td align="center">设置按钮大小</td>
</tr>
</tbody></table>
<p>BottomAppBar常用属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性值以及含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:navigationIcon</td>
<td align="center">设置导航菜单图标(也叫溢出菜单)</td>
</tr>
<tr>
<td align="center">app:hideOnScroll</td>
<td align="center">设置随着内容的滚动消失以及出现</td>
</tr>
<tr>
<td align="center">app:backgroundTint</td>
<td align="center">设置背景色</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;ShapeAppearance.App.SmallComponent&quot; parent=&quot;ShapeAppearance.MaterialComponents.SmallComponent&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;cornerFamily&quot;&gt;cut&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;cornerSize&quot;&gt;4dp&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">   &lt;style name=&quot;Widget.App.FloatingActionButton&quot; parent=&quot;Widget.MaterialComponents.FloatingActionButton&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;materialThemeOverlay&quot;&gt;@style/ThemeOverlay.App.FloatingActionButton&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">   &lt;style name=&quot;ThemeOverlay.App.FloatingActionButton&quot; parent=&quot;&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;shapeAppearanceSmallComponent&quot;&gt;@style/ShapeAppearance.App.SmallComponent&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>styles.xml添加如上样式，并让FloatActionButton使用可以展示不同的样式，点击的响应范围没变，对图形做了剪裁，详情看代码</p>
<p><a target="_blank" rel="noopener" href="https://material.io/develop/android/theming/shape">关于自定义Shape剪裁</a></p>
<ol start="2">
<li><p>顶部工具栏</p>
<p>①基本的工具栏滚动消失行为</p>
<ul>
<li><code>app:liftOnScroll=&quot;true&quot;</code>作用于AppBarLayout，显示与内容位于同一高度的顶部应用栏，滚动时，它会增加高度并让内容在其后面滚动</li>
<li><code>app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;</code>作用于MaterialToolbar，顶部应用栏在向上滚动时消失，向下滚动时出现</li>
<li><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>使NestedScrollView滚动搭配CoordinatorLayout</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/9a673d4800e990a53c2b5db4de8441a88538b6ab">代码链接</a></p>
<p>②突出的顶部应用栏</p>
<p>在MaterialToolbar外面套一层CollapsingToolbarLayout，并调大AppBarLayout的高度，使其可折叠</p>
<p>CollapsingToolbarLayout其实就是FrameLayout，所以还可以包裹一个ImageView作背景</p>
<ul>
<li><p><code>android:fitsSystemWindows=&quot;true&quot;</code>搭配主题透明可以使状态栏沉浸式，AppBarLayout中除了MaterialToolbar都需要加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.TopAppBarFitTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;</code>作用于CollapsingToolbarLayout，使得滑动时可折叠</p>
</li>
<li><p><code>app:layout_collapseMode=&quot;pin&quot;</code>作用于MaterialToolbar，固定滑到顶端ToolBar</p>
</li>
<li><p><code>android:background=&quot;@android:color/transparent&quot;</code>使MaterialToolbar透明，图片展示效果更佳</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/91a8e23146a8ae1438a6af4cd0f80a63c4cd722b">代码链接</a></p>
<p>③添加可变化式的ToolBar样式(上下文变化)</p>
<p>对于删除元素这种场景使用颇多</p>
<ul>
<li>定义删除状态的Menu</li>
<li>代码中添加回调(ActionMode)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.TopAppBarFitTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;windowActionModeOverlay&quot;&gt;true&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;actionModeStyle&quot;&gt;@style/Widget.App.ActionMode&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;actionModeCloseDrawable&quot;&gt;@drawable/ic_close_24dp&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;actionBarTheme&quot;&gt;@style/ThemeOverlay.MaterialComponents.Dark.ActionBar&lt;/item&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;style name=&quot;Widget.App.ActionMode&quot; parent=&quot;Widget.AppCompat.ActionMode&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;titleTextStyle&quot;&gt;?attr/textAppearanceHeadline6&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;subtitleTextStyle&quot;&gt;?attr/textAppearanceSubtitle1&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;background&quot;&gt;@color/material_grey_900&lt;/item&gt;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>ActionMode对应的主题</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/4bbc9e3b835a40c7e79e781793b6ebe5ca0d534f">代码链接</a></p>
</li>
<li><p>底部导航栏</p>
<p>官方是不建议单独使用，通常的用法是搭配Navigation(导航图)实现主页之间的切换</p>
<p>这里主要介绍menu的点击响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">binding.bottomNav.setOnItemSelectedListener &#123; item -&gt;</span><br><span class="line">            when(item.itemId) &#123;</span><br><span class="line">                R.id.page1 -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.page2 -&gt; &#123;        </span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                else -&gt; false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为其他的点击事件的API被废弃了，看上去不雅观，所以这里就是用比较原始的API</p>
<p><code>BottomNavigationView</code>还提供了带数量的标签Drawable，比如QQ的未读消息数量，使用很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private fun showCountDrawable(@IdRes menuId: Int) &#123;</span><br><span class="line">           binding.bottomNav.getOrCreateBadge(menuId).apply &#123;</span><br><span class="line">               if (!isVisible) isVisible = true</span><br><span class="line">               number = ++num</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   private fun removeCountDrawable(@IdRes menuId: Int) &#123;</span><br><span class="line">           binding.bottomNav.getBadge(menuId).also &#123; badgeDrawable -&gt;</span><br><span class="line">               if (badgeDrawable?.isVisible == true) &#123;</span><br><span class="line">                   badgeDrawable.clearNumber()</span><br><span class="line">                   badgeDrawable.isVisible = false</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>很多时候会使用路由框架，就和Navigation的导航框架会有冲突，所以还是可以考虑单独使用BottomNavigationView</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/e75aa3b17706f68c14e31e25e99ad63becb2a3f2">代码链接</a></p>
<p>这里就不展示主题的更换，详情可以参考官网，和之前提到的主题更换很类似</p>
</li>
<li><p>按钮</p>
<p>这里主要罗列比较特殊的按钮，比如线边框，就不用再用shape做背景了</p>
<p>①通过设置style达到效果</p>
<table>
<thead>
<tr>
<th align="center">style值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Widget.MaterialComponents.Button.TextButton</td>
<td align="center">不带icon的普通文本按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.TextButton.Icon</td>
<td align="center">带icon的文本按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.OutlinedButton</td>
<td align="center">不带icon的轮廓(线边框)按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.OutlinedButton.Icon</td>
<td align="center">带icon的轮廓按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.Icon</td>
<td align="center">原始风格带icon</td>
</tr>
</tbody></table>
<p>②<strong>按钮组(MaterialButtonToggleGroup)：</strong></p>
<ul>
<li>app:singleSelection：设置是否单选</li>
</ul>
<p>内部的Button只设置icon，然后自定义样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;Widget.App.Button.OutlinedButton.IconOnly&quot; parent=&quot;Widget.MaterialComponents.Button.OutlinedButton&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;iconPadding&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:insetTop&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:insetBottom&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:paddingLeft&quot;&gt;12dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:paddingRight&quot;&gt;12dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:minWidth&quot;&gt;48dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:minHeight&quot;&gt;48dp&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>③选择按钮(CheckBox)：通过selector的xml设置android:button属性，xml内部是state_checked属性</p>
<p>通用属性</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:icon</td>
<td align="center">设置图标</td>
</tr>
<tr>
<td align="center">app:iconTint</td>
<td align="center">设置图标颜色</td>
</tr>
<tr>
<td align="center">app:iconSize</td>
<td align="center">设置图标大小</td>
</tr>
<tr>
<td align="center">app:iconGravity</td>
<td align="center">设置图标位置</td>
</tr>
<tr>
<td align="center">app:iconPadding</td>
<td align="center">设置图标和文本的距离</td>
</tr>
<tr>
<td align="center">app:rippleColor</td>
<td align="center">点击的水波纹颜色</td>
</tr>
<tr>
<td align="center">app:strokeColor</td>
<td align="center">描边的颜色(如果有)</td>
</tr>
<tr>
<td align="center">app:strokeWidth</td>
<td align="center">描边的粗细(如果有)</td>
</tr>
<tr>
<td align="center">app:backgroundTint</td>
<td align="center">设置背景色</td>
</tr>
</tbody></table>
</li>
<li><p>Chip条目</p>
<p>共有四种类型，都是成组使用，通过不同的主题来区分</p>
<table>
<thead>
<tr>
<th align="center">Style</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Widget.MaterialComponents.Chip.Action</td>
<td align="center">默认的样式，只带有icon</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Chip.Entry</td>
<td align="center">输入条目样式</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Chip.Choice</td>
<td align="center">多项选择组</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Chip.Filter</td>
<td align="center">过滤组</td>
</tr>
</tbody></table>
<p>①单个Chip元素常用属性</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:chipIcon</td>
<td align="center">普通样式的icon</td>
</tr>
<tr>
<td align="center">app:checkedIcon</td>
<td align="center">选择样式的icon</td>
</tr>
<tr>
<td align="center">app:closeIcon</td>
<td align="center">移除样式的icon</td>
</tr>
</tbody></table>
<p>注：其余配套的属性都是和其功能搭配的，比如<code>check**</code></p>
<p>这个地方设置了对应的style就是对应的功能，比如过滤，点击之后就会自动更改选中样式，很方便，对于带closeIcon的Chip，可以设置点击事件，点×后可以让该Chip变成GONE，还是蛮好用的，然后获取对应被选中的Chip，代码中也有体现</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/036d4aafeb5474c092baa5a16e4e402d46373d52">代码链接</a></p>
</li>
<li><p>日期/时间选择器</p>
<p>日期/时间选择器，这里就一笔带过了，使用超简单，包括有时间范围的合没有时间范围的，拿到build之后的对象，还可以设置选择后的监听，拿到选择的具体日期或者时间跨度，详情看官网，比传统的时间选择器好用太多</p>
<p>此外还可以通过设置常量构造器限制选择的范围</p>
<p>日期和时间的选择器使用方式雷同，下面贴一下时间选择器的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val picker = MaterialTimePicker.Builder()</span><br><span class="line">                //设置小时制，12小时的界面会不同</span><br><span class="line">                .setTimeFormat(TimeFormat.CLOCK_24H)</span><br><span class="line">                .setHour(12)</span><br><span class="line">                .setMinute(10)</span><br><span class="line">                .setTitleText(&quot;Select Appointment time&quot;)</span><br><span class="line">                //设置展示的输入方式，不设置也可以，两种模式可以手动切换</span><br><span class="line">                .setInputMode(INPUT_MODE_CLOCK)</span><br><span class="line">                .build()</span><br><span class="line">        picker.addOnPositiveButtonClickListener &#123;</span><br><span class="line">            // 点击确定按钮</span><br><span class="line">        &#125;</span><br><span class="line">        picker.addOnNegativeButtonClickListener &#123;</span><br><span class="line">            // 点击取消按钮</span><br><span class="line">        &#125;</span><br><span class="line">        picker.addOnCancelListener &#123;</span><br><span class="line">            // call back code</span><br><span class="line">        &#125;</span><br><span class="line">        picker.addOnDismissListener &#123;</span><br><span class="line">            // Dialog消失的回调</span><br><span class="line">        &#125;</span><br><span class="line">        picker.show(supportFragmentManager,&quot;tag&quot;)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://material-io.cn/components/date-pickers/android#using-date-pickers">时间选择器官网链接</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/6efadff5ce61c5926d6e903958a0e4109bd821e0">代码链接</a></p>
</li>
<li><p>长按控件弹出菜单</p>
<p>这个还是蛮实用的吧，实现也比较简单，直接代码查看即可，也可以通过<code>PopupMenu</code>弹出菜单，这个用途是响应某个菜单按钮弹出</p>
<p>①长按某个控件弹出菜单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1.注册</span><br><span class="line">registerForContextMenu(view)</span><br><span class="line">// 2.重写对应的菜单解析方法</span><br><span class="line">override fun onCreateContextMenu(</span><br><span class="line">        menu: ContextMenu?,</span><br><span class="line">        v: View?,</span><br><span class="line">        menuInfo: ContextMenu.ContextMenuInfo?</span><br><span class="line">    ) &#123;</span><br><span class="line">        super.onCreateContextMenu(menu, v, menuInfo)</span><br><span class="line">        menuInflater.inflate(R.menu.contextual_action_bar,menu)</span><br><span class="line">    &#125;</span><br><span class="line">// 3.重写菜单项被点击的处理方法</span><br><span class="line">override fun onContextItemSelected(item: MenuItem): Boolean &#123;</span><br><span class="line">        return when (item.itemId) &#123;</span><br><span class="line">            R.id.share -&gt; &#123;</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">            R.id.delete -&gt; &#123;</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">            R.id.more -&gt; &#123;</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; super.onContextItemSelected(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>②单击控件弹出菜单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 1.添加点击监听</span><br><span class="line">view.setOnClickListener &#123;</span><br><span class="line">            showMenu(view,R.menu.contextual_action_bar)</span><br><span class="line">        &#125;</span><br><span class="line">// 2.通过PopupMenu弹出菜单</span><br><span class="line">private fun showMenu(v: View, @MenuRes menuRes: Int) &#123;</span><br><span class="line">        val popup = PopupMenu(this, v)</span><br><span class="line">        popup.menuInflater.inflate(menuRes, popup.menu)</span><br><span class="line"></span><br><span class="line">        popup.setOnMenuItemClickListener &#123; menuItem: MenuItem -&gt;</span><br><span class="line">            when(menuItem.itemId) &#123;</span><br><span class="line">                R.id.share -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.delete -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.more -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                else -&gt; false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        popup.setOnDismissListener &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        // Show the popup menu.</span><br><span class="line">        popup.show()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://material-io.cn/components/menus/android#dropdown-menus">官网文档</a></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/72aa2b4eeec04e45181bfe9e2a1825842c91e571">代码链接</a></p>
</li>
<li><p>抽屉布局</p>
<p>这里介绍两种抽屉布局</p>
<p>①常规的抽屉布局(类似QQ)</p>
<ul>
<li><p>定义Menu(这里可以有多个菜单Group，最终效果还蛮不错)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;group</span><br><span class="line">        android:id=&quot;@+id/group1&quot;</span><br><span class="line">        android:checkableBehavior=&quot;single&quot;&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item1&quot;</span><br><span class="line">            android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">            android:title=&quot;@string/title_1&quot;</span><br><span class="line">            android:checked=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item2&quot;</span><br><span class="line">            android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">            android:title=&quot;@string/title_2&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item3&quot;</span><br><span class="line">            android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">            android:title=&quot;@string/title_3&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;group</span><br><span class="line">        android:id=&quot;@+id/group2&quot;</span><br><span class="line">        android:checkableBehavior=&quot;single&quot;&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/subtitle&quot;</span><br><span class="line">            android:title=&quot;Subtitle&quot;&gt;</span><br><span class="line">            &lt;menu&gt;</span><br><span class="line">                &lt;item</span><br><span class="line">                    android:id=&quot;@+id/item4&quot;</span><br><span class="line">                    android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">                    android:title=&quot;Item 4&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;item</span><br><span class="line">                    android:id=&quot;@+id/item5&quot;</span><br><span class="line">                    android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">                    android:title=&quot;Item 5&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/menu&gt;</span><br><span class="line">        &lt;/item&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p>这里把第二个菜单组当做了子菜单</p>
</li>
<li><p>定义HeaderLayout(HeaderLayout和菜单都是给NavigationView使用的)</p>
</li>
<li><p>实现home页布局(home布局和NavigationView通过DrawerLayout包裹)</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/d050624784119898f2013e350894d0fea966ebed">代码链接</a></p>
<p>如果需要像QQ一样拉满屏幕，可以设置NavigationView<code>android:layout_marginRight=&quot;-65dp&quot;</code></p>
<p>②底部弹出抽屉</p>
<p>和左侧抽屉不一样的是，这里使用到了Behavior，通过将<code>BottomSheetBehavior</code>和<code>NavigationView</code>绑定实现从底部弹出抽屉，这个可以搭配前面写过的底部工具栏来使用</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/2000c6f9d3cde97744c5110e749b925ce42ad44e">代码链接</a></p>
</li>
<li><p>文本输入框</p>
<p>这个变化稍大，使用Material这套可以避免很多的自定义样式，蛮重要的，下面分类叙述</p>
<p>①附加icon</p>
<ul>
<li><p>app:startIconDrawable：添加起始图标</p>
</li>
<li><p>app:endIconMode：设置末尾模式，比如×，输入密码的模式下带小眼睛等，还可以自定义</p>
</li>
<li><p>app:endIconDrawable：在<code>custom</code>自定义模式下添加自己的icon，对于自己的icon还可以添加点击事件，这点很方便</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">textField.setEndIconOnClickListener &#123;</span><br><span class="line">  //末尾图标按下的回调</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textField.addOnEditTextAttachedListener &#123;</span><br><span class="line"> //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textField.addOnEndIconChangedListener &#123;</span><br><span class="line">  //末尾图标更改的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>②通过指定外层<code>TextInputLayout</code>的style和<code>AutoCompleteTextView</code>实现下拉选择输入</p>
<p>style=”@style/Widget.MaterialComponents.TextInputLayout.*.ExposedDropdownMenu”</p>
<p>③添加辅助说明文本在输入框的下方(作用于TextInputLayout)</p>
<p>app:helperTextEnabled=”true”<br>app:helperText=”辅助说明文本”</p>
<p>④添加文本计数功能(作用于TextInputLayout)</p>
<p>app:counterEnabled=”true”<br>app:counterMaxLength=”20”</p>
</li>
</ol>
<p>​        ⑤添加警告图标(作用于TextInputLayout)</p>
<p>​        app:errorEnabled=”true”</p>
<p>​        <code>passwordLayout.error = getString(警示信息)</code>，清空则赋为null即可</p>
<p>​        ⑥添加前后缀文本信息</p>
<p>​        app:prefixText=”前缀文本”<br>​        app:suffixText=”后缀文本”</p>
<p>​        这个常见于特定格式的邮箱补齐</p>
<p>​        ⑦添加文本改变的监听</p>
<p>​        <code>textField.editText?.doOnTextChanged &#123; text, start, before, count -&gt; &#125;</code>，可以不为里面的输入框设置id，直接通过外层        的TextInputLayout直接添加监听事件</p>
<ol start="10">
<li><p>Snackbar</p>
<p>类似于Toast的提示，使用也类似，下面简单介绍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Snackbar.make(binding.root,&quot;我是Snackbar&quot;,Snackbar.LENGTH_LONG)</span><br><span class="line">            .setAction(&quot;撤销&quot;)&#123;</span><br><span class="line">                //撤销后的响应</span><br><span class="line">            &#125;</span><br><span class="line">            //设置位于哪个控件的上方</span><br><span class="line">            .setAnchorView(binding.textField)</span><br><span class="line">            .show()</span><br></pre></td></tr></table></figure>

<p>所以也可以像平时封装Toast一样封装Snackbar，便于使用</p>
</li>
<li><p>Bottom Sheet(底部面板)</p>
<p>这个也超实用，只要需要底部弹窗的都可以用这个，Bottom Sheet分两种，一个是常驻的，一个是动态弹出</p>
<p>①常驻的Bottom Sheet：记得高德地图和美团里面都有用到</p>
<ul>
<li><p>设置behavior属性：app:layout_behavior=”@string/bottom_sheet_behavior”</p>
</li>
<li><p>设置起始高度：app:behavior_peekHeight=”dp值”</p>
</li>
<li><p>代码中可以通过<code>BottomSheetBehavior.from(设置过behavoir的view)</code>拿到behavoir，然后设置高度或者状态</p>
</li>
<li><p>常用的状态就是关闭(BottomSheetBehavior.STATE_COLLAPSED)和展开(BottomSheetBehavior.STATE_EXPANDED)</p>
</li>
<li><p>只要xml中设置了behavoir就可以拖动，至于最终能拖动多大距离，取决于控件的<code>layout_height</code></p>
</li>
<li><p>添加拖动的监听事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">behavior.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() &#123;</span><br><span class="line">            override fun onStateChanged(bottomSheet: View, newState: Int) &#123;</span><br><span class="line">                when (newState) &#123;</span><br><span class="line">                    BottomSheetBehavior.STATE_EXPANDED -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_COLLAPSED -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_DRAGGING -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_SETTLING -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_HIDDEN -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onSlide(bottomSheet: View, slideOffset: Float) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>​            ②动态的底部弹窗，有点类似于Dialog，但比Dialog好用</p>
<p>​            需要继承<code>BottomSheetDialogFragment</code>，然后和Fragment的创建类似，初始化布局，这里为了能够设置弹窗的高度，需要拿到系            统的<code>design_bottom_sheet</code>，如若不然，就算你布局时match_parent，也不会填满屏幕，之后设置高度，以及默认的起始高度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//拿到系统的Bottom Sheet，固定写法</span><br><span class="line">val view:FrameLayout = dialog?.findViewById(R.id.design_bottom_sheet)!!</span><br><span class="line">//拿到与之关联的behavior</span><br><span class="line">val behavior = BottomSheetBehavior.from(view)</span><br><span class="line">//设置弹出高度，如果不设置，则停止滑动时会停在默认0的位置</span><br><span class="line">behavior.peekHeight = 3000</span><br><span class="line">//设置弹窗大小</span><br><span class="line">view.layoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">behavior.state = BottomSheetBehavior.STATE_EXPANDED</span><br></pre></td></tr></table></figure>

<p>​            这里贴一下关键代码，这段初始化必须在onStart()中，否则会报错，因为dialog是在onCreate中创建的</p>
<p>​            <a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/ea7546e7fb640a5c33479e56825e14e42300074f">代码链接</a></p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>此篇琐碎的小文写了老久，算是对Material Design摸了一个底，实话说确实很好用，只不过上述是静态的使用，将它们组合在一起还需要动画支持，比如自定义Behavior和共享元素的转场动画</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/Material-Design%E6%95%B4%E7%90%86.html" data-id="clchkr8mv00195oqh1k1c920l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">Android重要组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%A1%B9%E7%9B%AE/">Android项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html%E5%AD%A6%E4%B9%A0/">html学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/">系统控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%B3%BB%E5%88%97/">组件化系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">hexo博客搭建问题总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" rel="tag">学年设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" rel="tag">系统高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 18px;">Android常用琐碎知识点</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" style="font-size: 10px;">Android开发小Demo</a> <a href="/tags/Android%E9%AB%98%E7%BA%A7UI/" style="font-size: 16px;">Android高级UI</a> <a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 10px;">hexo博客搭建问题总结</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 10px;">发布开源库</a> <a href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">学年设计</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" style="font-size: 20px;">算法篇</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" style="font-size: 12px;">系统高级UI</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 14px;">网络开源库</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
          </li>
        
          <li>
            <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
          </li>
        
          <li>
            <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
          </li>
        
          <li>
            <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
          </li>
        
          <li>
            <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 EngineerOfFinger<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/%20%7C%7C%20fas%20fa-home" class="mobile-nav-link">主页</a>
  
    <a href="/archives/%20%7C%7C%20fas%20fa-archive" class="mobile-nav-link">时间轴</a>
  
    <a href="/tags/%20%7C%7C%20fas%20fa-tags" class="mobile-nav-link">标签</a>
  
    <a href="/categories/%20%7C%7C%20fas%20fa-folder-open" class="mobile-nav-link">分类</a>
  
    <a href="/link/%20%7C%7C%20fas%20fa-link" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>