<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>CoordinatorLayout原理分析以及自定义Behavior入门 | 梦幻泡影</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一.前言 前面有整理过MD的用法，想要实现高级的效果，那还是得自定义，现在很多App都会使用到CoordinatorLayout来实现滚动关联的炫酷效果，至少体验感很好，下面会先从原理开始探讨，然后体验简单的自定义效果  二.CoordinatorLayout协调的原理分析CoordinatorLayout是建立在NestedScrolling机制的基础上的，但是NestedScroling仅限于">
<meta property="og:type" content="article">
<meta property="og:title" content="CoordinatorLayout原理分析以及自定义Behavior入门">
<meta property="og:url" content="https://wiwiyiyi.com/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">
<meta property="og:site_name" content="梦幻泡影">
<meta property="og:description" content="一.前言 前面有整理过MD的用法，想要实现高级的效果，那还是得自定义，现在很多App都会使用到CoordinatorLayout来实现滚动关联的炫酷效果，至少体验感很好，下面会先从原理开始探讨，然后体验简单的自定义效果  二.CoordinatorLayout协调的原理分析CoordinatorLayout是建立在NestedScrolling机制的基础上的，但是NestedScroling仅限于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/View%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%861.png">
<meta property="og:image" content="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%862.png">
<meta property="og:image" content="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95behavoir%E7%A4%BA%E4%BE%8B.gif">
<meta property="article:published_time" content="2022-01-26T05:22:05.000Z">
<meta property="article:modified_time" content="2023-01-04T09:03:55.010Z">
<meta property="article:author" content="EngineerOfFinger">
<meta property="article:tag" content="Android高级UI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/View%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
  
    <link rel="alternate" href="/atom.xml" title="梦幻泡影" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/wiwi.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">梦幻泡影</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">[object Object]</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/%20%7C%7C%20fas%20fa-home">主页</a>
        
          <a class="main-nav-link" href="/archives/%20%7C%7C%20fas%20fa-archive">时间轴</a>
        
          <a class="main-nav-link" href="/tags/%20%7C%7C%20fas%20fa-tags">标签</a>
        
          <a class="main-nav-link" href="/categories/%20%7C%7C%20fas%20fa-folder-open">分类</a>
        
          <a class="main-nav-link" href="/link/%20%7C%7C%20fas%20fa-link">友链</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wiwiyiyi.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-CoordinatorLayout原理分析以及自定义Behavior入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html" class="article-date">
  <time datetime="2022-01-26T05:22:05.000Z" itemprop="datePublished">2022-01-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CoordinatorLayout原理分析以及自定义Behavior入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面有整理过MD的用法，想要实现高级的效果，那还是得自定义，现在很多App都会使用到CoordinatorLayout来实现滚动关联的炫酷效果，至少体验感很好，下面会先从原理开始探讨，然后体验简单的自定义效果</p>
</blockquote>
<h3 id="二-CoordinatorLayout协调的原理分析"><a href="#二-CoordinatorLayout协调的原理分析" class="headerlink" title="二.CoordinatorLayout协调的原理分析"></a>二.CoordinatorLayout协调的原理分析</h3><p>CoordinatorLayout是建立在NestedScrolling机制的基础上的，但是NestedScroling仅限于父View和子View之间的交互，不能实现子View之间的交互效果，可以说CoordinatorLayout是兼容NestedScroling机制的</p>
<p>分析原理前，先过一遍View的生命周期</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/View%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" style="zoom:50%;" />

<ul>
<li>addView是添加到content区域</li>
<li>整个页面的层级是：activity-&gt;window-&gt;view</li>
<li>attach之后会触发makeVisible方法，setView之后会通过WMS开始绘制</li>
</ul>
<p>所以onAttachedToWindow是开始，那么CoordinatorLayout源码分析也是从此开始</p>
<ol>
<li><p>通过ViewTreeObserver添加绘制监听</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%861.png" style="zoom:33%;" /></li>
<li><p>开始绘制时，回调到<code>onPredraw</code>方法，进而调用<code>onChildViewsChanged</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">         final View child = mDependencySortedChildren.get(i);</span><br><span class="line">         final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">			//...省略部分代码</span><br><span class="line">         // Update any behavior-dependent views for the change</span><br><span class="line">         for (int j = i + 1; j &lt; childCount; j++) &#123;</span><br><span class="line">             final View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">             final LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">             final Behavior b = checkLp.getBehavior();</span><br><span class="line">   </span><br><span class="line">             if (b != null &amp;&amp; b.layoutDependsOn(this, checkChild, child)) &#123;</span><br><span class="line">                 if (type == EVENT_PRE_DRAW &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                     // If this is from a pre-draw and we have already been changed</span><br><span class="line">                     // from a nested scroll, skip the dispatch and reset the flag</span><br><span class="line">                     checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">   </span><br><span class="line">                 final boolean handled;</span><br><span class="line">                 switch (type) &#123;</span><br><span class="line">                     case EVENT_VIEW_REMOVED:</span><br><span class="line">                         // EVENT_VIEW_REMOVED means that we need to dispatch</span><br><span class="line">                         // onDependentViewRemoved() instead</span><br><span class="line">                         b.onDependentViewRemoved(this, checkChild, child);</span><br><span class="line">                         handled = true;</span><br><span class="line">                         break;</span><br><span class="line">                     default:</span><br><span class="line">                         // Otherwise we dispatch onDependentViewChanged()</span><br><span class="line">                         handled = b.onDependentViewChanged(this, checkChild, child);</span><br><span class="line">                         break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>省略了开头部分代码，此处的核心就是两层for循环，第二层是寻找依赖第一层for循环中定下的child，所以第一层是dependency(被依赖)，第二层是依赖方，如果存在依赖关系就通过behavior做更新逻辑的处理，switch里面有两种情况，一是dependency被移除时，二是默认情况下的视图更新(dependency改变时)</p>
</li>
<li><p>现在还有一个问题，mDependencySortedChildren是在什么时候初始化的，这个就得到onMeasure里面去看了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void prepareChildren() &#123;</span><br><span class="line">        mDependencySortedChildren.clear();</span><br><span class="line">        mChildDag.clear();</span><br><span class="line"></span><br><span class="line">        for (int i = 0, count = getChildCount(); i &lt; count; i++) &#123;</span><br><span class="line">            final View view = getChildAt(i);</span><br><span class="line"></span><br><span class="line">            final LayoutParams lp = getResolvedLayoutParams(view);</span><br><span class="line">            lp.findAnchorView(this, view);</span><br><span class="line"></span><br><span class="line">            mChildDag.addNode(view);</span><br><span class="line"></span><br><span class="line">            // Now iterate again over the other children, adding any dependencies to the graph</span><br><span class="line">            for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                if (j == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final View other = getChildAt(j);</span><br><span class="line">                if (lp.dependsOn(this, view, other)) &#123;</span><br><span class="line">                    if (!mChildDag.contains(other)) &#123;</span><br><span class="line">                        // Make sure that the other node is added</span><br><span class="line">                        mChildDag.addNode(other);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Now add the dependency to the graph</span><br><span class="line">                    mChildDag.addEdge(other, view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally add the sorted graph list to our list</span><br><span class="line">        mDependencySortedChildren.addAll(mChildDag.getSortedList());</span><br><span class="line">        // We also need to reverse the result since we want the start of the list to contain</span><br><span class="line">        // Views which have no dependencies, then dependent views after that</span><br><span class="line">        Collections.reverse(mDependencySortedChildren);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在onMeasure开始时调用<code>prepareChildren</code>方法进行收集CoordinatorLayout<strong>直接子View之间</strong>的依赖关系，看到这种依赖关系肯定是通过图来管理的，邻接矩阵是常用方式，这里深究的话，用的是dfs深度优先，再看就有点秃头了，这里主要是理解流程，可以看到，这里添加的顺序是(依赖方,dependency)的元组方式，显然我们得将它们反转，拿到dependency后再去遍历和它又依赖关系的View，这里还是很好理解的</p>
</li>
<li><p>有了2和3两步其实对它的原理也是蛮清晰的了，当dependency改变时一定会触发重绘，一旦重绘就会调用<code>onChildViewsChanged</code></p>
<p>去更新和它有依赖关系的View，而具体的更新操作，自然是在Behavior里面了，下面会进行一个小示例的展示来体现更新逻辑</p>
</li>
<li><p>此外，还得研究一下怎么监听到dependency被移除的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%862.png" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private class HierarchyChangeListener implements OnHierarchyChangeListener &#123;</span><br><span class="line">        HierarchyChangeListener() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChildViewAdded(View parent, View child) &#123;</span><br><span class="line">            if (mOnHierarchyChangeListener != null) &#123;</span><br><span class="line">                mOnHierarchyChangeListener.onChildViewAdded(parent, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChildViewRemoved(View parent, View child) &#123;</span><br><span class="line">            onChildViewsChanged(EVENT_VIEW_REMOVED);</span><br><span class="line"></span><br><span class="line">            if (mOnHierarchyChangeListener != null) &#123;</span><br><span class="line">                mOnHierarchyChangeListener.onChildViewRemoved(parent, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中设置了监听，所以视图被移除时可以感知到</p>
</li>
</ol>
<h3 id="三-自定义Behavoir入门实战"><a href="#三-自定义Behavoir入门实战" class="headerlink" title="三.自定义Behavoir入门实战"></a>三.自定义Behavoir入门实战</h3><blockquote>
<p>上面的分析大致缕清了CoordinatorLayout的工作原理，下面通过一个小例子来体验一下自定义Behavior实现的效果</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95behavoir%E7%A4%BA%E4%BE%8B.gif" style="zoom:50%;" />

<p>可以看到这个简单例子就很形象的展示了当dependency改变时，其他和它关联的子View的行为改变，这里代码比较简单，直接贴上对应的Behavior</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 颜色改变的behavior</span><br><span class="line">class ChangeColorBehavior @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;TextView&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    private val mArgbEvaluator = ArgbEvaluator()</span><br><span class="line"></span><br><span class="line">    override fun layoutDependsOn(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        return dependency is DefineDragView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;ResourceAsColor&quot;)</span><br><span class="line">    override fun onDependentViewChanged(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        val color = mArgbEvaluator.evaluate(dependency.y / parent.height, Color.WHITE, Color.BLACK) as Int</span><br><span class="line">        child.setTextColor(color)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 跟随dependency的behavior</span><br><span class="line">class ChildFollowBehavior@JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;TextView&gt;() &#123;</span><br><span class="line">    override fun layoutDependsOn(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        return dependency is DefineDragView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDependentViewChanged(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        child.y = (dependency.bottom + 50).toFloat()</span><br><span class="line">        child.x = dependency.x</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，这里必须重写的两个方法，<code>layoutDependsOn</code>用于筛选是否具有依赖关系，<code>onDependentViewChanged</code>用于做dependency改变的更新逻辑，其实在上述分析源码流程时就有看到这两个方法的身影</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>到这里，其实CoordinatorLayout的高级用法已经结束了，就是理解透它的协调流程，子View之间是如何联动的，下面进行两个问题的总结</p>
</blockquote>
<ol>
<li>使用behavior的View必须是CoordinatorLayout的直接子View，因为收集时并不是递归形式的查找</li>
<li>NestedScrolling机制的View不一定是直接子View，因为会递归查找，CoordinatorLayout实现了NestedScrollingParent系列接口</li>
</ol>
<p>后续会在项目实战中推出比较高级的自定义Behavior，这里只是一个入门，这里还有一个小坑，自定义的Behavior必须提供类似上述的构造函数，盲猜是需要第二个参数，因为在xml中使用，另外就是最好用类的全称，否则会抛异常</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/wiwiyiyi/improving-repository/commit/75f23d632ae87b1100e0a575f9f45c6dc6747510">代码链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wiwiyiyi.com/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html" data-id="clchki9j4000nt0qhap6q72lb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          首次开源库-不一样的文字渐变效果
        
      </div>
    </a>
  
  
    <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">NestedScrollView嵌套滑动原理</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-UI%E7%B3%BB%E5%88%97/">Android UI系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%AE%9E%E6%88%98%E9%9B%86/">Android实战集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E9%9B%86/">Android开发基础集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/">Android自定义系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Android设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6/">Android重要组件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E9%A1%B9%E7%9B%AE/">Android项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html%E5%AD%A6%E4%B9%A0/">html学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/">力扣题解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%92%E5%BA%8F%E9%9B%86/">排序集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">注解处理器与开源框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6/">系统控件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%B3%BB%E5%88%97/">组件化系列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%93%E9%A2%98/">设计模式专题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E9%9B%86/">问题总结集</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">Android常用琐碎知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" rel="tag">Android开发小Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E9%AB%98%E7%BA%A7UI/" rel="tag">Android高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">hexo博客搭建问题总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">发布开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" rel="tag">学年设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag">算法篇</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" rel="tag">系统高级UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" rel="tag">网络开源库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android%E5%B8%B8%E7%94%A8%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 18px;">Android常用琐碎知识点</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E5%B0%8FDemo/" style="font-size: 10px;">Android开发小Demo</a> <a href="/tags/Android%E9%AB%98%E7%BA%A7UI/" style="font-size: 16px;">Android高级UI</a> <a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 10px;">hexo博客搭建问题总结</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 10px;">发布开源库</a> <a href="/tags/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">学年设计</a> <a href="/tags/%E7%AE%97%E6%B3%95%E7%AF%87/" style="font-size: 20px;">算法篇</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/" style="font-size: 12px;">系统高级UI</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93/" style="font-size: 14px;">网络开源库</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html">自定义PhotoView处理手势</a>
          </li>
        
          <li>
            <a href="/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html">首次开源库-不一样的文字渐变效果</a>
          </li>
        
          <li>
            <a href="/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html">CoordinatorLayout原理分析以及自定义Behavior入门</a>
          </li>
        
          <li>
            <a href="/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html">NestedScrollView嵌套滑动原理</a>
          </li>
        
          <li>
            <a href="/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html">APT-javapoet详细教程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 EngineerOfFinger<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/%20%7C%7C%20fas%20fa-home" class="mobile-nav-link">主页</a>
  
    <a href="/archives/%20%7C%7C%20fas%20fa-archive" class="mobile-nav-link">时间轴</a>
  
    <a href="/tags/%20%7C%7C%20fas%20fa-tags" class="mobile-nav-link">标签</a>
  
    <a href="/categories/%20%7C%7C%20fas%20fa-folder-open" class="mobile-nav-link">分类</a>
  
    <a href="/link/%20%7C%7C%20fas%20fa-link" class="mobile-nav-link">友链</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>