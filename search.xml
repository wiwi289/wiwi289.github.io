<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APT-Java搭建环境以及入门</title>
    <url>/APT-Java%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>APT的全称是<strong>Annotation Processing Tool</strong>，也就是注解处理器，很多开源框架都会使用，简单说它的作用就是在编译期根据模板生成我们所需要的类，用来写框架很合适，很具动态性，下面会从基础开始到能够写出一些我们想要的东西</p>
</blockquote>
<h3 id="二-注解处理器基本介绍"><a href="#二-注解处理器基本介绍" class="headerlink" title="二.注解处理器基本介绍"></a>二.注解处理器基本介绍</h3><blockquote>
<p>所谓注解处理器，顾名思义，需要注解，在编译期，注解处理会扫描源文件，找出我们指定的Annotation，根据注解以及我们提供的<strong>规则</strong>生成代码</p>
</blockquote>
<p>所以比较重要的就是规则了，下面进行一个简单介绍</p>
<p>先从APT的写法开始，要知道Java是面向对象的语言，所以我们写java的思路是：创建文件-&gt;创建类-&gt;创建方法</p>
<p>那么APT生成类的方式也类似，不过这里有两种方式(个人理解，为了方便叙述，暂且这样)：</p>
<ol>
<li><p>面向过程：通过文件流自顶向下生成类，也就是从import导包开始写，比如EventBus</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/APT1.png" style="zoom: 33%;" />

<p>这样写的好处是可读性好，一目了然功能是什么，但是容易出错，一个标点符号写错都不行</p>
</li>
<li><p>面向对象</p>
<p>这里所谓的面向对象和Java的写法是倒过来的，创建方法-&gt;创建类-&gt;创建文件，不过也倒挺符合封装的思想，实现这种写法，必须使用<a href="https://github.com/square/javapoet">javapoet</a>这个库，下面也主要整理该库的使用方式</p>
</li>
</ol>
<p>既然通常选择面向对象的写法，那么自然需要清楚结构思路，先剖析一下java文件的结构</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/APT2.png" style="zoom:47%;" />

<ul>
<li>PackageElement：表示一个包程序元素。提供对有关包及其成员的信息的访问</li>
<li>ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序(静态或实例)</li>
<li>TypeElement：表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。</li>
<li>VariableElement：表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</li>
</ul>
<p>我们在写APT相关时，很重要的一个东西就是Element，也就是注解作用的元素(接口、类、属性、方法等)，系统提供了如下API供我们使用</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getEnclosedElements()</td>
<td align="center">返回该元素直接包含的子元素</td>
</tr>
<tr>
<td align="center">getEnclosingElement()</td>
<td align="center">返回包含该element的父element，与上一个方法相反</td>
</tr>
<tr>
<td align="center">getKind()</td>
<td align="center">返回element的类型，判断是哪种element</td>
</tr>
<tr>
<td align="center">getModifiers()</td>
<td align="center">获取修饰关键字,入public static final等关键字</td>
</tr>
<tr>
<td align="center">getSimpleName()</td>
<td align="center">获取名字，不带包名</td>
</tr>
<tr>
<td align="center">getQualifiedName()</td>
<td align="center">获取全名，如果是类的话，包含完整的包名路径</td>
</tr>
<tr>
<td align="center">getParameters()</td>
<td align="center">获取方法的参数元素，每个元素是一个VariableElement</td>
</tr>
<tr>
<td align="center">getReturnType()</td>
<td align="center">获取方法元素的返回值</td>
</tr>
<tr>
<td align="center">getConstantValue()</td>
<td align="center">如果属性变量被final修饰，则可以使用该方法获取它的值</td>
</tr>
</tbody></table>
<p>下面再介绍一下javapoet为我们提供的方法</p>
<table>
<thead>
<tr>
<th align="center">工具类</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MethodSpec</td>
<td align="center">代表一个构造函数或方法声明</td>
</tr>
<tr>
<td align="center">TypeSpec</td>
<td align="center">代表一个类，接口，或者枚举声明</td>
</tr>
<tr>
<td align="center">FieldSpec</td>
<td align="center">代表一个成员变量，一个字段声明</td>
</tr>
<tr>
<td align="center">JavaFile</td>
<td align="center">包含一个顶级类的Java文件</td>
</tr>
<tr>
<td align="center">ParameterSpec</td>
<td align="center">用来创建参数</td>
</tr>
<tr>
<td align="center">AnnotationSpec</td>
<td align="center">用来创建注解</td>
</tr>
<tr>
<td align="center">ClassName</td>
<td align="center">用来包装一个类</td>
</tr>
<tr>
<td align="center">TypeName</td>
<td align="center">类型，如在添加返回值类型是使用 TypeName.VOID</td>
</tr>
</tbody></table>
<p>比如MethodSpec，用来生成一个方法，后续会介绍它们的基本使用</p>
<h3 id="三-APT的使用搭建"><a href="#三-APT的使用搭建" class="headerlink" title="三.APT的使用搭建"></a>三.APT的使用搭建</h3><p>上面介绍了一堆APT相关概念和工具，这里就先进入正题，写任何一个东西都需要搭建一个环境，所以先搭建APT的环境，能够看到APT在工作，以及对应的产物</p>
<p>APT通常有如下三个模块：</p>
<ul>
<li>compiler：存放自定义注解处理器，代码编译生成规则在这里声明-&gt;<strong>java模块</strong></li>
<li>annotations：存放注解-&gt;<strong>java模块</strong></li>
<li>apt_api ：暴露给用户的api，我们生成的代码怎么调用，需要提供api支持-&gt;<strong>android 模块</strong></li>
</ul>
<ol>
<li><p>创建好上述三个模块后，建立相互间的依赖关系</p>
<p>compiler模块需要根据注解进行处理，所以需要依赖annotations模块</p>
<p>app和apt_api模块需要使用定义的注解并且通过注解处理器生成一些类，所以都需要依赖annotations模块，和通过annotationProcessor启用compiler中的注解处理器</p>
<p>app模块还需单独依赖apt_api，因为需要使用apt_api提供的一些api，这也是做SDK开发需要提供的api</p>
</li>
<li><p>自定义注解处理器以及相关配置</p>
<p>有了上述依赖，还得让compiler模块真正工作起来，那么就需要自定义注解处理器Processor</p>
<p>自定义注解处理器就是继承AbstractProcessor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须重写的是<code>process</code>方法，这个里面就是用来自定义生成类的规则，关于返回值</p>
<p>false : 表示没有出来完</p>
<p>true : 表示已经处理完了</p>
<p>但该方法无论如何都要执行两遍，第二次使用来检查是否有生成匹配规则的类文件</p>
<p>下面还得让编译期识别到我们自定义的注解处理器还有相关配置</p>
<ul>
<li><p>@SupportedAnnotationTypes：配置该注解处理器支持的注解</p>
</li>
<li><p>@SupportedSourceVersion：支持的版本号，通常是SourceVersion.RELEASE_7</p>
</li>
<li><p>@SupportedOptions：接收外部传入的参数</p>
</li>
<li><p>@AutoService(Process.class)：标识该注解处理器能够被编译期识别，需要额外的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</span><br><span class="line">annotationProcessor &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</span><br></pre></td></tr></table></figure>

<p>使用AutoService就不用通过javax.annotation.processing.Processor文件注册注解处理器，很方便</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">@SupportedAnnotationTypes(&#123;&quot;swu.cx.annotations.Test&quot;&#125;)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">@SupportedOptions(MyProcessor.PARAMS_CONFIG)</span><br><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    public static final String PARAMS_CONFIG = &quot;MODULE_NAME&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上工作处理完毕后，还需在MyProcessor的init方法中准备一些工具类，用于在写规则的时候使用</p>
<ul>
<li><p>Messager：日志打印工具</p>
<p>提供了ERROR、WARNING、MANDATORY_WARNING、NOTE OTHER五个级别的日志信息，常用的就是ERROR和NOTE了，不过使用ERROR会直接导致编译失败，强制性停止编译</p>
</li>
<li><p>Filer：文件生成器</p>
</li>
<li><p>Types：类信息工具类</p>
</li>
<li><p>Elements：节点工具类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">      super.init(processingEnv);</span><br><span class="line">      mElementUtils = processingEnv.getElementUtils();</span><br><span class="line">      mTypeUtils = processingEnv.getTypeUtils();</span><br><span class="line">      mFiler = processingEnv.getFiler();</span><br><span class="line">      mMessager = processingEnv.getMessager();</span><br><span class="line">      mModuleName = processingEnv.getOptions().get(PARAMS_CONFIG);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四-开始定义规则生成类文件"><a href="#四-开始定义规则生成类文件" class="headerlink" title="四.开始定义规则生成类文件"></a>四.开始定义规则生成类文件</h3><blockquote>
<p>有了以上的铺垫，现在就可以在process方法中定义生成文件的规则了，前面有说到使用javapoet生成文件，所以还需在compiler模块添加如下依赖</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com.squareup:javapoet:1.11.1&#x27;</span><br></pre></td></tr></table></figure>

<p>在开始生成文件前，可以通过增加打印信息来判断我们的注解处理器是否在工作，并且还可以输出处理过程中的一些重要信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">      mMessager.printMessage(Diagnostic.Kind.NOTE, &quot;=======&gt; process处理ing&quot;);</span><br><span class="line">      //构造main方法</span><br><span class="line">      MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC,Modifier.STATIC)</span><br><span class="line">              .returns(TypeName.VOID)</span><br><span class="line">              .addParameter(String[].class, &quot;args&quot;)</span><br><span class="line">              .addStatement(&quot;$T.out.println($S)&quot;,System.class,&quot;hello apt java!&quot;)</span><br><span class="line">              .build();</span><br><span class="line">      //构造类</span><br><span class="line">      TypeSpec helloWord = TypeSpec.classBuilder(&quot;HelloApt&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC,Modifier.FINAL)</span><br><span class="line">              .addMethod(methodSpec)</span><br><span class="line">              .build();</span><br><span class="line">      //指定包路径</span><br><span class="line">      JavaFile javaFile = JavaFile.builder(&quot;swu.cx.HelloApt&quot;, helloWord)</span><br><span class="line">              .build();</span><br><span class="line">      //生成文件</span><br><span class="line">      try &#123;</span><br><span class="line">          javaFile.writeTo(mFiler);</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了javapoet官网一个简单的小例子，先体验一下后续后补充完整的使用方法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/APT3.png" style="zoom:25%;" />

<p>可以看到生成了对应的文件，以及输出的打印信息</p>
<p>这里有一个很大的坑点，就是在app模块或其他应用了注解处理器的模块必须使用了注解才能触发注解处理器，因为顾名思义，注解处理器是根据注解才工作的，如果都没有使用注解，那么默认是不工作的，这个超坑，另外就是配置注解处理器的时候要格外仔细，按照上面的配置方式是一定可以跑起来的，后续也会补充Kotlin方式的配置</p>
<p>此外这里抛出的FilerException就是二次调用process方法的结果，这个无关紧要，可以忽略，因为第二遍的检查机制</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>此篇为入门篇，先把环境搭好，后续的工作就是通过javapoet定义规则，规则有简单的，也有复杂的，想上述的例子就是格外简单的，后续会从简到繁定义规则，也方便后续查阅</p>
</blockquote>
]]></content>
      <categories>
        <category>注解处理器与开源框架</category>
      </categories>
  </entry>
  <entry>
    <title>APK打包流程以及瘦身</title>
    <url>/APK%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%98%A6%E8%BA%AB.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>小编最近参加软件设计大赛，由于最终打包生成的app接近100MB，为了缩小app的体积，小编开始了解APK瘦身，在此之前还得了解APK的打包流程，其实由AS打包的app就是APK，下面小编从APK的组成说起</p>
</blockquote>
<h3 id="二-APK的成分"><a href="#二-APK的成分" class="headerlink" title="二.APK的成分"></a>二.APK的成分</h3><p><strong>首先得知道APK就是一个压缩包，官网中给出了APK的组成如下</strong></p>
<p>①目录</p>
<ol>
<li><p><code>META-INF</code>：包含 <code>CERT.SF</code> 和 <code>CERT.RSA</code> 签名文件，以及 <code>MANIFEST.MF</code> 清单文件</p>
</li>
<li><p><code>assets</code>：包含应用的资源；应用可以使用 <code>AssetManager</code> 对象检索这些资源</p>
</li>
<li><p><code>res</code>：包含未编译到 <code>resources.arsc</code> 中的资源</p>
</li>
<li><p><code>lib</code>: 包含特定于处理器软件层的已编译代码。此目录包含每种平台类型的子目录，如 <code>armeabi</code>、<code>armeabi-v7a</code>、<code>arm64-v8a</code>、<code>x86</code>、<code>x86_64</code> 和 <code>mips</code></p>
</li>
</ol>
<p>②文件</p>
<ol>
<li><code>resources.arsc</code>：包含已编译的资源。此文件包含 <code>res/values/</code> 文件夹的所有配置中的 XML 内容。打包工具会提取此 XML 内容，将其编译为二进制文件形式，并压缩内容。此内容包括语言字符串和样式，以及未直接包含在 <code>resources.arsc</code> 文件中的内容（例如布局文件和图片）的路径</li>
<li><code>classes.dex</code>：包含以 Dalvik/ART 虚拟机可理解的 DEX 文件格式编译的类</li>
<li><code>AndroidManifest.xml</code>：包含核心 Android 清单文件。此文件列出了应用的名称、版本、访问权限和引用的库文件。该文件使用 Android 的二进制 XML 格式</li>
</ol>
<p>下面展示小编项目打包后的APK通过压缩软件查看内部结构</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/apk%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom: 75%;" />

<h3 id="三-APK打包流程"><a href="#三-APK打包流程" class="headerlink" title="三.APK打包流程"></a>三.APK打包流程</h3><blockquote>
<p>在了解了APK的组成后，再来看APK的打包流程</p>
</blockquote>
<p><strong>先上流程图</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png"></p>
<ol>
<li>首先通过Android SDK中build-tools目录下对应的android版本提供的aapt工具将应用资源<strong>Application Resources</strong>打包生成R.java和对应的打包资源</li>
<li>和aapt位于同一目录下的aidl工具会将aidl文件打包成java文件</li>
<li>所有的.java文件通过java编译器编译为.class文件</li>
<li>将上一步骤编译的.class文件和第三方jar中的.class通过dex工具打包成.dex文件</li>
<li>然后将编译过的资源文件和.dex文件以及其他可能没有引用的资源文件通过apk打包工具打包成apk文件，但此时的.apk还不能运行，因为要通过最后一步签名才可以，签名后还会进行对齐处理</li>
</ol>
<h3 id="四-APK瘦身"><a href="#四-APK瘦身" class="headerlink" title="四.APK瘦身"></a>四.APK瘦身</h3><p>有了前面的铺垫，终于来到了APK瘦身模块，通过瘦身步骤，小编的APP较少了接近40MB的体积，感觉效果还是很不错的，下面开始真正的瘦身</p>
<ol>
<li><p>图片瘦身</p>
<p>一个项目最常见并且几乎不能缺省的资源便是图片，小编的项目也是图片太多，但目前没办法处理，对于使用了套图的项目，小编强烈建议改用矢量图Vector，因为它可以随比例缩放不失真，并且体积是真的小，当然能使用xml的资源更好，并且适量图还可以通过Tint着色得到不同颜色的矢量图，完全满足需求</p>
</li>
<li><p>国际化</p>
<p>如果你的APP仅在中国使用，那么使用中文即可，所以去掉国际化也可以缩小体积，特别是对于文字资源特别多的项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resConfigs &#x27;zh&#x27;</span><br></pre></td></tr></table></figure>

<p>在对应的app模块defaultConfig {}大括号中添加</p>
</li>
<li><p>动态库优化</p>
<p>如果集成过第三方平台SDK的朋友应该知道会在app模块defaultConfig {}大括号中添加一下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">       abiFilters &#x27;armeabi&#x27;, &#x27;armeabi-v7a&#x27;, &#x27;arm64-v8a&#x27;,&#x27;x86&#x27;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>因为so库的底层是用C/C++实现的，存在版本不兼容问题，比如虚拟机需要’x86’版本，而真机需要’armeabi-v7a’版本，但是现实中APP的使用只需要armeabi-v7a版本即可，微信就是这样做的，将其他版本删去后，你的app会缩小不少体积，这一步是瘦身的核心输出</p>
</li>
<li><p>移除未使用的资源</p>
<p>在Refactor选项中有<code>Remove Unused Resources</code>，可以一键移除未使用的资源</p>
<p>当你找到有些资源没有可能没有被使用时，可以使用一下代码，然后再一键删除，这样处理会安全很多，考虑到隐形引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resources.getIdentifier(&quot;activity_main&quot;,&quot;layout&quot;,packageName)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>就目前而言，经常使用的APK瘦身方式如上所示，同时APK的打包流程也需了解</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Android关于UI布局的小总结</title>
    <url>/Android%E5%85%B3%E4%BA%8EUI%E5%B8%83%E5%B1%80%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h1 id="项目常用三种布局详解"><a href="#项目常用三种布局详解" class="headerlink" title="项目常用三种布局详解"></a>项目常用三种布局详解</h1><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一.背景"></a>一.背景</h2><p>今日在做UI布局方面的修改，相信很多新人在过往一般都是独立开发小项目，所以为了方便都习惯用<code>ConstraintLayout</code>，因而其他三种布局接近边缘化，所以特地总结此篇文章以便快速上手公司项目的布局优化任务</p>
<h2 id="二-6种布局基础"><a href="#二-6种布局基础" class="headerlink" title="二.6种布局基础"></a>二.6种布局基础</h2><h3 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h3><p>帧布局是最简单的，特点就是，内部的控件不能指定摆放的位置，只能重叠在左上角</p>
<p><strong>优点：FrameLayout效率最高(体现在绘制速度上)，占用内存也是三者中最少的</strong></p>
<p>所以能使用FrameLayout就尽量使用FrameLayout作为外层容器，这也是布局优化的一个技巧</p>
<p>不能使用FrameLayout的场景：如果在代码中有设置布局参数(LayoutParam)，就不能将xml中的布局容器进行替换，因为设置布局参数对FrameLayout无效，也就是上面所提到的内部控件无法制定摆放位置</p>
<p>此外FrameLayout有的时候也会被用作占位符，通常搭配Fragment使用，确定Fragment在Activity视图中的位置</p>
<h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><p>线性布局分横向和纵向，通过<code>orientation</code>属性来设置布局方向(horizontal|vertical)，默认是horizontal</p>
<p>LinearLayout常用的属性分为两部分解说：</p>
<p>设置容器本身的属性：</p>
<ul>
<li><p>orientation：设置控件摆放方向，依次按纵向或者横向排列</p>
</li>
<li><p>gravity：设置控件在容器内部的位置-&gt;left、top、right、bottom、center、center_horizontal、center_vertical</p>
<p>可以通过|连接两个方位，如bottom|left，即底部靠左</p>
</li>
<li><p>padding：设置控件与容器内壁的距离</p>
</li>
</ul>
<p>设置控件本身的属性：</p>
<ul>
<li>layout_weight：给控件分配权重，用于按照比例瓜分容器空间(控件的高度或者宽度都为0)</li>
<li>layout_gravity：设置控件在容器中的摆放方位，和gravity值相同，但靠左还是靠右因orientation而异，可以自己试一试，会因为布局方向而没有效果</li>
<li>layout_margin：设置控件与四周的距离</li>
</ul>
<p>常用的属性如上，很多时候会将内和外两种相对属性弄混，所以我就分容器和控件两种类别，但它们其实是相对的，因为控件内部还会有内容，比如TextView，文本相对于控件来说是内部内容，所以可以根据以上两种分类联合记忆</p>
<p><strong>重点想说一下padding和margin两种属性，一个是内，一个是外</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/padding%E5%92%8Cmargin.png" style="zoom:60%;" />

<p>可以看到上图，红色箭头是设置layout_margin，黑色箭头是设置padding，对比可以发现，padding区域是属于控件本身，而margin部分属于容器，如果要实现一段间距，并且扩大控件的触摸事件响应范围，我们可以用padding代替margin，如果说上面的控件是一个button，而你想扩大button的点击区域，不改变button上的文本距离外部容器的距离，那么我们可以让button填充满整个容器，那么之前的padding应该加上外部的margin，如下图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/padding%E6%9B%BF%E6%8D%A2.png" style="zoom:60%;" />

<p>对比很明显，黄色区域的点击范围扩大了，可以自己写一个小demo试一试，实际上面的控件通常是一个容器，content才是控件</p>
<p>另外，如果上面的控件没有设置margin，而是外层的容器设置了padding，这其实是等价的，因为空白区域都属于外层容器</p>
<h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h3><p>线性布局提供了布局方案：纵向或者横向，相对布局需要我们自己确定布局方案，灵活性更大</p>
<p>容器本身独有的属性：</p>
<ul>
<li>ignoreGravity：忽略某个控件的布局方案，默认放在容器左上角</li>
</ul>
<p>设置布局方案的属性：</p>
<ol>
<li><p>相对于父容器的方位</p>
<ul>
<li><p>android: layout_alignParentLeft：靠左边显示。</p>
</li>
<li><p>android: layout_alignParentTop：靠顶部显示。</p>
</li>
<li><p>android: layout_alignParentRight：靠右边显示。</p>
</li>
<li><p>android: layout_alignParentBottom：靠底部显示。</p>
</li>
<li><p>android: layout_centerInParent：居中显示。</p>
</li>
<li><p>android: layout_centerHorizontal：水平居中显示。</p>
</li>
<li><p>android: layout_centerVertical：垂直居中显示。</p>
</li>
</ul>
</li>
<li><p>相对于其他view的方位</p>
<ul>
<li><p>android: layout_toLeftOf：在指定view的左边</p>
</li>
<li><p>android: layout_toRightOf：在指定view的右边</p>
</li>
<li><p>android: layout_above：在指定view的上方</p>
</li>
<li><p>android: layout_below：在指定view的下方</p>
</li>
</ul>
</li>
<li><p>相对于其他view的对齐方式</p>
<ul>
<li><p>android: layout_alignBaseline：和指定view的baseline 对齐。</p>
</li>
<li><p>android: layout_alignLeft：和指定view的左边对齐</p>
</li>
<li><p>android: layout_alignTop：和指定view的顶部对齐</p>
</li>
<li><p>android: layout_alignRight：和指定view的右边对齐</p>
</li>
<li><p>android: layout_alignBottom：和指定view的底部对齐</p>
</li>
</ul>
</li>
</ol>
<p>Tip：如果默认方向是从左往右，start和left等价，end和right等价，可以进行替换，因为我们通常默认从左到右，而像阿拉伯语是从右到左。相对于view的布局方案，所指定的view和摆放的view需要<strong>位于同一个RelativeLayout中</strong>，因为会存在布局的嵌套</p>
<p>将相对于父容器的位置和相对于其他view的位置以及margin和top等组合在一起就能确定view的摆放位置了</p>
<h3 id="TableLayout"><a href="#TableLayout" class="headerlink" title="TableLayout"></a>TableLayout</h3><p>表格布局：通常用在类似于表单的区域，比较好管理行列结构以及布局</p>
<ul>
<li>TableRow：控制一行，每添加一个view就增加一列</li>
<li>layout_column：作用在每行中的view上，整个表格的列数是以最多的那一行为准，该属性可以控制view摆放在哪一行</li>
<li>layout_span：设置view占几列，默认值是1</li>
</ul>
<h3 id="GridLayout"><a href="#GridLayout" class="headerlink" title="GridLayout"></a>GridLayout</h3><p>网格布局：比表格布局更加灵活</p>
<p>设置容器本身的属性：</p>
<ul>
<li>columnCount：设置最大的列数</li>
<li>rowCount：设置最大的行数</li>
<li>orientation：子view排列方向，horizontal：一行一行的添加，当view数量超出最大范围时，会增加行数 vertical：一列一列添加，当超出数量范围时，会增加列数</li>
<li>alignmentMode：alignBounds：对齐子视图边界 alignMargins ：对齐子视图内容，默认值</li>
<li>useDefaultMargins：没有指定视图的布局参数时使用默认的边距，默认值是false</li>
</ul>
<p>设置view的摆放属性：</p>
<ul>
<li>layout_column：设置view摆放在第几列(从0开始)</li>
<li>layout_row：设置view摆放在第几行(从0开始)</li>
<li>layout_columnSpan：指定view占据的列数</li>
<li>layout_rowSpan：指定view占据的行数</li>
<li>layout_gravity：设置view在容器中的位置，主要搭配跨列和跨行的时候使用，否则没有效果</li>
<li>layout_columnWeight：列权重</li>
<li>layout_rowWeight：行权重</li>
</ul>
<h3 id="AbsoluteLayout"><a href="#AbsoluteLayout" class="headerlink" title="AbsoluteLayout"></a>AbsoluteLayout</h3><p>绝对布局：通过设置view的x和y坐标来确定view的摆放位置，显然会出现屏幕适配的问题，发生拉伸等等，完全不能使用</p>
<h2 id="三-UI绘制的流程解析"><a href="#三-UI绘制的流程解析" class="headerlink" title="三.UI绘制的流程解析"></a>三.UI绘制的流程解析</h2><p>首先说一下Window、WindowManager、ViewRootImpl、DecorView</p>
<ol>
<li><p>Window：一个抽象基类，它提供了一系列窗口的方法，比如设置背景，标题等等，而它的唯一实现类则是PhoneWindow</p>
</li>
<li><p>WindowManager：窗口管理器，每一个窗口管理器都与一个的窗口显示绑定，可以对view进行增删操作</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/windowmanager.webp" style="zoom:67%;" />

<p>Activity内部保存有一个WindowManager的实例，在Activity被创建的时候进行的初始化，同时也保存了Window的实例</p>
</li>
<li><p>ViewRootImpl是一个视图层次结构的顶部，它实现了View与WindowManager之间所需要的协议，作为WindowManagerGlobal中大部分的内部实现，对view的操作最终是通过ViewRootImpl提供的方法实现的，</p>
</li>
<li><p>DecorView：顶级视图，继承与FramentLayout，setContentView则是添加在它里面的@id/content里</p>
</li>
</ol>
<p>上述和Activity创建的关系：</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%90%86%E8%AE%BA%E8%AF%BE%E5%AD%A6%E4%B9%A0/Activity%E5%90%AF%E5%8A%A8.png" style="zoom:70%;" />

<p>ViewRootImpl负责完成view的测量、布局、绘制</p>
<p>UI的绘制流程包括：measure、layout、draw，都是从根视图递归遍历view树进行的，下面以measure流程为例进行说明</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/measure%E6%B5%81%E7%A8%8B.png"></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/%E5%B1%82%E7%BA%A7%E5%88%86%E6%9E%90.png" style="zoom:50%;" />

<p>顺着箭头的方向进行遍历测量，最后回退确定各个容器的尺寸</p>
<p><strong>不论是采用哪种布局，都会对view测量两次，第一次是layoutRequested为true，第二次是因为是第一次加载视图，mFirst和mStopped都为true，可以通过断点调试发现调用栈</strong></p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
  </entry>
  <entry>
    <title>APT-javapoet详细教程</title>
    <url>/APT-javapoet%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍了注解处理器的相关概念以及工作流程，并且还搭建好了配置环境，本文将介绍通过javapoet来编写文件生成规则，从简到繁，当然也是借鉴官网的案例，途中可能有坑，小编先踩为敬</p>
</blockquote>
<h3 id="二-javapoet定义规则"><a href="#二-javapoet定义规则" class="headerlink" title="二.javapoet定义规则"></a>二.javapoet定义规则</h3><blockquote>
<p>前面也介绍了APT定义生成规则的两种方式，javapoet比较推崇，基本的写法流程也有提到，下面主要是定义一些比较高级的规则，比如生成带泛型的方法、类等等</p>
</blockquote>
<ol>
<li><p>定义控制流(for、if-else等等)</p>
<p>控制流在平常写代码中也极为常见，之前的小例子中仅仅为方法体添加了一行输出语句，当然了也可以添加定义变量的语句，后续会提到，这里先介绍控制流的规则写法</p>
<p>①通过<code>addCode</code>添加字符串形式的代码，有点类似于EventBus逐行手动写的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addControlFlowByHardCode() &#123;</span><br><span class="line">        MethodSpec main = MethodSpec.methodBuilder(&quot;main2&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC,Modifier.STATIC)</span><br><span class="line">                .returns(void.class)</span><br><span class="line">                .addCode(&quot;&quot;</span><br><span class="line">                        + &quot;int sum = 0;\n&quot;+</span><br><span class="line">                        &quot;for(int i = 0; i &lt; 20; i++) &#123; \n&quot; +</span><br><span class="line">                        &quot;        sum += i;\n&quot;+</span><br><span class="line">                                &quot;&#125;\n&quot;+</span><br><span class="line">                        &quot;&quot;)</span><br><span class="line">                .addStatement(&quot;$T.out.println(sum)&quot;,System.class)</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloApt2 = TypeSpec.classBuilder(&quot;HelloApt2&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(main)</span><br><span class="line">                .build();</span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt2)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述规则生成的类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt2 &#123;</span><br><span class="line">  public static void main2() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i &lt; 20; i++) &#123; </span><br><span class="line">            sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是通过硬编码的方式添加控制流，就等价于你一字不差的补充完整这个流程</p>
<p>②通过javapoet提供的流程控制api编写控制流程，这个的话感觉逻辑性更强一点，但肯定不如硬编码那么直观</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addControlFlowByLogicAPI() &#123;</span><br><span class="line">        MethodSpec main = MethodSpec.methodBuilder(&quot;main3&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(int.class)</span><br><span class="line">                .addStatement(&quot;int sum = 0&quot;)</span><br><span class="line">                .beginControlFlow(&quot;for(int i = 0; i &lt; 20; i++)&quot;)</span><br><span class="line">                .addStatement(&quot;sum += i&quot;)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .addStatement(&quot;return sum&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt3&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(main)</span><br><span class="line">                .build();</span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt).build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt3 &#123;</span><br><span class="line">  public static int main3() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比硬编码和通过控制流的api两种方式创建控制流，明显发现只有硬编码才会末尾加**;**分号，并且还需要大括号标识代码块，而api帮我们自动添加，这样的好处是我们定义规则时只需要关心我们的逻辑是否可行，很方便，这里官网还提供了，传参的方式，传参也是有好处的，更具动态性，比如我们可以给一个注解添加start和end两个参数，那么我们在注解处理器中可以读取到这两个变量的值，然后根据客户端传入的start和end来创建一个范围的控制流，这个思路也是蛮好的，不过目前还没有想到应用场景</p>
<p>③生成if-else的控制流，按照官网的意思，if-else的控制可以无限生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addIfElseFlowByLogicAPI() &#123;</span><br><span class="line">       MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;compareTimeStamp&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">               .addParameter(long.class,&quot;lastClickTime&quot;)</span><br><span class="line">               .addParameter(long.class, &quot;validLength&quot;)</span><br><span class="line">               .returns(boolean.class)</span><br><span class="line">               .addStatement(&quot;long now = $T.currentTimeMillis()&quot;,System.class)</span><br><span class="line">               .addStatement(&quot;long diff = now - lastClickTime&quot;)</span><br><span class="line">               .beginControlFlow(&quot;if ( diff &lt; validLength)&quot;)</span><br><span class="line">               .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;超级符合！！&quot;)</span><br><span class="line">               .addStatement(&quot;return true&quot;)</span><br><span class="line">               .nextControlFlow(&quot;else if (diff == validLength)&quot;)</span><br><span class="line">               .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;刚刚好，有点小失落。&quot;)</span><br><span class="line">               .addStatement(&quot;return true&quot;)</span><br><span class="line">               .nextControlFlow(&quot;else&quot;)</span><br><span class="line">               .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;超出范围，可以拜拜了。。&quot;)</span><br><span class="line">               .addStatement(&quot;return false&quot;)</span><br><span class="line">               .endControlFlow()</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       TypeSpec helloApt2 = TypeSpec.classBuilder(&quot;HelloApt4&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">               .addMethod(methodSpec)</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt2)</span><br><span class="line">               .build();</span><br><span class="line">       try &#123;</span><br><span class="line">           javaFile.writeTo(mFiler);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt4 &#123;</span><br><span class="line">  public static boolean compareTimeStamp(long lastClickTime, long validLength) &#123;</span><br><span class="line">    long now = System.currentTimeMillis();</span><br><span class="line">    long diff = now - lastClickTime;</span><br><span class="line">    if ( diff &lt; validLength) &#123;</span><br><span class="line">      System.out.println(&quot;超级符合！！&quot;);</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else if (diff == validLength) &#123;</span><br><span class="line">      System.out.println(&quot;刚刚好，有点小失落。&quot;);</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      System.out.println(&quot;超出范围，可以拜拜了。。&quot;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次给生成的方法通过<code>addParamete</code>r添加了参数，有多个参数则多次添加即可，可以看到这种无限的控制流是通过<code>nextControlFlow</code>来控制的，最后记得<code>endControlFlow</code>就好</p>
<p>④生成try-catch控制流，类似于if-else，也可以无限流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addTryCatchFlowByLogicAPI() &#123;</span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;exceptionCatch&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(void.class)</span><br><span class="line">                .beginControlFlow(&quot;try&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T($S)&quot;,ClassCastException.class,&quot;Failed&quot;)</span><br><span class="line">                .nextControlFlow(&quot;catch(ClassCastException e)&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T(e)&quot;,RuntimeException.class)</span><br><span class="line">                .nextControlFlow(&quot;catch(RuntimeException e)&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T($S)&quot;,ClassNotFoundException.class,&quot;class not found&quot;)</span><br><span class="line">                .nextControlFlow(&quot;catch(ClassNotFoundException e)&quot;)</span><br><span class="line">                .addStatement(&quot;throw new $T(e)&quot;,Exception.class)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt5&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt5 &#123;</span><br><span class="line">  public static void exceptionCatch() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      throw new ClassCastException(&quot;Failed&quot;);</span><br><span class="line">    &#125; catch(ClassCastException e) &#123;</span><br><span class="line">      throw new RuntimeException(e);</span><br><span class="line">    &#125; catch(RuntimeException e) &#123;</span><br><span class="line">      throw new ClassNotFoundException(&quot;class not found&quot;);</span><br><span class="line">    &#125; catch(ClassNotFoundException e) &#123;</span><br><span class="line">      throw new Exception(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码逻辑不一定正确，这里只是为了演示效果，从上面的例子可以看到，什么时候需要使用T变量来代替类，什么时候又可以直接在字符串中写入这个类，其实之所以要通过T变量来占位，是因为T变量的方式javapoet会自动帮我们导包，而不需要自己通过<code>addStatement</code>的方式来添加导包，所以如果前面有通过T变量的方式导入了，后续就可以直接通过字符串的形式写入，关于这个占位符下面也会介绍到</p>
</li>
<li><p>字符串拼接中的三个占位符</p>
<p>上面已经出现了一个占位符T，它是用来标识一个类型，那么还有L和S占位符等，下面一一介绍</p>
<p>①常量占位符</p>
<p>常量常见的有int、float、double等基本数据类型和字符串等</p>
<p>下面就先展示int类型的占位方式，其实基本类型的占位都一样，生成的结果或者使用差异，取决于你定义规则中字符串中的写入的类型是否是int或者其他类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addLExpression(int from, int to) &#123;</span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;LExpression&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(int.class)</span><br><span class="line">                .addStatement(&quot;int sum = 0&quot;)</span><br><span class="line">                .beginControlFlow(&quot;for(int i = $L; i &lt; $L; i++)&quot;,from, to)</span><br><span class="line">                .addStatement(&quot;sum += i&quot;)</span><br><span class="line">                .endControlFlow()</span><br><span class="line">                .addStatement(&quot;return sum&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt6&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt6 &#123;</span><br><span class="line">  public static int LExpression() &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 1; i &lt; 20; i++) &#123;</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个的话，可以在APT处理过程中读取注解中携带的值，动态生成一个范围的控制流</p>
<p>②S和T占位符前面已经使用了很多次了，相信也不太陌生，S用于字符串变量的占位，T用于类型占位，关于T这里再稍微啰嗦一点吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object();</span><br></pre></td></tr></table></figure>

<p>那么生成规则对应于</p>
<p><code>addStatement(&quot;$T obj = new $T&quot;, Object.class, Object.class)</code>或<code>addStatement(&quot;$T obj = new Object()&quot;, Object.class)</code></p>
<p>使用T占位类型的目的就是为了能够自动导入包，所以只要有一处导入，其他地方就不用再占位了</p>
<p>关于S的占位，小编试了试不用S占位，发现生成的文件依旧是正常的，所以貌似也可以，看官网的解释说是<strong>字符串变量</strong>才会使用到S占位，如果是写死的字符串的话，不需要占位</p>
<p>③方法名的占位符N，如果我们需要引用另外生成的方法来填充这行规则，就需要用到N来代替方法名占位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addMethodNamePlaceCase() &#123;</span><br><span class="line">        MethodSpec method1 = MethodSpec.methodBuilder(&quot;getName&quot;)</span><br><span class="line">                .addModifiers(Modifier.PRIVATE, Modifier.STATIC)</span><br><span class="line">                .returns(String.class)</span><br><span class="line">                .addStatement(&quot;return \&quot;cx\&quot;&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        ClassName testBean = ClassName.get(&quot;swu.cx.javaaptproject&quot;,&quot;TestBean&quot;);</span><br><span class="line">        MethodSpec method2 = MethodSpec.methodBuilder(&quot;generateObjWithName&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(testBean)</span><br><span class="line">                .addStatement(&quot;String name = $N()&quot;,method1)</span><br><span class="line">                .addStatement(&quot;return $T.createStringObj(name)&quot;,testBean)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt9&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method1)</span><br><span class="line">                .addMethod(method2)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .addStaticImport(testBean, &quot;createIntObj&quot;)</span><br><span class="line">                .addStaticImport(testBean, &quot;createStringObj&quot;)</span><br><span class="line">                .addStaticImport(Collection.class,&quot;*&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt9 &#123;</span><br><span class="line">  private static String getName() &#123;</span><br><span class="line">    return &quot;cx&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static TestBean generateObjWithName() &#123;</span><br><span class="line">    String name = getName();</span><br><span class="line">    return createStringObj(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关于类型的高级用法</p>
<p>在java中高级编程比较普遍，比如泛型的使用，那么，在生成文件的时候，如何生成带泛型的初始化表达式或者就是一个泛型的表达式，下面细细说来</p>
<p>①ClassName</p>
<p>ClassName比较重要，可以识别所有存在的类，就算是不存在的，也可以根据你提供的模板，自动导入生成</p>
<p>下面展示一下ArrayList的生成以及使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addArrayListUseCase() &#123;</span><br><span class="line">        ClassName objType = ClassName.get(&quot;java.lang&quot;,&quot;Object&quot;);</span><br><span class="line">        ClassName list = ClassName.get(&quot;java.util&quot;, &quot;List&quot;);</span><br><span class="line">        ClassName arrayList = ClassName.get(&quot;java.util&quot;, &quot;ArrayList&quot;);</span><br><span class="line">        TypeName listOfObj = ParameterizedTypeName.get(list, objType);</span><br><span class="line"></span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;arrayListCase&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(listOfObj)</span><br><span class="line">                .addStatement(&quot;$T arrayList = new $T&lt;&gt;()&quot;, listOfObj, arrayList)</span><br><span class="line">                .addStatement(&quot;arrayList.add(new $T())&quot;, objType)</span><br><span class="line">                .addStatement(&quot;arrayList.add(new $T())&quot;, objType)</span><br><span class="line">                .addStatement(&quot;return arrayList&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt7&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt7 &#123;</span><br><span class="line">  public static List&lt;Object&gt; arrayListCase() &#123;</span><br><span class="line">    List&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(new Object());</span><br><span class="line">    arrayList.add(new Object());</span><br><span class="line">    return arrayList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以对于泛型化的类型，需要获取到每一个具体的类型，然后通过<code>ParameterizedTypeName</code>进行组装</p>
<p>②导入静态代码块以及野蛮导入</p>
<p>对于静态方法，我们可以直接导入，然后生成的代码文件会变得简洁一点，同时import static也支持野蛮式导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addImportStaticCase() &#123;</span><br><span class="line">        ClassName testBean = ClassName.get(&quot;swu.cx.javaaptproject&quot;, &quot;TestBean&quot;);</span><br><span class="line">        ClassName list = ClassName.get(&quot;java.util&quot;, &quot;List&quot;);</span><br><span class="line">        ClassName arrayList = ClassName.get(&quot;java.util&quot;, &quot;ArrayList&quot;);</span><br><span class="line">        TypeName listOfTestBean = ParameterizedTypeName.get(list, testBean);</span><br><span class="line"></span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;importStaticCase&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .returns(listOfTestBean)</span><br><span class="line">                .addStatement(&quot;$T list = new $T&lt;&gt;()&quot;,listOfTestBean, arrayList)</span><br><span class="line">                .addStatement(&quot;list.add($T.createIntObj(20))&quot;,testBean)</span><br><span class="line">                .addStatement(&quot;list.add($T.createStringObj(\&quot;hello testBean\&quot;))&quot;,testBean)</span><br><span class="line">                .addStatement(&quot;return list&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt8&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .addStaticImport(testBean, &quot;createIntObj&quot;)</span><br><span class="line">                .addStaticImport(testBean, &quot;createStringObj&quot;)</span><br><span class="line">                .addStaticImport(Collection.class,&quot;*&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt8 &#123;</span><br><span class="line">  public static List&lt;TestBean&gt; importStaticCase() &#123;</span><br><span class="line">    List&lt;TestBean&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(createIntObj(20));</span><br><span class="line">    list.add(createStringObj(&quot;hello testBean&quot;));</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现确实清爽了许多，import static是在生成JavaFile的时候使用，此外在定义规则的字符串中如果要<strong>标识一个字符串得用转义字符转义一下</strong></p>
</li>
<li><p>生成其他成员类型</p>
<p>只提到过方法的生成，以及添加参数等基本操作，下面补充其他类的成员结构</p>
<p>①生成构造函数</p>
<p>构造函数也是一个方法，只不过是通过<code>constructorBuilder</code>来生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addConstructorCase() &#123;</span><br><span class="line">        MethodSpec cons = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addParameter(String.class, &quot;name&quot;)</span><br><span class="line">                .addStatement(&quot;this.$N = $N&quot;, &quot;name&quot;, &quot;name&quot;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt10&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addField(String.class, &quot;name&quot;, Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(cons)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt10 &#123;</span><br><span class="line">  public final String name;</span><br><span class="line"></span><br><span class="line">  public HelloApt10(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里多了一个N的占位符，上面提到是给方法名做占位的，官网的解释说只要自身的一个东西需要自身的另一个东西来生成，就可以通过N进行占位处理，这里可以说是这种场景，其实构造函数也没啥特别的只是比构造普通函数替换了一个东西而已，然后添加参数，当然了这里还提前引入了Field(属性)的生成，下面会一笔带过</p>
<p>②给方法添加参数：使用<code>addParameter</code>添加，有两种添加方式，下面具体列出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addParameterCase() &#123;</span><br><span class="line">        //方式一，通过ParameterSpec构造生成一个参数类型</span><br><span class="line">        ParameterSpec android = ParameterSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">                .addModifiers(Modifier.FINAL)</span><br><span class="line">                .build();</span><br><span class="line">        MethodSpec test = MethodSpec.methodBuilder(&quot;testAddParameter&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">                .addParameter(android)</span><br><span class="line">                .addParameter(int.class, &quot;age&quot;, Modifier.FINAL) //方式二</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt11&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">                .addMethod(test)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt11 &#123;</span><br><span class="line">  public static void testAddParameter(final String android, final int age) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是比较简单的，一般来说，方式二就可以了，轻便</p>
<p>③添加Field(成员属性)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加属性</span><br><span class="line">   private void addFieldCase() &#123;</span><br><span class="line">       //方式一 通过FieldSpec构造</span><br><span class="line">       FieldSpec android = FieldSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       TypeSpec helloApt = TypeSpec.classBuilder(&quot;HelloApt12&quot;)</span><br><span class="line">               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">               .addField(android)</span><br><span class="line">               .addField(int.class, &quot;age&quot;, Modifier.PRIVATE, Modifier.FINAL) //方式二</span><br><span class="line">               .build();</span><br><span class="line">   </span><br><span class="line">       JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, helloApt)</span><br><span class="line">               .build();</span><br><span class="line">       try &#123;</span><br><span class="line">           javaFile.writeTo(mFiler);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class HelloApt12 &#123;</span><br><span class="line">  public final String android;</span><br><span class="line"></span><br><span class="line">  private final int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和方法添加参数类似，通常使用第二种方式</p>
<p>当然了，第一种通过Build的方式构造是可以添加默认值的，通过<code>initializer</code>方法添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FieldSpec android = FieldSpec.builder(String.class, &quot;android&quot;)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">        .initializer(&quot;\&quot;hello\&quot;&quot;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>还可以通过前面提到的S和L两个占位符进行模式拼接</p>
</li>
<li><p>生成接口</p>
<p>单独把生成接口列出来，因为要做开原框架，接口的生成是重点</p>
<p>生成接口也没啥特别的，就是将类的生成稍微替换一下就好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void addInterfaceCase() &#123;</span><br><span class="line">        MethodSpec method = MethodSpec.methodBuilder(&quot;abstractFun&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">                .returns(void.class)</span><br><span class="line">                .addParameter(int.class, &quot;age&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        TypeSpec interfaceSpec = TypeSpec.interfaceBuilder(&quot;InterfaceTest&quot;)</span><br><span class="line">                .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                .addMethod(method)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, interfaceSpec)</span><br><span class="line">                .build();</span><br><span class="line">        try &#123;</span><br><span class="line">            javaFile.writeTo(mFiler);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface InterfaceTest &#123;</span><br><span class="line">  void abstractFun(int age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>高级用法的补充</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//高级用法补充</span><br><span class="line">  private void specialUse() &#123;</span><br><span class="line">   </span><br><span class="line">      MethodSpec methodImpl = MethodSpec.methodBuilder(&quot;abstractFun&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addAnnotation(Override.class)</span><br><span class="line">              .addParameter(int.class, &quot;age&quot;)</span><br><span class="line">              .addStatement(&quot;$T.out.println(\&quot;method implementation\&quot;)&quot;, System.class)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      //添加泛型</span><br><span class="line">      TypeVariableName typeVariableName = TypeVariableName.get(&quot;T&quot;);</span><br><span class="line">      //添加泛型方法</span><br><span class="line">      MethodSpec typeMethod = MethodSpec.methodBuilder(&quot;typeMethodCase&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .addParameter(typeVariableName, &quot;t&quot;)</span><br><span class="line">              .returns(typeVariableName)</span><br><span class="line">              .addStatement(&quot;return t&quot;)</span><br><span class="line">              .build();</span><br><span class="line">      //添加泛型约束型方法 extends 指定该泛型属于什么类型</span><br><span class="line">      TypeVariableName typeConstraint = TypeVariableName.get(&quot;U&quot;,ClassName.get(&quot;java.lang&quot;,&quot;Number&quot;));</span><br><span class="line">      MethodSpec typeConstraintMethod = MethodSpec.methodBuilder(&quot;typeConstraintMethod&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addTypeVariable(typeConstraint)</span><br><span class="line">              .build();</span><br><span class="line">      // 添加通配符 上限约束型 参数</span><br><span class="line">      TypeName typeExtends = WildcardTypeName.subtypeOf(ClassName.get(&quot;java.lang&quot;,&quot;Number&quot;));</span><br><span class="line">      TypeName parameterWithExtends = ParameterizedTypeName.get(ClassName.get(&quot;java.util&quot;,&quot;List&quot;),typeExtends);</span><br><span class="line">      MethodSpec typeConstraintMethod1 = MethodSpec.methodBuilder(&quot;typeConstraintMethod1&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addParameter(parameterWithExtends, &quot;list&quot;)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      //添加通配符 下限约束型 参数</span><br><span class="line">      TypeName typeExtends2 = WildcardTypeName.supertypeOf(ClassName.get(&quot;java.lang&quot;,&quot;Number&quot;));</span><br><span class="line">      TypeName parameterWithExtends2 = ParameterizedTypeName.get(ClassName.get(&quot;java.util&quot;,&quot;List&quot;),typeExtends2);</span><br><span class="line">      MethodSpec typeConstraintMethod2 = MethodSpec.methodBuilder(&quot;typeConstraintMethod2&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .returns(void.class)</span><br><span class="line">              .addParameter(parameterWithExtends2, &quot;list&quot;)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      TypeSpec implSpec = TypeSpec.classBuilder(&quot;InterfaceImpl&quot;)</span><br><span class="line">              .addModifiers(Modifier.PUBLIC)</span><br><span class="line">              .addSuperinterface(ClassName.get(PACKAGE_NAME,&quot;InterfaceTest&quot;)) //添加接口类型</span><br><span class="line">              .addTypeVariable(typeVariableName) //给类增加泛型，接口同理</span><br><span class="line">              .addMethod(methodImpl)</span><br><span class="line">              .addMethod(typeMethod)</span><br><span class="line">              .addMethod(typeConstraintMethod)</span><br><span class="line">              .addMethod(typeConstraintMethod1)</span><br><span class="line">              .addMethod(typeConstraintMethod2)</span><br><span class="line">              .build();</span><br><span class="line">   </span><br><span class="line">      JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, implSpec)</span><br><span class="line">              .build();</span><br><span class="line">      try &#123;</span><br><span class="line">          javaFile.writeTo(mFiler);</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>生成的类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class InterfaceImpl&lt;T&gt; implements InterfaceTest &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void abstractFun(int age) &#123;</span><br><span class="line">    System.out.println(&quot;method implementation&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public T typeMethodCase(T t) &#123;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public &lt;U extends Number&gt; void typeConstraintMethod() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void typeConstraintMethod1(List&lt;? extends Number&gt; list) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void typeConstraintMethod2(List&lt;? super Number&gt; list) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高级用法还有一些，这里写到快窒息了，剩余的也不难，把上述的吃透，剩余的就信手拈来好吧，另外也推荐上<a href="https://stackoverflow.com/questions/25926518/purpose-of-using-super-t-or-t-super-someclass-in-generics">stackoverflow</a>上查看javapoet的高级用法，有很多朋友提过问的，站在前人的肩膀上看问题，只能说很爽</p>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>这篇长文写到这里算是告一段落，官网还剩下一点点没有补充，可以自行前往查看，不过都是平时很少用到的了，其实发现，很难的是高级写法，比如涉及到泛型，还是多练为主吧</p>
</blockquote>
]]></content>
      <categories>
        <category>注解处理器与开源框架</category>
      </categories>
  </entry>
  <entry>
    <title>Android设计模式-MVC</title>
    <url>/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVC.html</url>
    <content><![CDATA[<h3 id="一-MVC概述"><a href="#一-MVC概述" class="headerlink" title="一.MVC概述"></a>一.MVC概述</h3><p>MVC是 <strong>Model(模型)-View(视图)-Controller(控制器)</strong>  的简写</p>
<ul>
<li>Model：数据模型-&gt;从现实生活中抽离的对象模型，封装了<strong>数据和对数据的操作</strong>，Kotlin中不仅仅局限于<strong>数据类</strong>，和数据有关的类以及操作类、接口都可称作Model</li>
<li>View：视图，提供应用和用户进行交互的接口，Android中主要指xml布局文件</li>
<li>Controller：负责View和Model之间的交互，处理逻辑，更新UI，在Android中指Activity或Fragment</li>
</ul>
<p><strong>三者间关系图</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/MVC.png"></p>
<h3 id="二-MVC实例演示"><a href="#二-MVC实例演示" class="headerlink" title="二.MVC实例演示"></a>二.MVC实例演示</h3><p>下面通过一个小demo对MVC设计模式进行诠释，效果如下：</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bookShow.gif" style="zoom:45%;" />

<h3 id="三-数据模型"><a href="#三-数据模型" class="headerlink" title="三.数据模型"></a>三.数据模型</h3><ol>
<li><p>分析数据模型</p>
<p>能直观感受到的模型是<strong>书</strong>，它包含两个书名和作者名两个信息，所以通过<code>data class Book(val bookName:String,val authorName:String)</code>数据类的形式进行封装，但对于大型项目来说，数据模型不仅仅只有这个</p>
</li>
<li><p>扩展常规思维的数据模型</p>
<p>如果将该小demo做成一个大项目，那么对数据的处理不仅仅只是更新UI，而应该将数据保存起来，存入数据库或者上传到服务器上，当我们需要数据时，又需要到数据库或网络中去加载，保存到本地，因此我们需要一个数据库(先以数据库存储为例)的操作类-<code>dataBase</code>以及本地仓库操作类-<code>BookRepository</code></p>
</li>
<li><p>抽离数据模型</p>
<p>在第二步中已经知道，需要增加数据库或者网络的操作类，而本地仓库会报存这两个类的对象，当我们需要对仓库中的数据进行操作时，其实是通过具体的(数据库或网络操作的)对象进行的，那么问题来了，如果使用者需要更换操作对象，那么就得找到具体的源码，更改仓库中保存的对象，并且拆卸很不方便，对于多人协作的项目来说，着实有些笨拙，那么我们便将具体对数据的存取操作封装成<strong>接口</strong>，操作类只需实现接口，仓库里保存该接口的对象即可，下面通过图来理解</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E7%A6%BB%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%9E%8B.png"></p>
</li>
</ol>
<p> 为了进一步方便使用者，将仓库的创建也抽离出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object BookProviderFactory &#123;</span><br><span class="line">    fun getBookRepository():BookRepository&#123;</span><br><span class="line">        val dao = dataBase.getInstance().bookdao</span><br><span class="line">        return BookRepository.getInstance(dao)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要更改获取数据的方式，只需找到该类，修改里面的<code>dao</code>即可，这样对数据操作类的拆卸变得相当简单了，这便是统一接口的好处</p>
<p><strong>具体源码请点击文末链接查看</strong></p>
<p>另外还用到了单例设计模式，此项目中采用java版本的懒汉式加载，但用Kotlin表示更加简洁，<a href="https://www.jianshu.com/p/26c43a48a23a">点击查看详情</a></p>
<h3 id="四-Controller"><a href="#四-Controller" class="headerlink" title="四.Controller"></a>四.Controller</h3><blockquote>
<p>此demo中，MainActivity作为<strong>Controller</strong>对数据和逻辑进行处理</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        submit.setOnClickListener &#123;</span><br><span class="line">            if (bookName.text.isEmpty())&#123;</span><br><span class="line">                Toast.makeText(this,&quot;书名不能为空！！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">                return@setOnClickListener</span><br><span class="line">            &#125;</span><br><span class="line">            if (athorName.text.isEmpty())&#123;</span><br><span class="line">                Toast.makeText(this,&quot;作者名不能为空！！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">                return@setOnClickListener</span><br><span class="line">            &#125;</span><br><span class="line">            //保存书本信息</span><br><span class="line">            val book = Book(bookName.text.toString(),athorName.text.toString())</span><br><span class="line">            //获取仓库对象</span><br><span class="line">            val repository = BookProviderFactory.getBookRepository()</span><br><span class="line">            repository.addBook(book,this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fun upDateUI(str:String)&#123;</span><br><span class="line">        content.text = str</span><br><span class="line">        bookName.setText(&quot;&quot;)</span><br><span class="line">        athorName.setText(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-数据处理-Model"><a href="#五-数据处理-Model" class="headerlink" title="五.数据处理-Model"></a>五.数据处理-Model</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BookRepository(private val dao: BookDao) &#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        @Volatile private var instance: BookRepository?=null</span><br><span class="line">        fun getInstance(dao: BookDao)= instance?: synchronized(this)&#123;</span><br><span class="line">            instance?: BookRepository(dao).also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fun getBooks():List&lt;Book&gt;&#123;</span><br><span class="line">        return dao.getBooks()</span><br><span class="line">    &#125;</span><br><span class="line">    fun addBook(book: Book,mainActivity: MainActivity)&#123;</span><br><span class="line">        dao.addBook(book)</span><br><span class="line">        val builder = StringBuilder()</span><br><span class="line">        getBooks().forEach &#123;book -&gt;</span><br><span class="line">            builder.append(&quot;$&#123;book.name&#125;-$&#123;book.author&#125; \n&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        mainActivity.upDateUI(builder.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码可以发现，MainActivity从View即XML中获取数据，监听View的点击事件，负责将数据传给Model进行处理，及时更新UI，完成View和Model之间的交互，其实从初学Android或者其他有UI界面的语言开始，我们就一直在用MVC的架构方式，太普遍了</p>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><ul>
<li>MVC的优点：将View(UI)、Controller(逻辑处理)、Model(数据模型以及处理)分隔开，功能划分很清楚，也容易掌握，使用简单</li>
<li>MVC的缺点：Controller中的代码过于冗杂，即负责管理UI，又负责传递数据以及逻辑业务的处理，所以当项目变大时，Controller中的代码迅速膨胀，不易管理，Activity或Fragment的负载将会很大，并且Model通过Controller与View间接挂钩，没有完全分离</li>
</ul>
<p><a href="https://gitee.com/wiwiyiyi/mvc-design-pattern">代码链接</a></p>
]]></content>
      <categories>
        <category>Android设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发中的协程使用</title>
    <url>/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h3 id="一-引入"><a href="#一-引入" class="headerlink" title="一.引入"></a>一.引入</h3><blockquote>
<p>我曾在Android开发涉及到网络操作时苦恼，因为网络操作不能在UI主线程里进行，所以关键问题是下载好的数据如何接收，通过函数返回值？显然不现实，因为函数的调用发生在UI主线程里，而下载数据在子线程，两者互不干扰，函数当然不会等数据下载好了之后才进行返回，这便涉及到线程之间的通信，本文核心讲解Kotlin中的协程，在此之前想先提一下java中线程通信的方式-Handler</p>
</blockquote>
<h3 id="二-Handler"><a href="#二-Handler" class="headerlink" title="二.Handler"></a>二.Handler</h3><p>在熟练协程之前，使用的是java中线程通信的方式-Handler，不得不说，Handler是真的很好用，使用很简单，并且能解决问题</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li><p>创建一个handler，并将其属性化，重写<code>handleMessage(msg: Message)</code>方法</p>
</li>
<li><p>如果进行网络加载的方法在其他类中，调用时需要传入一个<code>handler</code>对象，当数据下载完毕后，创建一个<code>Message</code>对象</p>
<ul>
<li>obj-&gt;保存带回的数据，可以是任意类型</li>
<li>what-&gt;用来标识返回的是什么类型的数据，不止一个线程需要返回数据时使用</li>
</ul>
</li>
<li><p>在<code>handleMessage</code>中根据其他线程发送的<code>msg</code>进行取数据</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object NetWorkUtils &#123;</span><br><span class="line">    const val TYPE_PIC = 1</span><br><span class="line">    const val TYPE_VIDE0 = 2</span><br><span class="line">    fun LoadPic(link:String,handler: Handler)&#123;</span><br><span class="line">        Thread &#123;</span><br><span class="line">            val url = URL(link)</span><br><span class="line">            val con = url.openConnection() as HttpURLConnection</span><br><span class="line">            con.doInput = true</span><br><span class="line">            val inputStream = url.openStream()</span><br><span class="line">            val bitmap = BitmapFactory.decodeStream(inputStream)</span><br><span class="line">            //创建消息</span><br><span class="line">            val msg = Message()</span><br><span class="line">            //带回数据</span><br><span class="line">            msg.obj = bitmap</span><br><span class="line">            //设置返回数据类型</span><br><span class="line">            msg.what = TYPE_PIC</span><br><span class="line">            //发送消息</span><br><span class="line">            handler.sendMessage(msg)</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    val handler = @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    object :Handler()&#123;</span><br><span class="line">        override fun handleMessage(msg: Message) &#123;</span><br><span class="line">            super.handleMessage(msg)</span><br><span class="line">            when(msg.what)&#123;</span><br><span class="line">                NetWorkUtils.TYPE_PIC-&gt;&#123;</span><br><span class="line">                    img.setImageBitmap(msg.obj as Bitmap)</span><br><span class="line">                &#125;</span><br><span class="line">                else-&gt;&#123;</span><br><span class="line">                    //返回的是视频数据</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        loadPic.setOnClickListener &#123;</span><br><span class="line">            val link =&quot;https://seopic.699pic.com/photo/50045/2756.jpg_wh1200.jpg&quot;</span><br><span class="line">            NetWorkUtils.LoadPic(link,handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后需要在Manifests中添加网络权限<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></p>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%8D%8F%E7%A8%8B/Handler.gif" style="zoom: 33%;" />

<blockquote>
<p>你会发现Handler的使用其实非常简单，并且能解决问题，如果要了解Handler的工作机制，还请自行百度</p>
</blockquote>
<h3 id="三-协程引入"><a href="#三-协程引入" class="headerlink" title="三.协程引入"></a>三.协程引入</h3><p>在学习Kotlin时已经详解了协程的基本使用，但那时由于没有合适的使用场景，所以看不到它的闪光点，而在Android开发中，首选<strong>Coroutine</strong>，协程在<strong>网络操作</strong>进行线程切换时相当方便，没有对比就没有伤害，先说说使用<strong>Handler</strong>不好的地方，在刚开始使用Handler时，确实觉得很香，毕竟理解和使用都很容易，但在实际写项目的过程中却发现相当繁琐，因为进行线程间通信的地方不止一处，一旦数量增加，很容易发生混乱，并且代码逻辑变得模糊，下面给出示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> fun loadStudent(id:String,handler: Handler)&#123;</span><br><span class="line">        Thread &#123;</span><br><span class="line">            val request = Request.Builder()</span><br><span class="line">                .url(&quot;http://10.129.26.231:8080/student/querybystudentid?studentid=$id&quot;)</span><br><span class="line">                .build()</span><br><span class="line">            val call = client.newCall(request)</span><br><span class="line">            call.enqueue(object :Callback&#123;</span><br><span class="line">                override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">                    mainActivity?.runOnUiThread &#123;</span><br><span class="line">                        mainActivity?.showMessage(&quot;网络连接超时！！&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                    val result = response.body?.string()</span><br><span class="line">                    val student = gson.fromJson(result, Array&lt;Student&gt;::class.java)</span><br><span class="line">                    val msg = Message()</span><br><span class="line">                    msg.what = Repository.MSG_TYPE_STUDENTINFOR</span><br><span class="line">                    msg.obj = student[0]</span><br><span class="line">                    handler.sendMessage(msg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line"> val handler = @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    object :Handler()&#123;</span><br><span class="line">        override fun handleMessage(msg: Message) &#123;</span><br><span class="line">            super.handleMessage(msg)</span><br><span class="line">            when(msg.what) &#123;</span><br><span class="line">                MSG_TYPE_STUDENTINFOR -&gt; studentInfor= msg.obj as Student</span><br><span class="line">                MSG_TYPE_SIGNTASKS -&gt;&#123;</span><br><span class="line">                    orgAttandenceInfors = msg.obj as Array&lt;AttendanceInfo&gt;</span><br><span class="line">                    convertAttandenceInfors()</span><br><span class="line">                &#125;</span><br><span class="line">                MSG_TYPE_LEAVEINFORS -&gt;studentLeaveInfors = msg.obj as Array&lt;LeaveInfor&gt;</span><br><span class="line">                MSG_TYPE_UPDATE_LEAVINFORS -&gt;&#123;</span><br><span class="line">                    studentLeaveInfors = msg.obj as Array&lt;LeaveInfor&gt;</span><br><span class="line">                    AllLeaveInforFragment.leaveAdapter.notifyDataSetChanged()</span><br><span class="line">                &#125;</span><br><span class="line">                MSG_TYPE_UPDATE_ALL_LEAVES-&gt;&#123;</span><br><span class="line">                    allStudentLeaves = msg.obj as Array&lt;LeaveInfor&gt;</span><br><span class="line">                    showLeaveFragment.allLeaveAdapter.notifyDataSetChanged()</span><br><span class="line">                &#125;</span><br><span class="line">                MSG_TYPE_NO_SIGNS_LIST -&gt;&#123;</span><br><span class="line">                    noSignStudentLists = msg.obj as Array&lt;AttendanceInfo&gt;</span><br><span class="line">                    LoadAnimationFragment.delayAnim.start()</span><br><span class="line">                    WelcomeActivity.isRestart = false</span><br><span class="line">                &#125;</span><br><span class="line">                MSG_TYPE_UPDATE_NOSIGN_LISTS-&gt;&#123;</span><br><span class="line">                    noSignStudentLists = msg.obj as Array&lt;AttendanceInfo&gt;</span><br><span class="line">                    showSignFragment.showSignAdapter.notifyDataSetChanged()</span><br><span class="line">                &#125;</span><br><span class="line">                MSG_TYPE_ALL_LEAVES -&gt;allStudentLeaves = msg.obj as Array&lt;LeaveInfor&gt;</span><br><span class="line">                MSG_TYPE_RELEASEATTENDANCE_TASK -&gt; &#123;</span><br><span class="line">                        releasedAttendancetask = msg.obj as Array&lt;releasedAttendanceTask&gt;</span><br><span class="line">                        NetWorkDao.loadNoSignStudents(this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码是在接触协程前写的一个小项目的局部，虽然对于一个需要进行通信的函数而言，传入一个<strong>Handler</strong>对象即可，但在UI主线程进行数据接收时变得相当复杂，一旦项目做大，Handler是绝对不能再用了，所以下面力荐使用协程<strong>Coroutine</strong></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/474adbdb9b5c">协程的基本知识点可以参考本链接</a></p>
<h3 id="四-协程在Android开发中的作用"><a href="#四-协程在Android开发中的作用" class="headerlink" title="四.协程在Android开发中的作用"></a>四.协程在Android开发中的作用</h3><p>首先强调一下协程和线程的区别，协程可以说是一种轻量级的线程，一个进程可以拥有多个线程，一个线程可以拥有多个协程，可以看出，协程是依附于线程的，所以开启一个协程时并不是开启了一个线程，由于协程的挂起机制<strong>suspend</strong>，你可以这样理解协程，将UI主线程想象成马路，如果某处发生交通事故，那么势必会阻塞主线程，此时通过开启协程将事故发生处(耗时任务)挂起，就是将发生事故的车辆悬空挂起，这样就不会影响主干的交通运行，而当发生事故的两辆车的车主解决好矛盾纠纷时(即耗时任务结束)，再将它们放下来，继续行驶在主干上，这样就完成了线程间的切换，当然你也可以根据自己的理解掌握协程的挂起以及切换机制</p>
<blockquote>
<p>线程是依赖于操作系统的，但协程仅由程序所决定，协程的挂起是一种函数，因此它的切换没有线程那样消耗大量内存</p>
</blockquote>
<ul>
<li><p>协程的挂起函数需要协程域-CoroutineScope，在Kotlin中有以下两种创造协程域的方式：</p>
<ol>
<li><p>GlobalScope.lauch</p>
<p>此方式创造的是全局的协程域，在Android中伴随着app运行的整个过程，不推荐，因为我们需要的是它能够伴随界面的生命周期</p>
</li>
<li><p>runBlocking</p>
<p>此方式会阻塞主线程，仅用于程序调试，在Android同样不推荐</p>
</li>
</ol>
</li>
<li><p>JetPack提供ViewModel以及LIveData都有自带的协程域，这才是项目中常用的方式</p>
</li>
<li><p>当然也可以通过代码的方式为一个Acitivity/Fragment自定义一个协程域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyFragment:Fragment() &#123;</span><br><span class="line">    private lateinit var scope:CoroutineScope</span><br><span class="line">    private val job:Job = Job()</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        scope = CoroutineScope( job + Dispatchers.Main)</span><br><span class="line">        //Dispatchers.Main用于标记此协程域附属于哪个线程，当耗时任务结束后会自动切回来</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onActivityCreated(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState)</span><br><span class="line">        scope.launch &#123; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方式需要注意协程域的需要伴随Acitvity/Fragment的生命周期</p>
<blockquote>
<p>有了协程域，我们便可以开启协程进行耗时的网络/文件操作任务，在协程域内可以自由的进行线程切换，只需切换到其他线程中执行耗时任务即可，切换线程使用<code>withContext(指定的其他线程)</code>，<code>withContext</code>会阻塞当前协程域，直到耗时任务结束，这一特性相当有用</p>
</blockquote>
</li>
</ul>
<h4 id="1-普通用法"><a href="#1-普通用法" class="headerlink" title="1.普通用法"></a>1.普通用法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var scope: CoroutineScope</span><br><span class="line">    private val job = Job()</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        scope = CoroutineScope(job+Dispatchers.Main)</span><br><span class="line">        load.setOnClickListener &#123;</span><br><span class="line">            scope.launch &#123;</span><br><span class="line">                val bitmap = withContext(Dispatchers.IO)&#123;</span><br><span class="line">                    val url = URL(&quot;http://img.kuai8.com/attaches/news/image/20131114/20131114102704_17481.jpg&quot;)</span><br><span class="line">                    val conn= url.openConnection() as HttpURLConnection</span><br><span class="line">                    BitmapFactory.decodeStream(url.openStream())</span><br><span class="line">                &#125;</span><br><span class="line">                //切换回来后在UI主线程中执行任务</span><br><span class="line">                imageView.setImageBitmap(bitmap)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDestroy() &#123;</span><br><span class="line">        super.onDestroy()</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%8D%8F%E7%A8%8B/%E7%BD%91%E7%BB%9C%E4%B8%8B%E8%BD%BD%E5%B1%95%E7%A4%BA.gif" style="zoom: 50%;" />

<h4 id="2-搭配JetPack中的ViewModel"><a href="#2-搭配JetPack中的ViewModel" class="headerlink" title="2.搭配JetPack中的ViewModel"></a>2.搭配JetPack中的ViewModel</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FirstPageViewModel:ViewModel() &#123;</span><br><span class="line">    var imgBitmap:MutableLiveData&lt;Bitmap&gt; = MutableLiveData()</span><br><span class="line">    fun loadImg()&#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            imgBitmap.value = withContext(Dispatchers.IO)&#123;</span><br><span class="line">             val url = URL(&quot;http://img.kuai8.com/attaches/news/image/20131114/20131114102704_17481.jpg&quot;)</span><br><span class="line">              val conn= url.openConnection() as HttpURLConnection</span><br><span class="line">                BitmapFactory.decodeStream(url.openStream())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        val viewModel = ViewModelProvider(this).get(FirstPageViewModel::class.java)</span><br><span class="line">        viewModel.imgBitmap.observe(this)&#123;</span><br><span class="line">            imageView.setImageBitmap(it)</span><br><span class="line">        &#125;</span><br><span class="line">        load.setOnClickListener &#123;</span><br><span class="line">            viewModel.loadImg()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-协程用法总结"><a href="#五-协程用法总结" class="headerlink" title="五.协程用法总结"></a>五.协程用法总结</h3><blockquote>
<p><code>withContext</code>就类似于开启了一个新的线程，只不过其本质是将耗时任务切换到其他线程上去执行，由于其具有阻塞性，即在<strong>同一个协程域中任务的执行是单向的，不会并发</strong>，只有当A任务执行完毕后才会执行其后的B任务，这点特性相当重要，当然只会阻塞协程域，并不会阻塞UI主线程，而外层协程域是附属于主线程的，切回来时会自动在主线程中执行任务，另外一点，<code>withContext</code>代码块最后一句话可作为返回值</p>
</blockquote>
<p><strong>相信通过以上对比，发现协程是真的很方便，特别是在MVVM设计模式中，今后会通过项目进行展示</strong></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Android设计模式-MVVM搭配LiveData的使用</title>
    <url>/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVVM.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><p>在熟悉了MVC和MVP两种设计模式后，你可能会迷茫到底使用哪种，并且两种都有优缺点，实在难以决策，本文将介绍MVVM架构模式，相信看完本文后，你将会喜欢上MVVM的架构方式</p>
<h3 id="二-MVVM概述"><a href="#二-MVVM概述" class="headerlink" title="二.MVVM概述"></a>二.MVVM概述</h3><p>MVVM是 <strong>Model</strong>(数据模型)-<strong>View</strong>(视图)-<strong>ViewModel</strong>(视图模型)的简称</p>
<ul>
<li>View在此处指XML布局文件</li>
<li>将View与ViewModel进行关联主要是用于保存View中的数据，比如界面旋转导致Activity重构</li>
<li>ViewModel可以感知Activity的生命周期，既可以保存View中的数据，又不会让数据的生命周期过长</li>
</ul>
<p>下面先演示ViewModel的使用，然后再讲解ViewModel搭配LiveData，目的是减少Activity中的逻辑以及和View的数据交互，达到减轻Activity/Fragment的负担</p>
<h3 id="三-ViewModel的使用"><a href="#三-ViewModel的使用" class="headerlink" title="三.ViewModel的使用"></a>三.ViewModel的使用</h3><ol>
<li><p>添加依赖</p>
<p>ViewModel是JetPack组件，使用得在app模块中添加如下依赖</p>
<p><code> def lifecycle_version = &quot;2.2.0&quot;  implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/viewModel%E4%BE%9D%E8%B5%96.png" style="zoom: 50%;" /></li>
<li><p>创建一个类继承ViewModel，并添加一个与XML中关联的一个变量用于保存数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyViewModel:ViewModel() &#123;</span><br><span class="line">    var content:String = &quot;Android开发&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Activity/Fragment中通过<code>ViewProvider</code>加载<code>MyViewModel</code>的一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val viewModel = ViewModelProvider(this).get(MyViewModel::class.java)</span><br></pre></td></tr></table></figure></li>
<li><p>将ViewModel中的数据和View进行绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showText.text = viewModel.content</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>经过上面的步骤发现，通过一个ViewModel保存View中的数据(即绑定)，Activity/Fragment中只需处理逻辑业务</p>
</blockquote>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ViewModelShow.gif" style="zoom: 33%;" />

<p>可以看到当屏幕旋转后，View(XML)中的数据依旧还在，而不需要像之前那样在Activity销毁之前通过<strong>Bundle</strong>对象将值保存起来，再在Activity创建时取出来展示到界面上</p>
<h3 id="四-自定义Factory"><a href="#四-自定义Factory" class="headerlink" title="四.自定义Factory"></a>四.自定义Factory</h3><p>有些时候，我们希望在创建ViewModel对象的时候，传入一些参数，但根据上面的反射创建对象是无法传参数的，这时我们需要自定义Factory继承真正在创建ViewModel对象的<code>NewInstanceFactory</code>，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ViewModelProviderFactory:ViewModelProvider.NewInstanceFactory() &#123;</span><br><span class="line">    override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        return MyViewModel(&quot;指尖上的工程师&quot;) as T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val viewModel = ViewModelProvider(this,ViewModelProviderFactory()).get(MyViewModel::class.java)</span><br></pre></td></tr></table></figure>

<p>在创建<code>ViewModel</code>时只需要把自定义的工厂类传入即可</p>
<h3 id="五-LiveData"><a href="#五-LiveData" class="headerlink" title="五.LiveData"></a>五.LiveData</h3><blockquote>
<p>MVVM的灵魂是将LiveData和ViewModel相结合，这样才能真正减轻Activity/Fragment的逻辑业务和数据处理的负担</p>
</blockquote>
<ol>
<li><p>首先在app模块中添加依赖</p>
<p><code>implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&quot;</code></p>
</li>
<li><p>在ViewModel创建<code>MutableLiveData</code>类型的变量</p>
<p>①存值</p>
<p>②监听值的改变</p>
</li>
<li><p>给<code>MutableLiveData</code>设置监听事件，这也是标准的监听者模式</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyViewModel():ViewModel() &#123;</span><br><span class="line">    var content:MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">    var name:MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">&#125;</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        val viewModel = ViewModelProvider(this).get(MyViewModel::class.java)</span><br><span class="line">        viewModel.content.observe(this)&#123;</span><br><span class="line">            showText.text = it</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.name.observe(this)&#123;</span><br><span class="line">            //具体操作</span><br><span class="line">        &#125;</span><br><span class="line">        convert.setOnClickListener &#123;</span><br><span class="line">            viewModel.content.value = &quot;我爱Android&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：一个界面中的元素很多，所以很多值都是活的，因此ViewModel中<code>MutableLiveData</code>的数量可以很多</p>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><blockquote>
<p>将LiveData和ViewModel结合后，Activity/Fragment不用直接操纵View，确实减轻了不少负担，并且还减少了很多事件回调，只能说MVVM真的很香</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/android-design-pattern-mvvm">代码链接</a></p>
]]></content>
      <categories>
        <category>Android设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Android设计模式-MVP</title>
    <url>/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVP.html</url>
    <content><![CDATA[<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h3><p>有了MVC的基础，理解MVP变得相对容易，MVP的出现是为了让三个板块完全分离，功能的分块更加清晰</p>
<p>MVP的全称是：Model(数据模型)-View(视图)-Presenter(中间处理者)</p>
<p>与MVC不同的之处：</p>
<ol>
<li>View(视图层)：将XML和Activity/Fragment统称为View，负责UI交互的部分</li>
<li>Presenter：处理逻辑业务以及和Model之间的数据交互</li>
</ol>
<p><strong>关系图如下</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/MVP%E5%9B%BE%E8%A7%A3.png" style="zoom:66%;" />

<h3 id="二-通过接口解决Presenter和View之间的鸿沟"><a href="#二-通过接口解决Presenter和View之间的鸿沟" class="headerlink" title="二.通过接口解决Presenter和View之间的鸿沟"></a>二.通过接口解决Presenter和View之间的鸿沟</h3><p>根据上图，View中接收到用户的输入事件后，需要通过Presenter进行逻辑处理和数据传递，因此View(即Activity)中需要保存一个Presenter的对象，但这还不够，因为activity并不知道Presenter中到底有什么方法对View中的数据进行处理，所以我们需要统一接口，还有一个好处就是，更改方法直接在接口中进行增删改即可，操作简单，同理，Presenter从Model中获取到数据后，需要更新UI，同样也需要View对应的一个接口对象，所以每增加一个视图，接口的数量会成倍增长，这也是MVP繁琐的地方</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/MVP%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.png" style="zoom:67%;" />

<p>数据模型和MVC中基本没什么变化</p>
<h3 id="三-接口的具体设计"><a href="#三-接口的具体设计" class="headerlink" title="三.接口的具体设计"></a>三.接口的具体设计</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IBookPresenter &#123;</span><br><span class="line">    fun checkInput(content1:String,content2:String)</span><br><span class="line">    fun addBook(book: Book)</span><br><span class="line">&#125;</span><br><span class="line">interface IBookView &#123;</span><br><span class="line">    fun inputIsValid(valid:Boolean)</span><br><span class="line">    fun showBooks(book:List&lt;Book&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Presenter和View都有对应的接口，在设计时只需单独考虑他们各自需要提供什么方法给对方进行逻辑处理以及界面刷新，让具体的Preseter和View类实现各自的接口以及里面的方法即可，这样就实现了Model和View的完全分离，各个板块分离很清晰</p>
<h3 id="四-强调数据模型层抽离出接口的重要性"><a href="#四-强调数据模型层抽离出接口的重要性" class="headerlink" title="四.强调数据模型层抽离出接口的重要性"></a>四.强调数据模型层抽离出接口的重要性</h3><p>在本次MVP的架构中，数据的获取采取模拟网络的方式，所以仓库中获取数据的途径得改变，下面通过代码来展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object BookProviderFactory &#123;</span><br><span class="line">    fun getBookRepository():BookRepository&#123;</span><br><span class="line">        val dao = netWork.getInstance().bookdao</span><br><span class="line">        return BookRepository.getInstance(dao)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E6%8A%BD%E7%A6%BB.jpg"></p>
<p>可以看到只需要在仓库提供类里面稍微修改一下类名即可，将<code>dataBase</code>换成了<code>netWork</code>，相当轻松，NetWork包下的创建和dataBase类似，因此在考虑数据模型层中数据的获取方式时，不能将其写死，而应该抽离成接口的方式，统一方法，在数据提供类里面拆卸会变得很容易，不仅方便个人，也方便和你合作的人</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><p>MVP虽然解决了MVC分离不够彻底的缺点，但它却增加了接口，增加了类，代码量也会快速膨胀，写起来很不方便</p>
<p><a href="https://gitee.com/wiwiyiyi/android-design-pattern-mvp">代码链接</a></p>
]]></content>
      <categories>
        <category>Android设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Android轻架构DataBinding</title>
    <url>/Android%E8%BD%BB%E6%9E%B6%E6%9E%84DataBinding.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面已经学习了MVVM设计模式，以及ViewModel搭配LiveData的使用减轻Activity/Fragment的负担，本篇文章将介绍JetPack架构系列中的DataBinding进一步让Activity/Fragment中的代码更加简洁</p>
</blockquote>
<h3 id="二-DataBinding简介"><a href="#二-DataBinding简介" class="headerlink" title="二.DataBinding简介"></a>二.DataBinding简介</h3><p>在Android实际开发中，我们还是习惯用<code>findViewbyId</code>或者直接通过控件的<code>id</code>获取到控件的引用对象，<strong>前者无疑会让  Activity/Fragment中的代码变得相当冗杂</strong>，特别是控件变得很多时，后者虽然使用方便，但有的时候会出错，<strong>比如两个界面不小心设置了相同的id值，那么在访问使用时肯定会报错，这样是不安全的</strong>，所以JetPack推出了DataBinding对一个界面即Activity/Fragment管理属于它的所有控件，这样既不会让代码膨胀，也保证了使用安全，确实不错。除此之外，它还可搭配ViewModel和LiveData将数据回绑到界面XML布局文件中，并且实时更新界面数据，当然这只适合界面中的部分数据，但也减轻了控制器的负担，下面通过一张图来展示使用DataBinding后的轻架构</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dataBinding%E7%BB%91%E5%AE%9A%E8%A7%86%E5%9B%BE.png" style="zoom:50%;" />

<h3 id="三-DataBinding具体使用"><a href="#三-DataBinding具体使用" class="headerlink" title="三.DataBinding具体使用"></a>三.DataBinding具体使用</h3><ol>
<li><p>创建ViewModel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    private var number: MutableLiveData&lt;Int&gt; = MutableLiveData()</span><br><span class="line">    init &#123;</span><br><span class="line">        if (number.value == null) &#123;</span><br><span class="line">            number.value = 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fun getNumber() = number</span><br><span class="line">    fun add(num: Int) &#123;</span><br><span class="line">        number.value = number.value!!.plus(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在app模块对应的gradle添加如下一句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 30</span><br><span class="line">    buildToolsVersion &quot;29.0.3&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;swu.cx.databindingtest&quot;</span><br><span class="line">        minSdkVersion 19</span><br><span class="line">        targetSdkVersion 30</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">        vectorDrawables&#123;</span><br><span class="line">            useSupportLibrary = true</span><br><span class="line">        &#125;</span><br><span class="line">        //添加此处，以支持使用DataBinding</span><br><span class="line">        dataBinding&#123;</span><br><span class="line">            enabled = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#x27;proguard-android-optimize.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>按照如下步骤调整XML格式</p>
<ol>
<li>鼠标右键</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%AD%A5%E9%AA%A41.png"></p>
<ol start="2">
<li><p>点击调整格式</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%AD%A5%E9%AA%A42.png"></p>
</li>
</ol>
</li>
<li><p>在Activity/Fragment中加载DataBinding的对象</p>
<p>每个Activity/Fragment都会自动生成一个DataBinding的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private lateinit var binding: ActivityMainBinding</span><br><span class="line">binding = DataBindingUtil.setContentView(this,R.layout.activity_main)</span><br></pre></td></tr></table></figure>

<p>通过以上代码就成功将视图中的控件绑定在binding对象中<code>binding.textView.setText()</code>，这样就能访问控件</p>
</li>
<li><p>在XML中的&lt;data&gt;标签中定义变量，用于数据回绑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;data&quot;</span><br><span class="line">            type=&quot;swu.cx.databindingtest.MyViewModel&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/textView&quot;</span><br><span class="line">            android:layout_width=&quot;127dp&quot;</span><br><span class="line">            android:layout_height=&quot;44dp&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;@&#123;String.valueOf(data.number)&#125;&quot;</span><br><span class="line">            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintVertical_bias=&quot;0.253&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageButton</span><br><span class="line">            android:id=&quot;@+id/up&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginTop=&quot;128dp&quot;</span><br><span class="line">            app:layout_constraintEnd_toStartOf=&quot;@+id/down&quot;</span><br><span class="line">            app:layout_constraintHorizontal_bias=&quot;0.5&quot;</span><br><span class="line">            app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintTop_toBottomOf=&quot;@+id/textView&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;()-&gt;data.add(1)&#125;&quot;</span><br><span class="line">            app:srcCompat=&quot;@drawable/ic_baseline_thumb_up_24&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageButton</span><br><span class="line">            android:id=&quot;@+id/down&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">            app:layout_constraintHorizontal_bias=&quot;0.5&quot;</span><br><span class="line">            app:layout_constraintStart_toEndOf=&quot;@+id/up&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;@+id/up&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;()-&gt;data.add(-1)&#125;&quot;</span><br><span class="line">            app:srcCompat=&quot;@drawable/ic_baseline_thumb_down_24&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<p><strong>用@{}包裹代码，()-&gt;表示调用函数</strong></p>
</li>
<li><p>在Activity/Fragment中设置data，并监听data的数据变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binding.data = viewModel</span><br><span class="line">binding.lifecycleOwner = this</span><br></pre></td></tr></table></figure>

<p><strong>效果图如下</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dataBinding%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif" style="zoom: 80%;" /></li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>可能你现在还习惯用id直接访问控件对象，但在写大型项目时还是考虑使用DataBinding统一管理一个界面中的控件，另外界面中一些简单值的变化还可回绑到界面中，减少Activity/Fragment中的逻辑，是一个不错的选择，轻架构。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>CoordinatorLayout原理分析以及自定义Behavior入门</title>
    <url>/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Behavior%E5%85%A5%E9%97%A8.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面有整理过MD的用法，想要实现高级的效果，那还是得自定义，现在很多App都会使用到CoordinatorLayout来实现滚动关联的炫酷效果，至少体验感很好，下面会先从原理开始探讨，然后体验简单的自定义效果</p>
</blockquote>
<h3 id="二-CoordinatorLayout协调的原理分析"><a href="#二-CoordinatorLayout协调的原理分析" class="headerlink" title="二.CoordinatorLayout协调的原理分析"></a>二.CoordinatorLayout协调的原理分析</h3><p>CoordinatorLayout是建立在NestedScrolling机制的基础上的，但是NestedScroling仅限于父View和子View之间的交互，不能实现子View之间的交互效果，可以说CoordinatorLayout是兼容NestedScroling机制的</p>
<p>分析原理前，先过一遍View的生命周期</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/View%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" style="zoom:50%;" />

<ul>
<li>addView是添加到content区域</li>
<li>整个页面的层级是：activity-&gt;window-&gt;view</li>
<li>attach之后会触发makeVisible方法，setView之后会通过WMS开始绘制</li>
</ul>
<p>所以onAttachedToWindow是开始，那么CoordinatorLayout源码分析也是从此开始</p>
<ol>
<li><p>通过ViewTreeObserver添加绘制监听</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%861.png" style="zoom:33%;" /></li>
<li><p>开始绘制时，回调到<code>onPredraw</code>方法，进而调用<code>onChildViewsChanged</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">         final View child = mDependencySortedChildren.get(i);</span><br><span class="line">         final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">			//...省略部分代码</span><br><span class="line">         // Update any behavior-dependent views for the change</span><br><span class="line">         for (int j = i + 1; j &lt; childCount; j++) &#123;</span><br><span class="line">             final View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">             final LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">             final Behavior b = checkLp.getBehavior();</span><br><span class="line">   </span><br><span class="line">             if (b != null &amp;&amp; b.layoutDependsOn(this, checkChild, child)) &#123;</span><br><span class="line">                 if (type == EVENT_PRE_DRAW &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                     // If this is from a pre-draw and we have already been changed</span><br><span class="line">                     // from a nested scroll, skip the dispatch and reset the flag</span><br><span class="line">                     checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">   </span><br><span class="line">                 final boolean handled;</span><br><span class="line">                 switch (type) &#123;</span><br><span class="line">                     case EVENT_VIEW_REMOVED:</span><br><span class="line">                         // EVENT_VIEW_REMOVED means that we need to dispatch</span><br><span class="line">                         // onDependentViewRemoved() instead</span><br><span class="line">                         b.onDependentViewRemoved(this, checkChild, child);</span><br><span class="line">                         handled = true;</span><br><span class="line">                         break;</span><br><span class="line">                     default:</span><br><span class="line">                         // Otherwise we dispatch onDependentViewChanged()</span><br><span class="line">                         handled = b.onDependentViewChanged(this, checkChild, child);</span><br><span class="line">                         break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>省略了开头部分代码，此处的核心就是两层for循环，第二层是寻找依赖第一层for循环中定下的child，所以第一层是dependency(被依赖)，第二层是依赖方，如果存在依赖关系就通过behavior做更新逻辑的处理，switch里面有两种情况，一是dependency被移除时，二是默认情况下的视图更新(dependency改变时)</p>
</li>
<li><p>现在还有一个问题，mDependencySortedChildren是在什么时候初始化的，这个就得到onMeasure里面去看了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void prepareChildren() &#123;</span><br><span class="line">        mDependencySortedChildren.clear();</span><br><span class="line">        mChildDag.clear();</span><br><span class="line"></span><br><span class="line">        for (int i = 0, count = getChildCount(); i &lt; count; i++) &#123;</span><br><span class="line">            final View view = getChildAt(i);</span><br><span class="line"></span><br><span class="line">            final LayoutParams lp = getResolvedLayoutParams(view);</span><br><span class="line">            lp.findAnchorView(this, view);</span><br><span class="line"></span><br><span class="line">            mChildDag.addNode(view);</span><br><span class="line"></span><br><span class="line">            // Now iterate again over the other children, adding any dependencies to the graph</span><br><span class="line">            for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">                if (j == i) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                final View other = getChildAt(j);</span><br><span class="line">                if (lp.dependsOn(this, view, other)) &#123;</span><br><span class="line">                    if (!mChildDag.contains(other)) &#123;</span><br><span class="line">                        // Make sure that the other node is added</span><br><span class="line">                        mChildDag.addNode(other);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Now add the dependency to the graph</span><br><span class="line">                    mChildDag.addEdge(other, view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally add the sorted graph list to our list</span><br><span class="line">        mDependencySortedChildren.addAll(mChildDag.getSortedList());</span><br><span class="line">        // We also need to reverse the result since we want the start of the list to contain</span><br><span class="line">        // Views which have no dependencies, then dependent views after that</span><br><span class="line">        Collections.reverse(mDependencySortedChildren);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在onMeasure开始时调用<code>prepareChildren</code>方法进行收集CoordinatorLayout<strong>直接子View之间</strong>的依赖关系，看到这种依赖关系肯定是通过图来管理的，邻接矩阵是常用方式，这里深究的话，用的是dfs深度优先，再看就有点秃头了，这里主要是理解流程，可以看到，这里添加的顺序是(依赖方,dependency)的元组方式，显然我们得将它们反转，拿到dependency后再去遍历和它又依赖关系的View，这里还是很好理解的</p>
</li>
<li><p>有了2和3两步其实对它的原理也是蛮清晰的了，当dependency改变时一定会触发重绘，一旦重绘就会调用<code>onChildViewsChanged</code></p>
<p>去更新和它有依赖关系的View，而具体的更新操作，自然是在Behavior里面了，下面会进行一个小示例的展示来体现更新逻辑</p>
</li>
<li><p>此外，还得研究一下怎么监听到dependency被移除的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/coor%E5%8E%9F%E7%90%862.png" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class HierarchyChangeListener implements OnHierarchyChangeListener &#123;</span><br><span class="line">        HierarchyChangeListener() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChildViewAdded(View parent, View child) &#123;</span><br><span class="line">            if (mOnHierarchyChangeListener != null) &#123;</span><br><span class="line">                mOnHierarchyChangeListener.onChildViewAdded(parent, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChildViewRemoved(View parent, View child) &#123;</span><br><span class="line">            onChildViewsChanged(EVENT_VIEW_REMOVED);</span><br><span class="line"></span><br><span class="line">            if (mOnHierarchyChangeListener != null) &#123;</span><br><span class="line">                mOnHierarchyChangeListener.onChildViewRemoved(parent, child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中设置了监听，所以视图被移除时可以感知到</p>
</li>
</ol>
<h3 id="三-自定义Behavoir入门实战"><a href="#三-自定义Behavoir入门实战" class="headerlink" title="三.自定义Behavoir入门实战"></a>三.自定义Behavoir入门实战</h3><blockquote>
<p>上面的分析大致缕清了CoordinatorLayout的工作原理，下面通过一个小例子来体验一下自定义Behavior实现的效果</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95behavoir%E7%A4%BA%E4%BE%8B.gif" style="zoom:50%;" />

<p>可以看到这个简单例子就很形象的展示了当dependency改变时，其他和它关联的子View的行为改变，这里代码比较简单，直接贴上对应的Behavior</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 颜色改变的behavior</span><br><span class="line">class ChangeColorBehavior @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;TextView&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    private val mArgbEvaluator = ArgbEvaluator()</span><br><span class="line"></span><br><span class="line">    override fun layoutDependsOn(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        return dependency is DefineDragView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;ResourceAsColor&quot;)</span><br><span class="line">    override fun onDependentViewChanged(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        val color = mArgbEvaluator.evaluate(dependency.y / parent.height, Color.WHITE, Color.BLACK) as Int</span><br><span class="line">        child.setTextColor(color)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 跟随dependency的behavior</span><br><span class="line">class ChildFollowBehavior@JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : CoordinatorLayout.Behavior&lt;TextView&gt;() &#123;</span><br><span class="line">    override fun layoutDependsOn(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        return dependency is DefineDragView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDependentViewChanged(</span><br><span class="line">        parent: CoordinatorLayout,</span><br><span class="line">        child: TextView,</span><br><span class="line">        dependency: View</span><br><span class="line">    ): Boolean &#123;</span><br><span class="line">        child.y = (dependency.bottom + 50).toFloat()</span><br><span class="line">        child.x = dependency.x</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，这里必须重写的两个方法，<code>layoutDependsOn</code>用于筛选是否具有依赖关系，<code>onDependentViewChanged</code>用于做dependency改变的更新逻辑，其实在上述分析源码流程时就有看到这两个方法的身影</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>到这里，其实CoordinatorLayout的高级用法已经结束了，就是理解透它的协调流程，子View之间是如何联动的，下面进行两个问题的总结</p>
</blockquote>
<ol>
<li>使用behavior的View必须是CoordinatorLayout的直接子View，因为收集时并不是递归形式的查找</li>
<li>NestedScrolling机制的View不一定是直接子View，因为会递归查找，CoordinatorLayout实现了NestedScrollingParent系列接口</li>
</ol>
<p>后续会在项目实战中推出比较高级的自定义Behavior，这里只是一个入门，这里还有一个小坑，自定义的Behavior必须提供类似上述的构造函数，盲猜是需要第二个参数，因为在xml中使用，另外就是最好用类的全称，否则会抛异常</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/75f23d632ae87b1100e0a575f9f45c6dc6747510">代码链接</a></p>
]]></content>
      <categories>
        <category>Android UI系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Dagger&amp;&amp;Hilt实现依赖注入</title>
    <url>/Dagger-Hilt%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>关于依赖注入部分小编也是刚上手，其实在日常项目的开发中我们经常会使用到依赖注入，但是很多时候我们的原生方式效率不高，代码量过大，导致结构不清晰，因为依赖注入这部分代码其实不是核心部分，不影响整体结构，所以我们应该尽量让它们变得简洁，因此我们会选用Dagger或Hilt的依赖注入库来实现这部分功能，让代码更加灵活</p>
</blockquote>
<h3 id="二-什么是依赖注入"><a href="#二-什么是依赖注入" class="headerlink" title="二.什么是依赖注入"></a>二.什么是依赖注入</h3><blockquote>
<p>依赖注入，说白了就是从其他地方获取到你需要的对象，下面通过两个小例子来进行展示</p>
</blockquote>
<ol>
<li><p>通过参数传递实现注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass constructor(val user: User) &#123;&#125;</span><br><span class="line">data class User(id:Int,name:String)</span><br></pre></td></tr></table></figure></li>
<li><p>通过函数(代码块)实现注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object UserProvideFactory &#123;</span><br><span class="line">    fun getUser() = User(1,&quot;cx&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fun main()&#123;</span><br><span class="line">    val user = UserProvideFactory.getUser()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当然了，方式有很多，比如还有set方法、使用接口等，对于上述两种方式，对于Kotlin来说还好，比较简洁，但是代码量也是有的，例如第二种方式需要提供一个工厂类进行管理这类似的所有方法，对于庞大的项目来说，这种代码是没有任何意义的，下面通过开源工具进行简化</p>
<h3 id="三-Dagger实现依赖注入"><a href="#三-Dagger实现依赖注入" class="headerlink" title="三.Dagger实现依赖注入"></a>三.Dagger实现依赖注入</h3><blockquote>
<p>Hilt是在Dagger的基础上做了一层封装，解决了Dagger一些比较繁琐的代码问题，所以我们先从从Dagger进行了解</p>
</blockquote>
<ol>
<li><p>添加依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;kotlin-kapt&#x27;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;com.google.dagger:dagger:2.x&#x27;</span><br><span class="line">    kapt &#x27;com.google.dagger:dagger-compiler:2.x&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建提供依赖的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class User @Inject constructor()&#123;</span><br><span class="line"> override fun toString(): String &#123;</span><br><span class="line">    return &quot;hello my name is cx&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建使用依赖对象的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    @Inject lateinit var user: User</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">         Log.v(&quot;cx&quot;,&quot;用户的信息是：$user&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建依赖注入组件</p>
<p>到这一步，依赖项的提供方和需求方都有了，只需要第三者将提供方的数据注入到需求方即可，就像医生(依赖注入组件)将药品(依赖提供方)注射到患者(依赖需求方)体内即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">interface Maincomponent &#123;</span><br><span class="line">    fun inject(activity: MainActivity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的实现是在编译时系统帮我们完成的，会生成对应的一个子类DaggerMaincompnent(根据命名来拼接的)</p>
</li>
<li><p>最后在使用时完成注入，即调用inject方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DaggerMainComponent.builder()</span><br><span class="line">    .build()</span><br><span class="line">    .inject(this)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>以上步骤完成了没有参数的依赖注入，显然在实际开发中User是需要传入参数的，@Inject注解只能提供无参的依赖项，如果要提供有参的依赖项需要自定义依赖提供方</strong></p>
<h3 id="四-Dagger的进阶使用"><a href="#四-Dagger的进阶使用" class="headerlink" title="四.Dagger的进阶使用"></a>四.Dagger的进阶使用</h3><ol>
<li><p>自定义有参的依赖提供方</p>
<p>使用<code>@Module</code>注解定义提供方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">class MainUserModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    fun provideUser() = User(1,&quot;cx&quot;)</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">class User (val id:Int,val name:String)&#123;</span><br><span class="line">    override fun toString(): kotlin.String &#123;</span><br><span class="line">        return &quot;(id:$id-name:$name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Component关联依赖提供方Module</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component(modules = [MainUserModule::class])</span><br><span class="line">interface MainComponent &#123;</span><br><span class="line">    fun inject(activity:MainActivity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用同无参数时相同</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/module%E8%87%AA%E5%AE%9A%E4%B9%89.png"></p>
</li>
<li><p>@Name注解的使用</p>
<p>如果你需要注入不同的User，此时你必须对它们进行分类，标识</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    @Named(&quot;xw&quot;)</span><br><span class="line">    @Provides</span><br><span class="line">    public User getUser1()&#123;</span><br><span class="line">        return new User(1,&quot;小王&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Named(&quot;xl&quot;)</span><br><span class="line">    @Provides</span><br><span class="line">    public User getUser2()&#123;</span><br><span class="line">        return new User(2,&quot;小李&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">MainActivity中使用</span><br><span class="line">@Named(&quot;xw&quot;)</span><br><span class="line">    @Inject</span><br><span class="line">    User xw;</span><br><span class="line"></span><br><span class="line">    @Named(&quot;xl&quot;)</span><br><span class="line">    @Inject</span><br><span class="line">    User xl;</span><br></pre></td></tr></table></figure>

<p><strong>注：此处我使用的是java版本，相同的代码Kotlin会编译出错，目前原因未知</strong></p>
</li>
<li><p>@Qualifier</p>
<p>@Name注解是建立在@Qualifier的基础上实现的，但Name注解需要传入字符串容易写错，所以很多时候还是优先考虑使用Qualifier自定义标识符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Qualifier</span><br><span class="line">@Retention(AnnotationRetention.RUNTIME)</span><br><span class="line">annotation class QualifierXW</span><br><span class="line"></span><br><span class="line">@Qualifier</span><br><span class="line">@Retention(AnnotationRetention.RUNTIME)</span><br><span class="line">annotation class QualifierXL</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@QualifierXW</span><br><span class="line">    @Provides</span><br><span class="line">    fun getUser1() = User(1,&quot;小王&quot;)</span><br><span class="line"></span><br><span class="line">    @QualifierXL</span><br><span class="line">    @Provides</span><br><span class="line">    fun getUser2() = User(1,&quot;小李&quot;)</span><br></pre></td></tr></table></figure></li>
<li><p>@Singleton实现单例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Module</span><br><span class="line">class SingleUserModule &#123;</span><br><span class="line">    @Singleton</span><br><span class="line">    @Provides</span><br><span class="line">    fun getSingleInstance() = User(4,&quot;Unique&quot;)</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@Singleton</span><br><span class="line">@Component(modules = [SingleUserModule::class])</span><br><span class="line">interface SingleComponent &#123;</span><br><span class="line">    fun inject(activity: MainActivity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来注入的对象都会是同一个</p>
<p>另外也可以使用自定义的@Scope(即自定义作用域)来实现单例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@MustBeDocumented</span><br><span class="line">@Retention(value = AnnotationRetention.RUNTIME)</span><br><span class="line">annotation class MyCustomScope</span><br></pre></td></tr></table></figure>

<p>然后在依赖项提供源和依赖项提供者之间使用该注解就会注入同一对象，和使用@Singleton方式一样</p>
</li>
</ol>
<h3 id="四-Hilt实现依赖注入"><a href="#四-Hilt实现依赖注入" class="headerlink" title="四.Hilt实现依赖注入"></a>四.Hilt实现依赖注入</h3><p>在了解了Dagger实现依赖注入后，再来学Hilt会很轻松，通过以上的步骤，发现Dagger其实使用有点繁琐，在Activity中也有类似于手动注入的代码，不够简洁，而Hilt便解决了这个问题</p>
<ol>
<li><p>添加配置</p>
<p>1⃣️将 <code>hilt-android-gradle-plugin</code> 插件添加到项目的根级 <code>build.gradle</code> 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath &#x27;com.google.dagger:hilt-android-gradle-plugin:2.28-alpha&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2⃣️应用 Gradle 插件并在 <code>app/build.gradle</code> 文件中添加以下依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply plugin: &#x27;kotlin-kapt&#x27;</span><br><span class="line">apply plugin: &#x27;dagger.hilt.android.plugin&#x27;</span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;</span><br><span class="line">    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3⃣️Hilt 使用 <a href="https://developer.android.com/studio/write/java8-support?hl=zh-cn">Java 8 功能</a>。如需在项目中启用 Java 8，请将以下代码添加到 <code>app/build.gradle</code> 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@HiltAndroidApp定义Hilt应用类，该注解会触发Hilt的代码生成操作，该基类充当应用级依赖项容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@HiltAndroidApp</span><br><span class="line">class MyApp :Application()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在Manifest文件中进行配置</p>
</li>
<li><p>@AndroidEntryPoint将依赖项注入 Android 类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@AndroidEntryPoint</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义数据类，通过@Inject实现注入，和Dagger的用法相同，不过此种方式不能用于传参的构造函数</p>
</li>
<li><p>如果需要注入有参数的对象，则需要定义Module具体提供，和Dagger用法相同，不过，Hilt不需要Component这个中间着，直接通过@InstallIn(ActivityComponent::class)注解进行指定由谁来完成依赖注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Word @Inject constructor(val word:String,val meaning:String) &#123;</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;Word(word=&#x27;$word&#x27;, meaning=&#x27;$meaning&#x27;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@Module</span><br><span class="line">@InstallIn(ActivityComponent::class)</span><br><span class="line">class MainModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    fun provideWord() = Word(&quot;hello&quot;,&quot;你好&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@Binds注解，上面我们提供的注入都是某个具体的类，如果想注入一个借口对象，则只能使用@Binds注解来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface APIService &#123;&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">class MyService:APIService &#123;&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@Module</span><br><span class="line">@InstallIn(ActivityComponent::class)</span><br><span class="line">abstract class MainModule &#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        @Provides</span><br><span class="line">        fun provideWord() = Word(&quot;hello&quot;,&quot;你好&quot;)</span><br><span class="line"></span><br><span class="line">        @Provides</span><br><span class="line">        fun provideAPIService() = MyService()</span><br><span class="line">    &#125;</span><br><span class="line">    @Binds</span><br><span class="line">    abstract fun bindService(myService: MyService):APIService</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来就可以在Activity中注入接口对象</p>
</li>
</ol>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>历时两天，踩了很多坑，Dagger和Hilt的相似度很高，只是Hilt更加简洁而已，个人感觉重点是要会自定义Module提供数据源，可以搭配网络访问框架Retrofit和Okhttp进行组合练习</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder机制浅谈</title>
    <url>/Binder%E6%9C%BA%E5%88%B6%E6%B5%85%E8%B0%88.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>说起Binder的跨进程，百般挠头，个人感觉很难想通的是通信的具体流程，以及代码中如何体现的，每一个类具体扮演什么样的角色，折磨一番也只能暂时理解一个大概</p>
</blockquote>
<h3 id="二-理论基础"><a href="#二-理论基础" class="headerlink" title="二.理论基础"></a>二.理论基础</h3><blockquote>
<p>看了Binder也才理解为什么面试官喜欢挖操作系统，基本的进程概念，以及传统的IPC(进程间通信方式)有哪些，如何进行的通信，内核态/用户态…….下面简单聊一下传统的IPC和Binder的优劣</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-2160e70ca6e813ff28c34eec5ae8209c_1440w.jpg"></p>
<p>此前还得先补充一下进程隔离以及数据是如何传递的</p>
<ol>
<li><p>进程隔离</p>
<img src="https://pic3.zhimg.com/80/v2-38e2ea1d22660b237e17d2a7f298f3d6_1440w.jpg" style="zoom:51%;" />

<ul>
<li><p>所谓进程间的通信就是进程1中的类可以调用进程2中的类的方法进行数据传递或其他响应</p>
</li>
<li><p>每个进程间内存隔离，互不干扰，所以进程1中的类A是无法持有进程2中类B的引用，更无法调用类B的方法</p>
</li>
<li><p>上图呈现了进程空间的划分，多个进程间无法通信，但通过内核空间就可以实现中转然后通信，下面简单介绍一下用户空间和内核空间的划分问题</p>
<p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<img src="https://pic2.zhimg.com/80/v2-3c719337413b9c5c4ad0b6c6b8eb0291_1440w.jpg" style="zoom:75%;" />

<p>简单说内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。用户空间内部分多个互不干扰的进程，而内核空间是共享的，用户进程可以通过<strong>系统调用</strong>和内核空间进行通信，所以说内核空间就是一层中转</p>
<p>常用的系统调用：</p>
<ul>
<li>copy_from_user() //将数据从用户空间拷贝到内核空间</li>
<li>copy_to_user() //将数据从内核空间拷贝到用户空间</li>
</ul>
</li>
</ul>
</li>
<li><p>传统的IPC通信方式</p>
<p>有了上面的基本理解，下面就开始具体介绍传统IPC是如何实现进程间通信的</p>
<img src="https://pic1.zhimg.com/80/v2-aab2affe42958a659ea8a517ffaff5a0_1440w.jpg" style="zoom:51%;" />

<p>​    注：上述看到的内存空间都是虚拟地址，虚拟地址映射真实的物理地址，就像栈中的指针引用对应堆上的实例对象，下面以     Socket/管道/消息队列的通信方式来演示(发送方和接收方都有自己的内存管理)</p>
<ol>
<li>发送方将数据从自己管辖的物理空间中拷贝数据到内核空间-copy_from_user</li>
<li>接收方将数据从内核空间拷贝到自己管辖的物理空间-copy_to_user</li>
</ol>
<p>所以没有内存共享就是拷贝两次，下面再看一下完全的内存共享方式</p>
<p><img src="https://img-blog.csdn.net/20170522210722671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2t5cm9iZW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>这里直接扒了一张图，简单说就是两个进程的虚拟地址都指向同一片物理内存空间，所以一个进程对这片共享的区域修改，另一个进程就可以同步修改，因此就不需要进行数据拷贝</p>
</li>
<li><p>Binder通信</p>
<img src="https://pic4.zhimg.com/80/v2-cbd7d2befbed12d4c8896f236df96dbf_1440w.jpg" style="zoom:51%;" />

<p>Binder通信是基于内存映射(mmap)来实现的，mmap在接收进程的用户空间和内核空间建立内存映射，简单说就是接收进程的指定虚拟地址指向了内核空间的数据缓存区，所以现在只需要发送进程拷贝数据到内核空间即可</p>
</li>
</ol>
<p>上面通过概念图的方式对比了传统IPC和Binder之间的差异，下面总结一下Binder的优势：</p>
<img src="https://pic3.zhimg.com/80/v2-30dce36be4e6617596b5fab96ef904c6_1440w.jpg" style="zoom:51%;" />

<h3 id="三-手撸一个跨进程通信示例"><a href="#三-手撸一个跨进程通信示例" class="headerlink" title="三.手撸一个跨进程通信示例"></a>三.手撸一个跨进程通信示例</h3><p>为了能够展示码代码的基本思路，下面先附上一张Binder通信的基本流程图</p>
<img src="https://pic3.zhimg.com/80/v2-729b3444cd784d882215a24067893d0e_1440w.jpg" style="zoom:51%;" />

<img src="https://pic4.zhimg.com/80/v2-67854cdf14d07a6a4acf9d675354e1ff_1440w.jpg" style="zoom:51%;" />

<p>需要的类以及对应的功能：</p>
<ol>
<li>IInterface：标识服务端进程(习惯这样说)对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</li>
<li>Client：客户端需要拿到服务端的一个对象(这里拿到的是代理对象)，因为IInterface规定了服务端提供了哪些通信方式(说白了就是方法，调用服务端的方法进行数据传递达到通信目的)，所以容易想到Client需要持有IInterface的对象</li>
<li>Server：服务端通常是Service的实现类来扮演，比如说服务端用来存储数据，那肯定需要暴露接口给外部用于添加数据，这也是IInterface中要提供的功能</li>
<li>Stub : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类，这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力，Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。其实通过后面代码实现来看，Stub就是Server端具体实现功能的工具，这里抽象一层，便于区分处理代理对象发送的数据操作请求和具体的数据操作</li>
<li>Proxy：Binder通信使用了代理模式，就算通过Binder驱动-&gt;ServiceManager找到了具体的服务端进程，也不可能返回真实的服务端进程中类的对象引用，如果客户端都能持有服务端的引用了，也说不上是跨进程了，所以这里通过链接返回的代理对象，很显然要调用服务端的功能，Proxy必然也是IInterface实现类</li>
</ol>
<p>注：IInterface是系统提供的一种标识，具体定义服务端提供哪些功能，中间还需要提供一层接口用于定义功能</p>
<p>下面就不贴代码了，通过一张图结合Binder的通信过程来理解为什么要这样撸码</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/777501da5c06a7309589e0af92ec1dfadf0a6898">代码链接</a></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Binder%E9%80%9A%E4%BF%A1.png" style="zoom:35%;" />

<p>这里就省去了用户进程通过open/io_ctl和Binder驱动通信的流程，简单描绘了一个大致流程，仅一己之见</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>Binder理解起来实在复杂，特别是搭配底层C++源码，其实很多时候疑惑的是自己写的代码是如何体现Binder通信的流程，以及为什么要这样写，下面推荐一篇博客，个人感觉写得很详细了，如果能搭配代码，将代码中的每个类扮演的角色，以及通过方法发起的链接流程理清楚就很棒了。这里再简单提一下吧，从宏观角度来说，Client通过bindService向Server发送一个连接请求，那Server应该在onBind中返回一个自己的实例，然后Client就可以在onServiceConnected拿到这个实例，然后就可以通信了，只不过因为跨进程，所以不能拿到Server的一个实例，需要通过第三者来封装，因为是Binder通信，所以就必须是能够在Binder驱动中来去自如的IBinder的实现类，还需实现我们规定给Server端的功能接口，这也就是Stub存在的意义，此外因为跨进程，所以还必须返回一个代理对象，所以就有了Proxy，Proxy内部持有连接成功返回的Binder对象，这么一说其实就很清晰了，从宏观到细节。</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/35519585">博客链接</a></p>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Fragment以及Navitation</title>
    <url>/Fragment%E4%BB%A5%E5%8F%8ANavitation.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><ul>
<li><p>Fragment：翻译为碎片，Fragment的初衷是为了适配平板，因为平板的界面比较大，可以划分为多个区域，每个区域就是一个Fragment</p>
</li>
<li><p>Fragment在如今的用法是扮演小型Activity，有属于自己的生命周期，Fragment不像Activity那样耗内存，特别轻巧，亲身经历，如果一个app的界面过多，也就意味着Activity会很多，那么Activity之间的跳转关系便会变得很复杂，而Activity的跳转是<strong>相当消耗内存的</strong>，一个简单的app打包之后可能会上百兆，而如果界面之间的跳转使用Fragment，会减少几倍的内存，如果Activity是房间，Fragment是画，那么Activity之间的跳转就是从一个房间进入到另外一个房间，而Frament之间的跳转仅仅只是将新的一幅画贴上去，可想而知，界面采取Fragment跳转是有多easy</p>
</li>
<li><p>现在app的设计大多采用一两个甚至一个Activity(即MainActivity)，而其他界面都是Fragment，因为Fragment就是<strong>小型Activity</strong></p>
</li>
<li><p>随着Fragment的不断发展，Fragment之间的跳转升级成了<strong>Navigation</strong>，让Fragment的使用变得更加简单</p>
</li>
</ul>
<h3 id="二-Fragment的生命周期"><a href="#二-Fragment的生命周期" class="headerlink" title="二.Fragment的生命周期"></a>二.Fragment的生命周期</h3><p><img src="https://developer.android.google.cn/images/fragment_lifecycle.png"></p>
<ul>
<li>onAttach - fragment添加到activity时触发</li>
<li>onCreate - 创建fragment(准备画框)</li>
<li>onCreateView - 初始化fragment具体显示的内容-xml (画的具体内容)</li>
<li>onActivityCreated - Activity创建好后(准备墙)，在此方法中可以访问到fragment对应的xml中的控件</li>
<li>onStart 启动</li>
<li>onResume 可以交互</li>
<li>onPause 暂停交互</li>
<li>onStop 停止了</li>
<li>onDestroyView 销毁xml中的视图控件，即销毁画，fragment(画框还在)</li>
<li>onDestroy  真正销毁fragment</li>
</ul>
<h3 id="三-使用Fragment"><a href="#三-使用Fragment" class="headerlink" title="三.使用Fragment"></a>三.使用Fragment</h3><p><strong>①静态使用</strong></p>
<ol>
<li><p>在activity的xml中添加fragment组件</p>
</li>
<li><p>创建一个类继承于fragment</p>
</li>
<li><p>重写对应的生命周期方法-onCreateView必需</p>
</li>
<li><p>创建xml文件进行界面布局</p>
</li>
<li><p>使用LayoutInflater解析xml</p>
</li>
<li><p>在activity的xml中设置fragment对应的name属性</p>
</li>
</ol>
<p><strong>②动态使用</strong></p>
<ol>
<li><p>在activity的xml中添加FrameLayout组件进行占位</p>
</li>
<li><p>创建一个类继承于fragment</p>
</li>
<li><p>重写对应的生命周期方法-onCreateView必需</p>
</li>
<li><p>创建xml文件进行界面布局</p>
</li>
<li><p>使用LayoutInflater解析xml</p>
</li>
<li><p>使用FragmentManager管理fragment的切换</p>
<p>Activity中：supportFragmentManager</p>
<p>Fragment中：fragmentManager</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> mAdd.setOnClickListener &#123;</span><br><span class="line">            supportFragmentManager.beginTransaction()</span><br><span class="line">                .add(R.id.container,LoginFragment())</span><br><span class="line">                .addToBackStack(null)</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">mReplace.setOnClickListener &#123;</span><br><span class="line">            supportFragmentManager.beginTransaction()</span><br><span class="line">                .replace(R.id.container,RegisterFragment())</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>addToBackStack(null)</code>可以将fragment添加到栈中</p>
</blockquote>
<h3 id="四-fragment跳转添加动画"><a href="#四-fragment跳转添加动画" class="headerlink" title="四.fragment跳转添加动画"></a>四.fragment跳转添加动画</h3><ol>
<li><p>在<code>res</code>目录下新建一个<code>Android Resource Directory</code>，类型为<code>anim</code></p>
</li>
<li><p>在<code>anim</code>下新建<code>Animation Resource File</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//slide_in</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:duration=&quot;500&quot;&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:fromXDelta=&quot;-100%&quot;</span><br><span class="line">        android:toXDelta=&quot;0%&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>setCustomAnimations(R.anim.slide_in,R.anim.slide_out,R.anim.pop_in,R.anim.pop_out)</code>设置切换动画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supportFragmentManager.beginTransaction()</span><br><span class="line">               .setCustomAnimations(R.anim.slide_in,R.anim.slide_out,R.anim.pop_in,R.anim.pop_out)</span><br><span class="line">               .replace(R.id.container,RegisterFragment())</span><br><span class="line">               .commit()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Fragment/fragmentshow.gif" style="zoom:33%;" />

<h3 id="五-Navigation"><a href="#五-Navigation" class="headerlink" title="五.Navigation"></a>五.Navigation</h3><p>①为了支持<code>safe-args</code>需要在<strong>工程gradle</strong>中添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def nav_version = &quot;2.3.1&quot;</span><br><span class="line">classpath &quot;androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version&quot;</span><br></pre></td></tr></table></figure>

<p>②在app对应的gradle中添加<code>apply plugin: &quot;androidx.navigation.safeargs.kotlin&quot;</code></p>
<p>官网强烈要求使用<code>safe-args</code>的跳转方式，可以保证类型安全</p>
<p><strong>Navigation中三大重要组成</strong></p>
<ol>
<li><p>NavHostFragment</p>
<p>用于承载所有Fragment，就是一个容器，画框</p>
</li>
<li><p>NavGraph</p>
<p>导航图，构建Fragment之间的跳转关系，还可管理参数传递和切换动画</p>
</li>
<li><p>NavController</p>
<p>管理Fragment之间的切换</p>
</li>
</ol>
<p><strong>Navigation搭配底部导航使用步骤：</strong></p>
<ol>
<li><p>提前准备好几个具有跳转关系的Fragment</p>
</li>
<li><p>创建导航图</p>
<p>①在<code>res</code>目录下新建一个<code>Android Resource Directory</code>，类型为<code>navigation</code></p>
<p>②在<code>navigation</code>下新建<code>Navigation Resource File</code></p>
</li>
<li><p>在导航图中构建导航关系</p>
</li>
<li><p>创建菜单</p>
<p>①在<code>res</code>目录下新建一个<code>Android Resource Directory</code>，类型为<code>navigation</code></p>
<p>②在<code>navigation</code>下新建<code>Menu Resource File</code></p>
<p>③创建菜单项，每一项的<strong>id</strong>必须和导航图里面每个视图的id一样，一一对应才能完成跳转</p>
</li>
<li><p>在<code>activity_main.xml</code>中添加<code>NavHostFragment</code>容器，并关联上<code>NavGraph</code>，添加<code>BottomNavigationView</code>，并添加<code>menu</code>属性</p>
</li>
<li><p>在MainActivity中加载<code>NavController</code>控制Fragment跳转</p>
</li>
<li><p>将底部导航控件和<code>NavController</code>相关联</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private lateinit var navController: NavController</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        navController=findNavController(R.id.nav_host_fragment)</span><br><span class="line">        bottomNavigationView.setupWithNavController(navController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加顶部toolBar以及菜单</strong></p>
<ol>
<li><p>在<code>styles.xml</code>中将<code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</code>更改为<code>NoActionBar</code></p>
</li>
<li><p>在<code>activity_main.xml</code>中添加<code>ToolBar</code></p>
</li>
<li><p>设置<code>ActionBar</code></p>
<p><code>setSupportActionBar(toolbar)</code></p>
</li>
<li><p>将toolBar和navController关联，当切换界面时，会把对应fragment的label显示到actionBar</p>
<p><code>setupActionBarWithNavController(navController)</code></p>
</li>
</ol>
<p><strong>抽屉式布局</strong></p>
<ol>
<li><p>将activity_main.xml的外层用drawerLayout包裹</p>
</li>
<li><p>在原来的约束布局下面添加一个<code>NavigationView</code>，并添加<code>android:layout_gravity = &quot;start&quot;</code>属性，end表示从右边滑出</p>
</li>
<li><p>添加<code>menu</code>属性</p>
</li>
<li><p>在MainActivity中关联<code>NavigationView</code>和<code>NavController</code></p>
<p><code>nav_view.setupWithNavController(navController)</code></p>
</li>
<li><p>将<code>appBarConfiguration</code>属性化(即全局)，并初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appBarConfiguration = AppBarConfiguration(setOf(R.id.homeFragment,R.id.registerFragment),</span><br><span class="line">                drawer</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>

<p>第一个参数表示有哪些Fragment是同级的，不能通过顶部的返回键返回，第二个参数是给toolBar左侧添加一个菜单标志，提示用户</p>
</li>
</ol>
<p><strong>Fragment跳转时传递数据</strong></p>
<ol>
<li><p>在导航图中给目的地界面添加参数</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Fragment/Navigation%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" style="zoom: 50%;" /></li>
<li><p>通过NavController进行导航跳转</p>
<p>首先创建action对象，当你在导航图中添加导航关系后，会自动生成一个以起始Fragment类名命名的action类，当然该类可以有很多个跳转关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loginBtn.setOnClickListener &#123;</span><br><span class="line">            val action = HomeFragmentDirections.actionHomeFragmentToLoginFragment2(nameInput.text.toString())</span><br><span class="line">            findNavController().navigate(action)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果想传递参数，则将参数填入action的圆括号内即可</p>
</li>
<li><p>目的地Fragment取出数据</p>
<p>通过代理模式<code>by</code>取数据更加方便，且不易出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val args:LoginFragmentArgs by navArgs()</span><br><span class="line"> override fun onActivityCreated(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState)</span><br><span class="line">        showText.text = args.userName</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>推荐使用这种方式进行数据传递</p>
</li>
</ol>
<p><strong>如果想设置按back键退回到哪个界面，只需在导航图中进行设置</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Fragment/%E8%AE%BE%E7%BD%AEback%E7%95%8C%E9%9D%A2.png" style="zoom:50%;" />

<p>这种设置对于层级很深的跳转很有用</p>
<p><strong>下面展示综合效果</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Fragment/navigationshow.gif" style="zoom:33%;" />

<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><blockquote>
<p>学完Fragment后，会发现Navigation让界面的跳转变得更加轻松，从此app的设计多采用一个Activity，多个Fragment的形式，并且app的基本框架会使用Navigation相关组件</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/fragment-and-navigation">代码链接</a></p>
]]></content>
      <categories>
        <category>Android重要组件</category>
      </categories>
  </entry>
  <entry>
    <title>Glide源码解读以及自定义图片加载库</title>
    <url>/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在了解了Glide的基本使用后，还需进一步了解的实现原理，通过源码理清思路后能够自己封装一个类似的网络图片加载库，下面分步骤详解</p>
</blockquote>
<p><strong>下面照旧从三个方面进行源码解读</strong></p>
<ol>
<li>请求发送到哪里去了</li>
<li>请求是被谁处理的</li>
<li>请求是怎么被维护的</li>
</ol>
<h3 id="二-请求发送到哪里去了"><a href="#二-请求发送到哪里去了" class="headerlink" title="二.请求发送到哪里去了"></a>二.请求发送到哪里去了</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%AD%A5%E9%AA%A4%E4%B8%80.png" style="zoom:67%;" />

<blockquote>
<p>从链式代码的最后一个步<code>into()</code>入手，进入<code>RequestBuilder</code>类中，有多个<code>into</code>方法，跳转两次后，会看到<code>requestManager.track()</code>，进入到<code>runRequest()</code>方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void runRequest(@NonNull Request request) &#123;</span><br><span class="line">    requests.add(request);</span><br><span class="line">    if (!isPaused) &#123;</span><br><span class="line">      request.begin();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      request.clear();</span><br><span class="line">      if (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, &quot;Paused, delaying request&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      pendingRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到里面的逻辑，如果没有暂停则立即执行请求，否则清空运行中的队列，并将请求添加到等待中的队列</p>
<h3 id="三-请求是被谁处理的"><a href="#三-请求是被谁处理的" class="headerlink" title="三.请求是被谁处理的"></a>三.请求是被谁处理的</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%AD%A5%E9%AA%A4%E4%BA%8C.png" style="zoom: 67%;" />

<blockquote>
<p>进入到<code>loadData()</code>的具体实现类<code>HttpUrlFetcher</code>，在<code>loadDataWithRedirects()</code>中可以清楚的看到真正在处理网络请求的是<code>HttpUrlConnection</code></p>
</blockquote>
<h3 id="四-请求是怎么被维护的"><a href="#四-请求是怎么被维护的" class="headerlink" title="四.请求是怎么被维护的"></a>四.请求是怎么被维护的</h3><p>Glide传入了Context参数，具有生命周期，据此来进行维护</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%AD%A5%E9%AA%A4%E4%B8%89.png" style="zoom:80%;" />

<blockquote>
<p>涉及到的方法较少，通过<code>supportFragmentGet()</code>创建一个无UI的Fragment，并且与返回的<code>requestManager</code>进行了绑定，Fragment可以感知Activity的生命周期，因此<code>requestManager</code>也具有了生命周期，而且在<code>RequestManager</code>类中也可以看到<code>onStart</code>、<code>onStop</code>等方法，具体调用<code>resumeRequests()</code>、<code>pauseRequests()</code>，并且在<code>SingleRequest</code>中还有<code>recycle()</code>回收机制</p>
</blockquote>
<h3 id="五-自定义图片加载框架"><a href="#五-自定义图片加载框架" class="headerlink" title="五.自定义图片加载框架"></a>五.自定义图片加载框架</h3><blockquote>
<p>弄懂Glide的原理后，下面尝试着写一个类似的图片加载框架，比较简单</p>
</blockquote>
<p>可以将下面的例子类比成一个餐馆，客人就是请求，桌子就是处理线程，客人都会先进行排队(将任务丢进队列)，然后是寻找桌子(线程从队列中取任务)，在菜做好(图片加载好)之前，先吃点花生米(展示提示图)，整个店就是一个图片加载框架，服务员类似于<code>RequestManager</code>的角色，所以核心类就只有三个<code>BitmapRequest</code>、<code>BitmapDispatcher</code>、<code>RequestManager</code></p>
<p><strong>例子中会使用到一个Md5工具类，用于核对防止图片设置错位</strong></p>
<blockquote>
<p>由于多个BitmapDispatcher是从同一个队列中取任务，所以它内部管理的只能是一个引用，不能自己创建一个队列，该队列只能维护在<code>RequestManager</code>中，取任务的过程依然是一个死循环</p>
</blockquote>
<p>在此就不贴出代码了，还请自行前往链接查看，理清三个类之间的关系即可</p>
<p>效果展示：</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/MyGlide%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif" style="zoom: 33%;" />

<p><a href="https://gitee.com/wiwiyiyi/my-glide">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler原理分析</title>
    <url>/Handler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>日常开发中免不了线程切换，子-&gt;主或主-&gt;子，最经典的就是Handler实现的线程切换了，它也占据了系统源码的很大一部分，没有它就跑不起来，下面娓娓道来</p>
</blockquote>
<h3 id="二-组成与运作"><a href="#二-组成与运作" class="headerlink" title="二.组成与运作"></a>二.组成与运作</h3><p>先来通过一张图体现Handler相关体系的组成</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Handler%E7%BB%93%E6%9E%84.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val handler = object : Handler()&#123;</span><br><span class="line">        override fun handleMessage(msg: Message) &#123;</span><br><span class="line">            //切换到主线程做事情</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Thread&#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            Looper.loop()</span><br><span class="line">            handler.sendEmptyMessage(0)</span><br><span class="line">        &#125;.start()    </span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" style="zoom:50%;" />

<p>上图已经比较清楚的解释了子线程发送消息如何回到handleMessage中处理结果的流程，主要成员也比较清楚</p>
<ol>
<li><p>无论是SendMessage还是post都是发送一个消息，并且最终汇流于sendMessageAtTime此函数，开始入队</p>
</li>
<li><p>最终发送消息时，会将Handler的对象赋值给target，消息出队后才知道让哪个Handler来处理</p>
</li>
<li><p>Looper在此过程中充当动力源，内部就是一个死循环，不断取消息，然后分发，Handler就像入口，MessageQueue做一个缓存中转，所以这就是一个典型的生产者/消费者问题，消息队列满了，Handler的入队操作阻塞，消息队列为空，Looper的取操作阻塞，等待被唤醒</p>
</li>
<li><p>MessageQueue是一个优先级队列，上面提到最终汇流于sendMessageAtTime函数，无论你是否设置时间，系统会给一个默认的时间，入队时按照延迟的时间排序，显然延迟时间越短越靠前，正是要保证优先性，所以要出队和入队都要加锁</p>
</li>
<li><p>Looper如何跑起来的？</p>
<p>每一个线程只能有一Looper实例和消息队列，这就是通过ThreadLocal来实现的，因为每一个线程内部都有一个唯一的ThreadLocalMap，Looper这个类中保存了一个静态的ThreadLocal变量，作为公有的key，构造方法私有，只能通过<code>prepare()</code>来创建Looper对象，并保存在当前线程的ThreadLocalMap中，并且还需要调用Looper.loop将其跑起来，这里涉及到的<strong>Looper实例的存和取都是针对线程中的ThreadLocalMap</strong>，所以保证了唯一性</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Looper%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7.png" style="zoom:50%;" /></li>
<li><p>取消息时的阻塞，分两种</p>
<p>a. 没到延迟时间，会重新计算延迟时间，然后睡眠，达到时间自动唤醒</p>
<p>b. 消息队列为空，无限等待，直到有消息入队将它唤醒</p>
<p>上述搭配使用的方法是nativePollOnce睡眠、nativeWake唤醒</p>
</li>
<li><p>如何结束Looper.loop的死循环</p>
<p>MessageQueue提供了quit方法，当App退出时会调用此方法，修改mQuitting这个标志位，如果下次取消息时mQuitting为true，则返回空消息(null)，在Looper.loop中如果拿到的是空消息，则return结束循环</p>
</li>
<li><p>Handler存在内存泄漏</p>
<p>实例代码在IDE中会提示内存泄漏，这是因为内部类会持有外部类的引用，所以Handler持有了Activity的引用，而前面提到Msg的target就是Handler，所以相当于MessageQueue持有了Activity的引用，就导致了内存泄漏，因此开发中需要使用静态内部类+弱引用的方式</p>
</li>
<li><p>Handler实现线程切换或者说线程间的通信是通过共享内存实现的，那这里共享的内存自然就是<strong>Message</strong>，数据是共享的，比如在子线程发送消息，消息的入队操作是在子线程完成的，可以一路追踪，哪个线程的Handler，自然就会调用哪个线程的MessageQueue入队操作，一旦消息入队，并唤醒(如果需要)，子线程的任务就完成了，既然消息已经进入了Handler对应的MessageQueue，剩余的就是对应的Looper取消息并分发的过程了，移动的就是Message，细思甚秒！</p>
</li>
</ol>
<h3 id="三-内存屏障-barrier"><a href="#三-内存屏障-barrier" class="headerlink" title="三.内存屏障-barrier"></a>三.内存屏障-barrier</h3><blockquote>
<p>内存屏障的作用很重要，屏障简单说就是阻塞，对于普通的消息都是按照时间排序后顺序被取出，但如果有一个紧急消息需要立即被执行，岂不是还要等待前面的消息执行完毕，显然不合理，这也就是内存屏障的意义</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E6%B6%88%E6%81%AF%E5%B1%8F%E9%9A%9C.png"></p>
<ol>
<li><p>先解释一下这里的同步消息和异步消息，小编感觉有点混乱，这里应该是针对消息队列来看，普通消息必须排队按次序被取出，所以普通消息称为同步消息，需要立即被处理的消息称为异步消息，所以如此来理解为什么立即被处理的消息的标志位为isAsynchronous就比较容易了，遍历查找异步消息</p>
</li>
<li><p>如何插入的屏障</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = true;</span><br><span class="line">            //插入内存屏障</span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            //发送异步消息</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>在ViewRootImpl中有示例，内存屏障也是考虑到了UI刷新问题，显然UI刷新是需要立即被处理的，另外屏幕也会每隔一定时间就会刷新，比如60HZ，就是说1秒内刷新60次，约等于16ms刷新一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void postCallbackDelayedInternal(int callbackType,</span><br><span class="line">            Object action, Object token, long delayMillis) &#123;</span><br><span class="line">        if (DEBUG_FRAMES) &#123;</span><br><span class="line">            Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType</span><br><span class="line">                    + &quot;, action=&quot; + action + &quot;, token=&quot; + token</span><br><span class="line">                    + &quot;, delayMillis=&quot; + delayMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            final long dueTime = now + delayMillis;</span><br><span class="line">            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">            if (dueTime &lt;= now) &#123;</span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">                msg.arg1 = callbackType;</span><br><span class="line">                //设置标志位</span><br><span class="line">                msg.setAsynchronous(true);</span><br><span class="line">                mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>设置了内存屏障后，发送异步消息时只需要通过setAsynchronous(true)设置标志位即可</p>
</li>
<li><p>如果不移除内存屏障就会反复遍历寻找，所以一旦不需要了，立即移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br></pre></td></tr></table></figure>

<p>mTraversalBarrier是插入的屏障的标识</p>
</li>
</ol>
<blockquote>
<p>内存屏障东西不多，理解它的工作原理，以及使用即可，插入和移除搭配使用，移除一定要及时，否则会影响效率</p>
</blockquote>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Html学习随笔</title>
    <url>/Html%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94.html</url>
    <content><![CDATA[<h3 id="Html与Css笔记"><a href="#Html与Css笔记" class="headerlink" title="Html与Css笔记"></a>Html与Css笔记</h3><h4 id="1-文字效果"><a href="#1-文字效果" class="headerlink" title="1.文字效果"></a>1.文字效果</h4><table>
<thead>
<tr>
<th align="center">效果</th>
<th align="center">格式</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">文字加粗</td>
<td align="center"><strong></strong>或则<b></b>标签</td>
<td align="center">更推荐使用<strong></td>
</tr>
<tr>
<td align="center">倾斜</td>
<td align="center"><em></em>或者<i></i></td>
<td align="center">推荐使用<em></td>
</tr>
<tr>
<td align="center">删除线</td>
<td align="center"><del></del>或者<s></s></td>
<td align="center">推荐使用<del></td>
</tr>
<tr>
<td align="center">下划线</td>
<td align="center"><ins></ins>或者<u></u></td>
<td align="center">推荐使用<ins></td>
</tr>
</tbody></table>
<h3 id="2-盒子标签"><a href="#2-盒子标签" class="headerlink" title="2.盒子标签"></a>2.盒子标签</h3><ul>
<li><p>&lt;div&gt;&lt;/div&gt;</p>
<p>一行只能放一个·大盒子</p>
</li>
<li><p>&lt;span&gt;&lt;/span&gt;</p>
<p>一行可以放多个<span>即为跨距的意思</p>
</li>
</ul>
<h3 id="3-图像标签"><a href="#3-图像标签" class="headerlink" title="3.图像标签"></a>3.图像标签</h3><p>&lt;img src = “图片路径”/&gt;</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">属性值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">src</td>
<td align="center">图片路径</td>
<td align="center">必须属性</td>
</tr>
<tr>
<td align="center">alt</td>
<td align="center">文本</td>
<td align="center">替换文本，图片不能正常显示时替换</td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">文本</td>
<td align="center">提示文本，鼠标放在图片上时显示</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">像素</td>
<td align="center">设置图像的高度</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">像素</td>
<td align="center">设置图片的高度</td>
</tr>
<tr>
<td align="center">border</td>
<td align="center">像素</td>
<td align="center">设置的图片的边框粗细</td>
</tr>
</tbody></table>
<blockquote>
<p>高度和宽度修改其中一个即可，等比例缩放，同时修改会失真</p>
<p>属性写在标签后面，不分先后，各属性之间通过空格隔开</p>
</blockquote>
<h3 id="4-图片的相对路径"><a href="#4-图片的相对路径" class="headerlink" title="4.图片的相对路径"></a>4.图片的相对路径</h3><table>
<thead>
<tr>
<th align="center">相对路径分类</th>
<th align="center">符号格式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一级路径</td>
<td align="center">无</td>
<td align="center">图片和html文件位于同一文件级，&lt;img src=”wiwi.jpg”/&gt;</td>
</tr>
<tr>
<td align="center">下一级路径</td>
<td align="center">/</td>
<td align="center">图片位于位于html文件下一级，&lt;img src=”images/wiwi.jpg”/&gt;</td>
</tr>
<tr>
<td align="center">上一级路径</td>
<td align="center">../</td>
<td align="center">图片位于html文件上一级，&lt;img src=”../wiwi.jpg”/&gt;</td>
</tr>
</tbody></table>
<h3 id="5-超链接标签"><a href="#5-超链接标签" class="headerlink" title="5.超链接标签"></a>5.超链接标签</h3><p>&lt;a href=”跳转目标”  target=”目标窗口的弹出方式”&gt; 文本或图像 &lt;/a&gt;</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">href</td>
<td align="center">指定链接目标的url地址，(必须属性) 当为标签应用<strong>href</strong>属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">指定链接页面的<strong>打开方式</strong>，其中_self为默认值，__blank为在新窗口中打开方式</td>
</tr>
</tbody></table>
<p><strong>链接分类</strong></p>
<ol>
<li><p>外部链接</p>
<p>&lt;a href=”<a href="http://www.baidu.com&quot;&gt;百度/">http://www.baidu.com&quot;&gt;百度\</a></a></p>
</li>
<li><p>内部链接</p>
<p>网站内部之间的相互链接，直接链接内部链接名称即可</p>
<p>&lt;a href=”index.html”&gt;首页&lt;/a&gt;</p>
</li>
<li><p>空链接</p>
<p>&lt;a href=”#”&gt;空链接&lt;/a&gt;</p>
</li>
<li><p>下载链接</p>
<p>地址链接的是<strong>文件：.exe、zip</strong></p>
<p>&lt;a href=”img.zip”&gt;图片下载&lt;/a&gt;</p>
<p>点击之后会立即将图片下载到本地</p>
</li>
<li><p>网页元素的链接</p>
<p>&lt;a href=”<a href="http://www.baidu.com&quot;&gt;/">http://www.baidu.com&quot;&gt;\</a><img src="wiwi.jpg"/>&lt;/a&gt;</p>
</li>
<li><p>锚点链接</p>
<p>点击链接可以快速定位到页面中的某个位置</p>
<p>使用步骤</p>
<ol>
<li>在链接文本的href属性中，设置属性的值为**”#名字”**，如&lt;a href=”#two”&gt;第二季&lt;/a&gt;</li>
<li>在目标位置标签中加入<strong>id属性=上面的名字</strong>，如&lt;h3 id=”two”&gt;第二季介绍&lt;/h3&gt;</li>
</ol>
</li>
</ol>
<h3 id="6-常用符号语法"><a href="#6-常用符号语法" class="headerlink" title="6.常用符号语法"></a>6.常用符号语法</h3><table>
<thead>
<tr>
<th align="center">特殊符号</th>
<th align="center">描述</th>
<th align="center">字符代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">空格符</td>
<td align="center">&amp;nbsp;</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于符</td>
<td align="center">&amp;lt;</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于符</td>
<td align="center">&amp;gt;</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">和符</td>
<td align="center">&amp;amp;</td>
</tr>
</tbody></table>
<h3 id="7-表格标签"><a href="#7-表格标签" class="headerlink" title="7.表格标签"></a>7.表格标签</h3><ol>
<li><p>&lt;table&gt;&lt;table/&gt;用于定义表格的标签</p>
</li>
<li><p>&lt;tr&gt;&lt;tr/&gt;用于定义表格中的行，必须嵌套在&lt;table&gt;标签中</p>
</li>
<li><p>&lt;td&gt;&lt;td/&gt;用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;tr/&gt;中</p>
</li>
<li><p>&lt;th&gt;&lt;th/&gt;常用于表头，加粗和居中效果</p>
</li>
</ol>
<p><strong>表格的属性</strong></p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">align</td>
<td align="center">left、center、right</td>
<td align="center">规定表格相对于周围元素的对齐方式</td>
</tr>
<tr>
<td align="center">border</td>
<td align="center">1或””</td>
<td align="center">设置表格是否有边框，””表示默认没有</td>
</tr>
<tr>
<td align="center">cellpadding</td>
<td align="center">像素值</td>
<td align="center">设置内容和单元格的内间距，默认1像素</td>
</tr>
<tr>
<td align="center">cellspacing</td>
<td align="center">像素值</td>
<td align="center">设置单元格之间的空白，默认2像素</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">像素值或百分比</td>
<td align="center">设置表格的宽度</td>
</tr>
</tbody></table>
<p><strong>表格的结构标签</strong></p>
<ol>
<li>&lt;thead&gt;&lt;thead/&gt; 定义表格的头部，内部必须有&lt;tr&gt;标签，一般位于表格的第一行</li>
<li>&lt;tbody&gt;&lt;tbody&gt;   定义表格的主体，主要用于放数据主体</li>
</ol>
<p><strong>单元格的合并</strong></p>
<ul>
<li>跨行合并：rowspan=”合并单元格的个数”</li>
<li>跨列合并：colspan=”合并单元格的个数”</li>
</ul>
<p><strong>合并单元格的步骤</strong></p>
<ol>
<li>确定是跨行还是跨列合并</li>
<li>找到目标单元格，写上<strong>合并方式=合并的单元格数量</strong>，如&lt;td colspan=”2”&gt; &lt;/td&gt;</li>
<li>删除多余的单元格</li>
</ol>
<h3 id="8-列表标签"><a href="#8-列表标签" class="headerlink" title="8.列表标签"></a>8.列表标签</h3><ol>
<li><p>无序列表</p>
<ul>
<li>用&lt;ul&gt;&lt;ul&gt;  定义列表</li>
<li>&lt;li&gt;&lt;li/&gt;  定义列表项</li>
</ul>
<p>注：&lt;ul&gt;标签内只能放&lt;li&gt;标签，但&lt;li&gt;标签内可以容纳所有元素</p>
</li>
<li><p>有序列表</p>
<ul>
<li>使用&lt;ol&gt;&lt;ol/&gt; 定义有序列表</li>
</ul>
</li>
<li><p>自定义列表</p>
<ul>
<li><p>自定义列表常用于对术语或名词进行解释和描述，列表项前没有任何项目符号</p>
</li>
<li><p>语法格式</p>
<p>&lt;dl&gt;</p>
<p>​     &lt;dt&gt;分类标题&lt;/dt&gt;</p>
<p>​    &lt;dd&gt;子项一&lt;/dd&gt;</p>
<p>​    &lt;dd&gt;子项二&lt;/dd&gt;</p>
<p>  &lt;/dl&gt;</p>
</li>
<li><p>&lt;dl&gt;标签内只能放&lt;dt&gt;和&lt;dd&gt;标签</p>
</li>
<li><p>通常情况下，一个&lt;dt&gt;对应多个&lt;dd&gt;标签</p>
</li>
</ul>
</li>
</ol>
<h3 id="9-表单"><a href="#9-表单" class="headerlink" title="9. 表单"></a>9. 表单</h3><p>使用&lt;form&gt;&lt;form/&gt;表示表单域</p>
<p>(1)&lt;input&gt;</p>
<p>格式：&lt;input type= “属性值”/&gt;</p>
<p>常用type的属性值如下表</p>
<table>
<thead>
<tr>
<th align="center">type值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">button</td>
<td align="center">定义可点击按钮，用于通过JS启动脚本</td>
</tr>
<tr>
<td align="center">checkbox</td>
<td align="center">定义复选框</td>
</tr>
<tr>
<td align="center">text</td>
<td align="center">定义单行的输入字段，输入文本·，默认宽度为20个字符</td>
</tr>
<tr>
<td align="center">hidden</td>
<td align="center">定义隐藏的输入字段</td>
</tr>
<tr>
<td align="center">image</td>
<td align="center">定义图像形式的提交按钮</td>
</tr>
<tr>
<td align="center">password</td>
<td align="center">定义密码字段，该字段中的字符被掩码</td>
</tr>
<tr>
<td align="center">radio</td>
<td align="center">定义单选按钮</td>
</tr>
<tr>
<td align="center">reset</td>
<td align="center">定义重置按钮，清空表单中的所有数据</td>
</tr>
<tr>
<td align="center">submit</td>
<td align="center">定义提交按钮，将表单的数据提交给服务器</td>
</tr>
</tbody></table>
<ol>
<li><p>每个表单元素都有自己的name属性，可以理解为Java里面的<strong>引用对象</strong>，多个单选按钮以及复选框按钮必须设置相同的name</p>
</li>
<li><p>value：设置input元素的值</p>
</li>
<li><p>checked：规定input元素首次加载时被选中，主要针对单选和多选按钮</p>
</li>
<li><p>maxLength：设置输入的最大长度</p>
</li>
</ol>
<p>(2) 表单标签-label</p>
<ul>
<li><p>用于绑定某个表单元素，增加用户体验</p>
</li>
<li><p>格式：</p>
<p>&lt;label for=”sex”&gt;男&lt;/label&gt;</p>
<p>&lt;input type=”radio” name=”sex” id=”sex”&gt;</p>
</li>
<li><p>label标签的for属性应和相关元素的id属性相同</p>
</li>
</ul>
<p>(3) 下拉表单元素&lt;select&gt;</p>
<ul>
<li><p>针对多个选择</p>
</li>
<li><p>语法格式</p>
<p>&lt;select&gt;</p>
<p>​      &lt;option&gt;选项一&lt;/option&gt;</p>
<p>​      &lt;option&gt;选项二&lt;/option&gt;</p>
<p>​      &lt;option&gt;选项三&lt;/option&gt;</p>
<p>​    &lt;/select&gt;</p>
</li>
<li><p>注：至少包含一对&lt;option&gt;，可以给某个option设置selected属性，首次加载默认选中</p>
</li>
</ul>
<p>(4) 文本域表单元素&lt;textarea&gt;</p>
<ul>
<li><p>针对多行文本</p>
</li>
<li><p>语法格式</p>
<p>&lt;textarea cols=”一行多少个字” rows=”行数”&gt;</p>
<p>​        文本内容</p>
<p>​    &lt;/textarea&gt;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>html学习</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Java阻塞队列和线程池</title>
    <url>/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>关于阻塞队列和线程池以往用得少，如果写自己的框架就需要很熟悉，下面系统地介绍一下</p>
</blockquote>
<h3 id="二-阻塞队列"><a href="#二-阻塞队列" class="headerlink" title="二.阻塞队列"></a>二.阻塞队列</h3><blockquote>
<p>阻塞队列在实际开发中基本都是用来解决生产者和消费者问题，当队列满了，所有生产者都会阻塞等待被唤醒，队列为空，所有消费者都会阻塞等待被唤醒</p>
</blockquote>
<p>阻塞队列-&gt;BlockingQueue接口，下面看一下它提供的放入和取出方法，都是成对的</p>
<ol>
<li>add()和remove()，都是非阻塞的，当队列满了，add会抛异常，队列为空，remove会抛异常</li>
<li>offer()和poll()，当队列满了，offer返回false，队列为空，poll返回null，同样是非阻塞</li>
<li>put()和take()，当队列满了，放不进则阻塞，队列为空，取不到则阻塞</li>
</ol>
<p>下面简单介绍一下阻塞队列的几个实现：</p>
<ol>
<li><p>ArrayBlockingQueue：由数组结构组成的有界阻塞队列，初始化时必须传入容量</p>
<p>初始化时还可以传入fair参数指定是否是公平访问，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列</p>
</li>
<li><p>LinkedBlockingQueue：由链表结构组成的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE</p>
</li>
</ol>
<blockquote>
<p>简单提一下Array和Link两种实现方式的区别：</p>
<ol>
<li><p>队列中锁的实现不同<br>ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁</p>
<p>LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock</p>
</li>
<li><p>在生产或消费时操作不同<br>ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的<br>LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node<E>进行插入或移除，会影响性能</p>
</li>
<li><p>队列大小初始化方式不同<br>ArrayBlockingQueue实现的队列中必须指定队列的大小<br>LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE</p>
</li>
</ol>
</blockquote>
<ol start="3">
<li><p>PriorityBlockingQueue：支持优先级的无界阻塞队列，默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
</li>
<li><p>DelayQueue：支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，就算队列中有元素也只有在延迟期满时才能从队列中提取元素。</p>
<p>运用场景：缓存系统的设计-&gt;可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程，队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p>
</li>
<li><p>LinkedTransferQueue：新增transfer和tryTransfer方法<br>（1）transfer方法<br>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。<br>（2）tryTransfer方法<br>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
</li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<br>新增addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p>
</li>
</ol>
<p>以上介绍的阻塞队列常用的就是数组和链表实现的，使用简单，下面通过DelayQueue简单模拟订单的限时支付</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data class Order(val orderNo: String, val orderMoney: Int)</span><br><span class="line">class PutOrderThread(private val delayQueue: DelayQueue&lt;ItemVo&lt;Order&gt;&gt;): Thread() &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        val order = Order(&quot;123&quot;,12)</span><br><span class="line">        val itemVo =</span><br><span class="line">            ItemVo&lt;Order&gt;(5, order)</span><br><span class="line">        delayQueue.offer(itemVo)</span><br><span class="line">        println(&quot;订单5秒后超时: $&#123;order.orderMoney&#125;---$&#123;order.orderNo&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        val order2 = Order(&quot;1234&quot;,123)</span><br><span class="line">        val itemVo2 =</span><br><span class="line">            ItemVo&lt;Order&gt;(8, order2)</span><br><span class="line">        delayQueue.offer(itemVo2)</span><br><span class="line">        println(&quot;订单8秒后超时: $&#123;order.orderMoney&#125;---$&#123;order.orderNo&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class FetchOrderThread(private val delayQueue: DelayQueue&lt;ItemVo&lt;Order&gt;&gt;): Thread()&#123;</span><br><span class="line"></span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            print(&quot;开始取数据&quot;)</span><br><span class="line">            val itemVo = delayQueue.take()</span><br><span class="line">            val order = itemVo.data</span><br><span class="line">            println(&quot;取出的数据：$&#123;order.orderNo&#125;----$&#123;order.orderMoney&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ItemVo&lt;T&gt;(expirationTime: Long, data: T) : Delayed &#123;</span><br><span class="line">    //到期时间,但传入的数值代表过期的时长，传入单位毫秒</span><br><span class="line">    val activeTime: Long</span><br><span class="line">    val data: T//业务数据，泛型</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这个方法返回到激活日期的剩余时间，时间单位由单位参数指定。</span><br><span class="line">     */</span><br><span class="line">    override fun getDelay(unit: TimeUnit): Long &#123;</span><br><span class="line">        return unit.convert(activeTime - System.currentTimeMillis(), unit</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     *Delayed接口继承了Comparable接口，按剩余时间排序，实际计算考虑精度为纳秒数</span><br><span class="line">     */</span><br><span class="line">    override fun compareTo(other: Delayed): Int &#123;</span><br><span class="line">        val d = (getDelay(TimeUnit.MILLISECONDS)</span><br><span class="line">                - other.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">        return if (d == 0L) &#123;</span><br><span class="line">            0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (d &lt; 0) &#123;</span><br><span class="line">                -1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //传入过期时长,单位秒，内部转换</span><br><span class="line">    init &#123;</span><br><span class="line">        activeTime = expirationTime * 1000 + System.currentTimeMillis()</span><br><span class="line">        this.data = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val delayQueue = DelayQueue&lt;ItemVo&lt;Order&gt;&gt;()</span><br><span class="line">    PutOrderThread(delayQueue).start()</span><br><span class="line">    FetchOrderThread(delayQueue).start()</span><br><span class="line">    //每隔500毫秒，打印个数字</span><br><span class="line"></span><br><span class="line">    //每隔500毫秒，打印个数字</span><br><span class="line">    for (i in 1..14) &#123;</span><br><span class="line">        Thread.sleep(500)</span><br><span class="line">        println(i * 500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-线程池"><a href="#三-线程池" class="headerlink" title="三.线程池"></a>三.线程池</h3><p><strong>为什么需要使用线程池：</strong></p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。   如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ol>
<p><strong>创建线程池的参数解析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<ol>
<li>corePoolSize<br>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；<br>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li>maximumPoolSize<br>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</li>
<li>keepAliveTime<br>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</li>
<li>TimeUnit<br>keepAliveTime的时间单位</li>
<li>workQueue<br>workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。<br>一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：<br>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。<br>2）由于1，使用无界队列时maximumPoolSize将是一个无效参数。<br>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。<br>4）更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</li>
<li>threadFactory<br>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。<br>Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</li>
<li>RejectedExecutionHandler<br>线程池的饱和(拒绝)策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<br>（1）AbortPolicy：直接抛出异常，默认策略；<br>（2）CallerRunsPolicy：用调用者所在的线程来执行任务；<br>（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>（4）DiscardPolicy：直接丢弃任务；<br>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</li>
</ol>
<p><strong>线程池的工作机制：</strong></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" style="zoom:50%;" />

<p><strong>常用的线程池：</strong></p>
<p>即便知道每个参数的含义，平时开发中也很少自己创建线程池，因为jdk已经为我们提供了常用的线程池</p>
<ol>
<li><p>newCachedThreadPool</p>
<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>这种类型的线程池特点是：</p>
<ul>
<li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
</li>
<li><p>newFixedThreadPool</p>
<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
</li>
<li><p>newSingleThreadExecutor</p>
<p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
</li>
<li><p>newScheduleThreadPool</p>
<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>
</li>
</ol>
<p><strong>最后需要合理使用线程池：</strong></p>
<p>首先分析任务的特性：CPU密集型任务、IO密集型任务和混合型任务。</p>
<ol>
<li><p>任务的优先级：高、中和低。</p>
</li>
<li><p>任务的执行时间：长、中和短。</p>
</li>
<li><p>任务的依赖性：是否依赖其他系统资源，如数据库连接。</p>
</li>
</ol>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu，可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>从以往的开发经验来说，对于耗时任务的处理，小编见过线程池处理和HandlerThread处理两种方式，关于线程池，需要知道大概的工作流程，以及常用的几种线程池，无论使用哪种，在个人开发中其实影响不大</p>
</blockquote>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Material Design整理</title>
    <url>/Material-Design%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>Material Design早在2014年就已经推出了，现在很多APP都会使用里面的控件布局UI，实现一些炫酷的布局效果很容易，本文旨在整理全套的基本使用，便于查阅</p>
</blockquote>
<h3 id="二-Material-Design使用示例"><a href="#二-Material-Design使用示例" class="headerlink" title="二.Material Design使用示例"></a>二.Material Design使用示例</h3><ol>
<li><p>底部工具栏</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Material%20Design/%E5%BA%95%E9%83%A8%E5%B7%A5%E5%85%B7%E6%A0%8F.png" style="zoom:50%;" /></li>
</ol>
<p>使用场景：</p>
<ul>
<li>仅限移动设备</li>
<li>访问底部导航抽屉</li>
<li>有两到五个动作的屏幕</li>
</ul>
<p>注：不适用于带有底部导航栏的应用</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/59615210fbc6a0d75b22fe988ac8d2349f7c8d30">代码链接</a></p>
<p>FloatActionButton常用属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性值以及含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:layout_anchor</td>
<td align="center">相对于哪个控件的锚点</td>
</tr>
<tr>
<td align="center">app:layout_anchorGravity</td>
<td align="center">相对于锚点控件的位置(bottom|end|left…)</td>
</tr>
<tr>
<td align="center">app:rippleColor</td>
<td align="center">设置点击水波纹的颜色</td>
</tr>
<tr>
<td align="center">app:fabSize</td>
<td align="center">设置按钮大小</td>
</tr>
</tbody></table>
<p>BottomAppBar常用属性：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性值以及含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:navigationIcon</td>
<td align="center">设置导航菜单图标(也叫溢出菜单)</td>
</tr>
<tr>
<td align="center">app:hideOnScroll</td>
<td align="center">设置随着内容的滚动消失以及出现</td>
</tr>
<tr>
<td align="center">app:backgroundTint</td>
<td align="center">设置背景色</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;ShapeAppearance.App.SmallComponent&quot; parent=&quot;ShapeAppearance.MaterialComponents.SmallComponent&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;cornerFamily&quot;&gt;cut&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;cornerSize&quot;&gt;4dp&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">   &lt;style name=&quot;Widget.App.FloatingActionButton&quot; parent=&quot;Widget.MaterialComponents.FloatingActionButton&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;materialThemeOverlay&quot;&gt;@style/ThemeOverlay.App.FloatingActionButton&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">   &lt;style name=&quot;ThemeOverlay.App.FloatingActionButton&quot; parent=&quot;&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;shapeAppearanceSmallComponent&quot;&gt;@style/ShapeAppearance.App.SmallComponent&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>styles.xml添加如上样式，并让FloatActionButton使用可以展示不同的样式，点击的响应范围没变，对图形做了剪裁，详情看代码</p>
<p><a href="https://material.io/develop/android/theming/shape">关于自定义Shape剪裁</a></p>
<ol start="2">
<li><p>顶部工具栏</p>
<p>①基本的工具栏滚动消失行为</p>
<ul>
<li><code>app:liftOnScroll=&quot;true&quot;</code>作用于AppBarLayout，显示与内容位于同一高度的顶部应用栏，滚动时，它会增加高度并让内容在其后面滚动</li>
<li><code>app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot;</code>作用于MaterialToolbar，顶部应用栏在向上滚动时消失，向下滚动时出现</li>
<li><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>使NestedScrollView滚动搭配CoordinatorLayout</li>
</ul>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/9a673d4800e990a53c2b5db4de8441a88538b6ab">代码链接</a></p>
<p>②突出的顶部应用栏</p>
<p>在MaterialToolbar外面套一层CollapsingToolbarLayout，并调大AppBarLayout的高度，使其可折叠</p>
<p>CollapsingToolbarLayout其实就是FrameLayout，所以还可以包裹一个ImageView作背景</p>
<ul>
<li><p><code>android:fitsSystemWindows=&quot;true&quot;</code>搭配主题透明可以使状态栏沉浸式，AppBarLayout中除了MaterialToolbar都需要加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.TopAppBarFitTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;</code>作用于CollapsingToolbarLayout，使得滑动时可折叠</p>
</li>
<li><p><code>app:layout_collapseMode=&quot;pin&quot;</code>作用于MaterialToolbar，固定滑到顶端ToolBar</p>
</li>
<li><p><code>android:background=&quot;@android:color/transparent&quot;</code>使MaterialToolbar透明，图片展示效果更佳</p>
</li>
</ul>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/91a8e23146a8ae1438a6af4cd0f80a63c4cd722b">代码链接</a></p>
<p>③添加可变化式的ToolBar样式(上下文变化)</p>
<p>对于删除元素这种场景使用颇多</p>
<ul>
<li>定义删除状态的Menu</li>
<li>代码中添加回调(ActionMode)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.TopAppBarFitTheme&quot; parent=&quot;Theme.MaterialComponents.DayNight.NoActionBar&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;windowActionModeOverlay&quot;&gt;true&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;actionModeStyle&quot;&gt;@style/Widget.App.ActionMode&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;actionModeCloseDrawable&quot;&gt;@drawable/ic_close_24dp&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;actionBarTheme&quot;&gt;@style/ThemeOverlay.MaterialComponents.Dark.ActionBar&lt;/item&gt;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;style name=&quot;Widget.App.ActionMode&quot; parent=&quot;Widget.AppCompat.ActionMode&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;titleTextStyle&quot;&gt;?attr/textAppearanceHeadline6&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;subtitleTextStyle&quot;&gt;?attr/textAppearanceSubtitle1&lt;/item&gt;</span><br><span class="line">      &lt;item name=&quot;background&quot;&gt;@color/material_grey_900&lt;/item&gt;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>ActionMode对应的主题</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/4bbc9e3b835a40c7e79e781793b6ebe5ca0d534f">代码链接</a></p>
</li>
<li><p>底部导航栏</p>
<p>官方是不建议单独使用，通常的用法是搭配Navigation(导航图)实现主页之间的切换</p>
<p>这里主要介绍menu的点击响应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binding.bottomNav.setOnItemSelectedListener &#123; item -&gt;</span><br><span class="line">            when(item.itemId) &#123;</span><br><span class="line">                R.id.page1 -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.page2 -&gt; &#123;        </span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                else -&gt; false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为其他的点击事件的API被废弃了，看上去不雅观，所以这里就是用比较原始的API</p>
<p><code>BottomNavigationView</code>还提供了带数量的标签Drawable，比如QQ的未读消息数量，使用很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private fun showCountDrawable(@IdRes menuId: Int) &#123;</span><br><span class="line">           binding.bottomNav.getOrCreateBadge(menuId).apply &#123;</span><br><span class="line">               if (!isVisible) isVisible = true</span><br><span class="line">               number = ++num</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   private fun removeCountDrawable(@IdRes menuId: Int) &#123;</span><br><span class="line">           binding.bottomNav.getBadge(menuId).also &#123; badgeDrawable -&gt;</span><br><span class="line">               if (badgeDrawable?.isVisible == true) &#123;</span><br><span class="line">                   badgeDrawable.clearNumber()</span><br><span class="line">                   badgeDrawable.isVisible = false</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>很多时候会使用路由框架，就和Navigation的导航框架会有冲突，所以还是可以考虑单独使用BottomNavigationView</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/e75aa3b17706f68c14e31e25e99ad63becb2a3f2">代码链接</a></p>
<p>这里就不展示主题的更换，详情可以参考官网，和之前提到的主题更换很类似</p>
</li>
<li><p>按钮</p>
<p>这里主要罗列比较特殊的按钮，比如线边框，就不用再用shape做背景了</p>
<p>①通过设置style达到效果</p>
<table>
<thead>
<tr>
<th align="center">style值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Widget.MaterialComponents.Button.TextButton</td>
<td align="center">不带icon的普通文本按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.TextButton.Icon</td>
<td align="center">带icon的文本按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.OutlinedButton</td>
<td align="center">不带icon的轮廓(线边框)按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.OutlinedButton.Icon</td>
<td align="center">带icon的轮廓按钮</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Button.Icon</td>
<td align="center">原始风格带icon</td>
</tr>
</tbody></table>
<p>②<strong>按钮组(MaterialButtonToggleGroup)：</strong></p>
<ul>
<li>app:singleSelection：设置是否单选</li>
</ul>
<p>内部的Button只设置icon，然后自定义样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;Widget.App.Button.OutlinedButton.IconOnly&quot; parent=&quot;Widget.MaterialComponents.Button.OutlinedButton&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;iconPadding&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:insetTop&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:insetBottom&quot;&gt;0dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:paddingLeft&quot;&gt;12dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:paddingRight&quot;&gt;12dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:minWidth&quot;&gt;48dp&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:minHeight&quot;&gt;48dp&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>③选择按钮(CheckBox)：通过selector的xml设置android:button属性，xml内部是state_checked属性</p>
<p>通用属性</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:icon</td>
<td align="center">设置图标</td>
</tr>
<tr>
<td align="center">app:iconTint</td>
<td align="center">设置图标颜色</td>
</tr>
<tr>
<td align="center">app:iconSize</td>
<td align="center">设置图标大小</td>
</tr>
<tr>
<td align="center">app:iconGravity</td>
<td align="center">设置图标位置</td>
</tr>
<tr>
<td align="center">app:iconPadding</td>
<td align="center">设置图标和文本的距离</td>
</tr>
<tr>
<td align="center">app:rippleColor</td>
<td align="center">点击的水波纹颜色</td>
</tr>
<tr>
<td align="center">app:strokeColor</td>
<td align="center">描边的颜色(如果有)</td>
</tr>
<tr>
<td align="center">app:strokeWidth</td>
<td align="center">描边的粗细(如果有)</td>
</tr>
<tr>
<td align="center">app:backgroundTint</td>
<td align="center">设置背景色</td>
</tr>
</tbody></table>
</li>
<li><p>Chip条目</p>
<p>共有四种类型，都是成组使用，通过不同的主题来区分</p>
<table>
<thead>
<tr>
<th align="center">Style</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Widget.MaterialComponents.Chip.Action</td>
<td align="center">默认的样式，只带有icon</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Chip.Entry</td>
<td align="center">输入条目样式</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Chip.Choice</td>
<td align="center">多项选择组</td>
</tr>
<tr>
<td align="center">Widget.MaterialComponents.Chip.Filter</td>
<td align="center">过滤组</td>
</tr>
</tbody></table>
<p>①单个Chip元素常用属性</p>
<table>
<thead>
<tr>
<th align="center">属性值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">app:chipIcon</td>
<td align="center">普通样式的icon</td>
</tr>
<tr>
<td align="center">app:checkedIcon</td>
<td align="center">选择样式的icon</td>
</tr>
<tr>
<td align="center">app:closeIcon</td>
<td align="center">移除样式的icon</td>
</tr>
</tbody></table>
<p>注：其余配套的属性都是和其功能搭配的，比如<code>check**</code></p>
<p>这个地方设置了对应的style就是对应的功能，比如过滤，点击之后就会自动更改选中样式，很方便，对于带closeIcon的Chip，可以设置点击事件，点×后可以让该Chip变成GONE，还是蛮好用的，然后获取对应被选中的Chip，代码中也有体现</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/036d4aafeb5474c092baa5a16e4e402d46373d52">代码链接</a></p>
</li>
<li><p>日期/时间选择器</p>
<p>日期/时间选择器，这里就一笔带过了，使用超简单，包括有时间范围的合没有时间范围的，拿到build之后的对象，还可以设置选择后的监听，拿到选择的具体日期或者时间跨度，详情看官网，比传统的时间选择器好用太多</p>
<p>此外还可以通过设置常量构造器限制选择的范围</p>
<p>日期和时间的选择器使用方式雷同，下面贴一下时间选择器的用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val picker = MaterialTimePicker.Builder()</span><br><span class="line">                //设置小时制，12小时的界面会不同</span><br><span class="line">                .setTimeFormat(TimeFormat.CLOCK_24H)</span><br><span class="line">                .setHour(12)</span><br><span class="line">                .setMinute(10)</span><br><span class="line">                .setTitleText(&quot;Select Appointment time&quot;)</span><br><span class="line">                //设置展示的输入方式，不设置也可以，两种模式可以手动切换</span><br><span class="line">                .setInputMode(INPUT_MODE_CLOCK)</span><br><span class="line">                .build()</span><br><span class="line">        picker.addOnPositiveButtonClickListener &#123;</span><br><span class="line">            // 点击确定按钮</span><br><span class="line">        &#125;</span><br><span class="line">        picker.addOnNegativeButtonClickListener &#123;</span><br><span class="line">            // 点击取消按钮</span><br><span class="line">        &#125;</span><br><span class="line">        picker.addOnCancelListener &#123;</span><br><span class="line">            // call back code</span><br><span class="line">        &#125;</span><br><span class="line">        picker.addOnDismissListener &#123;</span><br><span class="line">            // Dialog消失的回调</span><br><span class="line">        &#125;</span><br><span class="line">        picker.show(supportFragmentManager,&quot;tag&quot;)</span><br></pre></td></tr></table></figure>

<p><a href="https://material-io.cn/components/date-pickers/android#using-date-pickers">时间选择器官网链接</a></p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/6efadff5ce61c5926d6e903958a0e4109bd821e0">代码链接</a></p>
</li>
<li><p>长按控件弹出菜单</p>
<p>这个还是蛮实用的吧，实现也比较简单，直接代码查看即可，也可以通过<code>PopupMenu</code>弹出菜单，这个用途是响应某个菜单按钮弹出</p>
<p>①长按某个控件弹出菜单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.注册</span><br><span class="line">registerForContextMenu(view)</span><br><span class="line">// 2.重写对应的菜单解析方法</span><br><span class="line">override fun onCreateContextMenu(</span><br><span class="line">        menu: ContextMenu?,</span><br><span class="line">        v: View?,</span><br><span class="line">        menuInfo: ContextMenu.ContextMenuInfo?</span><br><span class="line">    ) &#123;</span><br><span class="line">        super.onCreateContextMenu(menu, v, menuInfo)</span><br><span class="line">        menuInflater.inflate(R.menu.contextual_action_bar,menu)</span><br><span class="line">    &#125;</span><br><span class="line">// 3.重写菜单项被点击的处理方法</span><br><span class="line">override fun onContextItemSelected(item: MenuItem): Boolean &#123;</span><br><span class="line">        return when (item.itemId) &#123;</span><br><span class="line">            R.id.share -&gt; &#123;</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">            R.id.delete -&gt; &#123;</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">            R.id.more -&gt; &#123;</span><br><span class="line">                true</span><br><span class="line">            &#125;</span><br><span class="line">            else -&gt; super.onContextItemSelected(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>②单击控件弹出菜单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.添加点击监听</span><br><span class="line">view.setOnClickListener &#123;</span><br><span class="line">            showMenu(view,R.menu.contextual_action_bar)</span><br><span class="line">        &#125;</span><br><span class="line">// 2.通过PopupMenu弹出菜单</span><br><span class="line">private fun showMenu(v: View, @MenuRes menuRes: Int) &#123;</span><br><span class="line">        val popup = PopupMenu(this, v)</span><br><span class="line">        popup.menuInflater.inflate(menuRes, popup.menu)</span><br><span class="line"></span><br><span class="line">        popup.setOnMenuItemClickListener &#123; menuItem: MenuItem -&gt;</span><br><span class="line">            when(menuItem.itemId) &#123;</span><br><span class="line">                R.id.share -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.delete -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.more -&gt; &#123;</span><br><span class="line">                    true</span><br><span class="line">                &#125;</span><br><span class="line">                else -&gt; false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        popup.setOnDismissListener &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        // Show the popup menu.</span><br><span class="line">        popup.show()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://material-io.cn/components/menus/android#dropdown-menus">官网文档</a></p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/72aa2b4eeec04e45181bfe9e2a1825842c91e571">代码链接</a></p>
</li>
<li><p>抽屉布局</p>
<p>这里介绍两种抽屉布局</p>
<p>①常规的抽屉布局(类似QQ)</p>
<ul>
<li><p>定义Menu(这里可以有多个菜单Group，最终效果还蛮不错)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;group</span><br><span class="line">        android:id=&quot;@+id/group1&quot;</span><br><span class="line">        android:checkableBehavior=&quot;single&quot;&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item1&quot;</span><br><span class="line">            android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">            android:title=&quot;@string/title_1&quot;</span><br><span class="line">            android:checked=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item2&quot;</span><br><span class="line">            android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">            android:title=&quot;@string/title_2&quot; /&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/item3&quot;</span><br><span class="line">            android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">            android:title=&quot;@string/title_3&quot; /&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">    &lt;group</span><br><span class="line">        android:id=&quot;@+id/group2&quot;</span><br><span class="line">        android:checkableBehavior=&quot;single&quot;&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:id=&quot;@+id/subtitle&quot;</span><br><span class="line">            android:title=&quot;Subtitle&quot;&gt;</span><br><span class="line">            &lt;menu&gt;</span><br><span class="line">                &lt;item</span><br><span class="line">                    android:id=&quot;@+id/item4&quot;</span><br><span class="line">                    android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">                    android:title=&quot;Item 4&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;item</span><br><span class="line">                    android:id=&quot;@+id/item5&quot;</span><br><span class="line">                    android:icon=&quot;@drawable/ic_favourite_filled_24dp&quot;</span><br><span class="line">                    android:title=&quot;Item 5&quot; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/menu&gt;</span><br><span class="line">        &lt;/item&gt;</span><br><span class="line">    &lt;/group&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

<p>这里把第二个菜单组当做了子菜单</p>
</li>
<li><p>定义HeaderLayout(HeaderLayout和菜单都是给NavigationView使用的)</p>
</li>
<li><p>实现home页布局(home布局和NavigationView通过DrawerLayout包裹)</p>
</li>
</ul>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/d050624784119898f2013e350894d0fea966ebed">代码链接</a></p>
<p>如果需要像QQ一样拉满屏幕，可以设置NavigationView<code>android:layout_marginRight=&quot;-65dp&quot;</code></p>
<p>②底部弹出抽屉</p>
<p>和左侧抽屉不一样的是，这里使用到了Behavior，通过将<code>BottomSheetBehavior</code>和<code>NavigationView</code>绑定实现从底部弹出抽屉，这个可以搭配前面写过的底部工具栏来使用</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/2000c6f9d3cde97744c5110e749b925ce42ad44e">代码链接</a></p>
</li>
<li><p>文本输入框</p>
<p>这个变化稍大，使用Material这套可以避免很多的自定义样式，蛮重要的，下面分类叙述</p>
<p>①附加icon</p>
<ul>
<li><p>app:startIconDrawable：添加起始图标</p>
</li>
<li><p>app:endIconMode：设置末尾模式，比如×，输入密码的模式下带小眼睛等，还可以自定义</p>
</li>
<li><p>app:endIconDrawable：在<code>custom</code>自定义模式下添加自己的icon，对于自己的icon还可以添加点击事件，这点很方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">textField.setEndIconOnClickListener &#123;</span><br><span class="line">  //末尾图标按下的回调</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textField.addOnEditTextAttachedListener &#123;</span><br><span class="line"> //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textField.addOnEndIconChangedListener &#123;</span><br><span class="line">  //末尾图标更改的回调</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>②通过指定外层<code>TextInputLayout</code>的style和<code>AutoCompleteTextView</code>实现下拉选择输入</p>
<p>style=”@style/Widget.MaterialComponents.TextInputLayout.*.ExposedDropdownMenu”</p>
<p>③添加辅助说明文本在输入框的下方(作用于TextInputLayout)</p>
<p>app:helperTextEnabled=”true”<br>app:helperText=”辅助说明文本”</p>
<p>④添加文本计数功能(作用于TextInputLayout)</p>
<p>app:counterEnabled=”true”<br>app:counterMaxLength=”20”</p>
</li>
</ol>
<p>​        ⑤添加警告图标(作用于TextInputLayout)</p>
<p>​        app:errorEnabled=”true”</p>
<p>​        <code>passwordLayout.error = getString(警示信息)</code>，清空则赋为null即可</p>
<p>​        ⑥添加前后缀文本信息</p>
<p>​        app:prefixText=”前缀文本”<br>​        app:suffixText=”后缀文本”</p>
<p>​        这个常见于特定格式的邮箱补齐</p>
<p>​        ⑦添加文本改变的监听</p>
<p>​        <code>textField.editText?.doOnTextChanged &#123; text, start, before, count -&gt; &#125;</code>，可以不为里面的输入框设置id，直接通过外层        的TextInputLayout直接添加监听事件</p>
<ol start="10">
<li><p>Snackbar</p>
<p>类似于Toast的提示，使用也类似，下面简单介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Snackbar.make(binding.root,&quot;我是Snackbar&quot;,Snackbar.LENGTH_LONG)</span><br><span class="line">            .setAction(&quot;撤销&quot;)&#123;</span><br><span class="line">                //撤销后的响应</span><br><span class="line">            &#125;</span><br><span class="line">            //设置位于哪个控件的上方</span><br><span class="line">            .setAnchorView(binding.textField)</span><br><span class="line">            .show()</span><br></pre></td></tr></table></figure>

<p>所以也可以像平时封装Toast一样封装Snackbar，便于使用</p>
</li>
<li><p>Bottom Sheet(底部面板)</p>
<p>这个也超实用，只要需要底部弹窗的都可以用这个，Bottom Sheet分两种，一个是常驻的，一个是动态弹出</p>
<p>①常驻的Bottom Sheet：记得高德地图和美团里面都有用到</p>
<ul>
<li><p>设置behavior属性：app:layout_behavior=”@string/bottom_sheet_behavior”</p>
</li>
<li><p>设置起始高度：app:behavior_peekHeight=”dp值”</p>
</li>
<li><p>代码中可以通过<code>BottomSheetBehavior.from(设置过behavoir的view)</code>拿到behavoir，然后设置高度或者状态</p>
</li>
<li><p>常用的状态就是关闭(BottomSheetBehavior.STATE_COLLAPSED)和展开(BottomSheetBehavior.STATE_EXPANDED)</p>
</li>
<li><p>只要xml中设置了behavoir就可以拖动，至于最终能拖动多大距离，取决于控件的<code>layout_height</code></p>
</li>
<li><p>添加拖动的监听事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">behavior.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() &#123;</span><br><span class="line">            override fun onStateChanged(bottomSheet: View, newState: Int) &#123;</span><br><span class="line">                when (newState) &#123;</span><br><span class="line">                    BottomSheetBehavior.STATE_EXPANDED -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_COLLAPSED -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_DRAGGING -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_SETTLING -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    BottomSheetBehavior.STATE_HIDDEN -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onSlide(bottomSheet: View, slideOffset: Float) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>​            ②动态的底部弹窗，有点类似于Dialog，但比Dialog好用</p>
<p>​            需要继承<code>BottomSheetDialogFragment</code>，然后和Fragment的创建类似，初始化布局，这里为了能够设置弹窗的高度，需要拿到系            统的<code>design_bottom_sheet</code>，如若不然，就算你布局时match_parent，也不会填满屏幕，之后设置高度，以及默认的起始高度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//拿到系统的Bottom Sheet，固定写法</span><br><span class="line">val view:FrameLayout = dialog?.findViewById(R.id.design_bottom_sheet)!!</span><br><span class="line">//拿到与之关联的behavior</span><br><span class="line">val behavior = BottomSheetBehavior.from(view)</span><br><span class="line">//设置弹出高度，如果不设置，则停止滑动时会停在默认0的位置</span><br><span class="line">behavior.peekHeight = 3000</span><br><span class="line">//设置弹窗大小</span><br><span class="line">view.layoutParams.height = ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">behavior.state = BottomSheetBehavior.STATE_EXPANDED</span><br></pre></td></tr></table></figure>

<p>​            这里贴一下关键代码，这段初始化必须在onStart()中，否则会报错，因为dialog是在onCreate中创建的</p>
<p>​            <a href="https://gitee.com/wiwiyiyi/improving-repository/commit/ea7546e7fb640a5c33479e56825e14e42300074f">代码链接</a></p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>此篇琐碎的小文写了老久，算是对Material Design摸了一个底，实话说确实很好用，只不过上述是静态的使用，将它们组合在一起还需要动画支持，比如自定义Behavior和共享元素的转场动画</p>
</blockquote>
]]></content>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM、LiveData、DataBinding综合小demo</title>
    <url>/MVVM%E3%80%81LiveData%E3%80%81DataBinding%E7%BB%BC%E5%90%88%E5%B0%8Fdemo.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在学习了MVVM架构方式的基础上，又了解了DataBinding以及LiveData实现轻架构，在很大程度上减轻了控制器Activity/Fragment的负担，下面通过一个小例子来进行巩固，融合的知识点如下：</p>
</blockquote>
<ol>
<li>ViewModel(此实例使用的是AndroidViewModel，因为它可搭配SharedPreference轻松使用)</li>
<li>DataBinding</li>
<li>LiveData</li>
<li>Fragment以及Navigation</li>
<li>SharedPreferences</li>
<li>使用建造者模式创建AlertDialog</li>
</ol>
<p><strong>除此之外，还有一些小细节，比如使用AS提供的矢量图<code>Vector Asset</code>，可以保证拉伸时保持原有比例，配置横屏布局，虽然我在实际操作时没控制好比例，但在写项目的时候应该考虑横屏布局，使用资源文件<code>strings.xml</code>并且提供多国语言支持</strong></p>
<p>本次demo是一个简单的加减法口算测试，可供小孩子使用，实际意义还不错，下面展示效果</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/MVVMdemo%E5%B1%95%E7%A4%BA.gif" style="zoom:33%;" />

<h3 id="二-知识点分析"><a href="#二-知识点分析" class="headerlink" title="二.知识点分析"></a>二.知识点分析</h3><ol>
<li><p>ViewModel加强-&gt;SavedStateHandle</p>
<p>在app模块对应的gradle中添加<code>implementation &#39;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-beta01&#39;</code></p>
<p><code>SavedStateHandle</code>属于lifecycle中的一个分支，可用于ViewModel被摧毁时保存数据，它存放的是键值对，最大的用处是提供了<code>getLiveData&lt;类型&gt;(KEY)</code>获取与键对应的LiveData值，通过<code>set(KEY,value)</code>设置初始值并添加到<code>handle</code>中。</p>
<p>若想在构造函数中保存handle对象，则创建ViewModel时传入<code>SavedStateViewModelFactory(requireActivity().application,requireActivity()</code></p>
</li>
<li><p>AndroidViewModel</p>
<p>在AndroidViewModel内部可以通过<code>getApplication()</code>获取到<code>Application</code>对象，从而得以访问全局资源，在本demo中主要用于获取<code>SharedPreferences</code>的对象来存储数据</p>
</li>
<li><p>创建AS提供的矢量图</p>
<p>选择<strong>res</strong>目录，鼠标右键，选择<code>Vector Asset</code>，然后根据自己的喜好选择矢量图，设置大小颜色等</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E7%9F%A2%E9%87%8F%E5%9B%BE.png" style="zoom: 40%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%B7%E5%BC%8F.png" style="zoom:50%;" /></li>
<li><p>为<code>strings.xml</code>中的资源提供多国语言</p>
<p>在写项目的时候建议在<code>strings.xml</code>中添加后再使用，直接赋值text的硬编码方式不便维护，下面展示提供多国语言</p>
<p>本demo提供的是汉化：</p>
<p>①在<code>strings.xml</code>中点击<code>Open editor</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8F%90%E4%BE%9B%E6%B1%89%E5%8C%961.png" style="zoom:40%;" />

<p>②点击左上角的地球图标，选择你要添加的新语言，这里选择中文</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8F%90%E4%BE%9B%E6%B1%89%E5%8C%962.png" style="zoom:50%;" />

<p>③添加后，会多出一列供你填充翻译版本</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8F%90%E4%BE%9B%E6%B1%89%E5%8C%963.png" style="zoom: 50%;" /></li>
</ol>
<h3 id="三-基于本demo对MVVM的小结"><a href="#三-基于本demo对MVVM的小结" class="headerlink" title="三.基于本demo对MVVM的小结"></a>三.基于本demo对MVVM的小结</h3><blockquote>
<p>该小demo逻辑简单，如果不使用MVVM的架构方式，而用传统的MVC架构，那么所有的逻辑都会在Controller中进行，包括数据的处理、控件的响应事件，不要简单地觉得ViewModel就仅仅用于管理界面中的数据，它还可以进行数据的处理以及简单的逻辑，所以使用MVVM架构，在控制器Controller中只需要处理控件的点击事件即可，大大减轻了Controller的负担，再加上DataBinding实现数据回绑到界面上，就更加轻松了，下面上代码进行体会</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ViewModel</span><br><span class="line">class MyViewModel(application: Application, handle: SavedStateHandle):AndroidViewModel(application) &#123;</span><br><span class="line">    private var handle:SavedStateHandle?=null</span><br><span class="line">    private val Key_High_Score = &quot;key_high_score&quot;</span><br><span class="line">    private val Key_Left_Number = &quot;key_left_number&quot;</span><br><span class="line">    private val Key_Right_Number = &quot;key_right_number&quot;</span><br><span class="line">    private val Key_Operatior = &quot;key_operator&quot;</span><br><span class="line">    private val Key_Answer = &quot;key_answer&quot;</span><br><span class="line">    private val Save_Shp_Data_Name = &quot;save_shp_data_name&quot;</span><br><span class="line">    private val Key_Current_Score = &quot;key_current_score&quot;</span><br><span class="line">    var win_flag = false</span><br><span class="line">    init &#123;</span><br><span class="line">        if (!handle.contains(Key_High_Score))&#123;</span><br><span class="line">            val shp = getApplication&lt;Application&gt;().getSharedPreferences(Save_Shp_Data_Name,Context.MODE_PRIVATE)</span><br><span class="line">            handle.set(Key_High_Score,shp.getInt(Key_High_Score,0))</span><br><span class="line">            handle.set(Key_Left_Number,0)</span><br><span class="line">            handle.set(Key_Right_Number,0)</span><br><span class="line">            handle.set(Key_Operatior,&quot;+&quot;)</span><br><span class="line">            handle.set(Key_Answer,0)</span><br><span class="line">            handle.set(Key_Current_Score,0)</span><br><span class="line">        &#125;</span><br><span class="line">        this.handle = handle</span><br><span class="line">    &#125;</span><br><span class="line">    public fun getLeftNumber()=handle?.getLiveData&lt;Int&gt;(Key_Left_Number)</span><br><span class="line">    public fun getRightNumber()=handle?.getLiveData&lt;Int&gt;(Key_Right_Number)</span><br><span class="line">    public fun  getOperator()=handle?.getLiveData&lt;String&gt;(Key_Operatior)</span><br><span class="line">    public fun  getHighScore()=handle?.getLiveData&lt;Int&gt;(Key_High_Score)</span><br><span class="line">    public fun  getCurrentScore()=handle?.getLiveData&lt;Int&gt;(Key_Current_Score)</span><br><span class="line">    public fun getAnswer() = handle?.getLiveData&lt;Int&gt;(Key_Answer)</span><br><span class="line">    fun generator()&#123;</span><br><span class="line">        val Level = 20</span><br><span class="line">        val x = (1..Level).random()</span><br><span class="line">        val y = (1..Level).random()</span><br><span class="line">        if (x%2==0)&#123;</span><br><span class="line">            getOperator()?.value = &quot;+&quot;</span><br><span class="line">            if (x&gt;y)&#123;</span><br><span class="line">                getAnswer()?.value = x</span><br><span class="line">                getLeftNumber()?.value = y</span><br><span class="line">                getRightNumber()?.value = (x-y)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                getAnswer()?.value = y</span><br><span class="line">                getLeftNumber()?.value = x</span><br><span class="line">                getRightNumber()?.value = (y-x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            getOperator()?.value = &quot;-&quot;</span><br><span class="line">            if (x&gt;y)&#123;</span><br><span class="line">                getAnswer()?.value = (x-y)</span><br><span class="line">                getLeftNumber()?.value = x</span><br><span class="line">                getRightNumber()?.value = y</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                getAnswer()?.value = (y-x)</span><br><span class="line">                getLeftNumber()?.value = y</span><br><span class="line">                getRightNumber()?.value = x</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fun save()&#123;</span><br><span class="line">        val shp = getApplication&lt;Application&gt;().getSharedPreferences(Save_Shp_Data_Name,Context.MODE_PRIVATE)</span><br><span class="line">        shp.edit().apply&#123;</span><br><span class="line">            getHighScore()?.value?.let &#123; putInt(Key_High_Score, it) &#125;</span><br><span class="line">            apply()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fun answerCorrect()&#123;</span><br><span class="line">        getCurrentScore()?.value = getCurrentScore()?.value?.plus(1)</span><br><span class="line">        if(getCurrentScore()?.value!! &gt; getHighScore()?.value!!)&#123;</span><br><span class="line">            getHighScore()?.value = getCurrentScore()?.value</span><br><span class="line">            win_flag = true</span><br><span class="line">        &#125;</span><br><span class="line">        generator()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制器Fragment中的代码就不展示了，可以自行前往代码链接查看，它主要用于处理控件的点击事件，从上面的代码就可以感受到ViewModel的强大以及便利，因此对于MVVM的架构方式，所有和数据相关的操作都尽可能地放在ViewModel中，Controller只负责衔接即处理控件的各种响应事件</p>
<blockquote>
<p>除此之外，写完这个小demo后，对<strong>ViewModel实现数据共享</strong>的用处更加印象深刻，整个demo只有一个ViewModel，各个Fragment中的代码几乎相同，ViewModel融合了各个界面所需的所有数据，当然，当界面变得复杂起来，最好一个界面对应一个ViewModel</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/master-of-mental-arithmetic/">代码链接</a></p>
]]></content>
      <categories>
        <category>Android设计模式</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>NestedScrollView嵌套滑动原理</title>
    <url>/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面回顾了View体系的事件分发机制，本文主要会介绍NestedScrollView的滑动嵌套原理，要知道事件分发的流程的是死的，怎么让事件的消费更加合理，才能更好的处理嵌套滑动的冲突，有一说一，NestedScrollView通过接口回调的方式做的很nice</p>
</blockquote>
<h3 id="二-使用传统的思路解决嵌套滑动"><a href="#二-使用传统的思路解决嵌套滑动" class="headerlink" title="二.使用传统的思路解决嵌套滑动"></a>二.使用传统的思路解决嵌套滑动</h3><blockquote>
<p>平常我们经常会用到纵向滑动内嵌套纵向滑动，外层的纵向滑动容器通常会选择NestedScrollView，那么现在先按照传统的思维来替代外层的NestedScrollView，观察可以得到什么样的效果</p>
</blockquote>
<p>这里采用外部拦截法，需要格外注意的是<code>super.onInterceptTouchEvent(ev)</code>默认情况下是不会拦截DOWN事件的，看源码也能看出这个拦截的条件是有多苛刻，所以直接return这个就好，不用手动return false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在滑动控制过程中，都有一个最小滑动距离，这里通过<code>ViewConfiguration.get(context).scaledTouchSlop</code>获取</p>
<p>为了模拟嵌套滑动效果，MOVE事件的拦截需要自定义规则，这里是以顶部的图片是否可见作为判断准则，具体代码下面会附上链接</p>
<p>基本规则：</p>
<ol>
<li>向上滑动时，如果顶部图片可见，则外层消费MOVE事件</li>
<li>向下滑动时，如果顶部图片不可见，则外层消费MOVE事件</li>
</ol>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/5df6e3417781597964ffdced677dbf37dd96840d">传统嵌套滑动机制实现</a></p>
<p>下面看一下最终的效果如何</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E6%9C%BA%E5%88%B6show.gif" style="zoom:67%;" />

<p>可以看到，优先滑动的是外层，但是很明显，当外层不能再滑(顶部图片不可见)时，内层的RecyclerView不可滑动，显然不符合预期，不过根据原理确实也应该是这样的效果，外层容器一旦拿到了MOVE事件，就不可能再放给孩子了，因为前面的文章说到，只有内部拦截法，也就是孩子才可以决定时候放给父亲，只要父亲决定消费MOVE事件了，那么孩子肯定就消费不了了。</p>
<h3 id="三-分析NestedScroll机制"><a href="#三-分析NestedScroll机制" class="headerlink" title="三.分析NestedScroll机制"></a>三.分析NestedScroll机制</h3><blockquote>
<p>有了上面的铺垫，下面就来搞一搞NestedScroll，主要是通过接口回调的方式来灵活消费事件，值得强调的是NestedScroll机制没有改变事件分发的流程，只是在分发和消费流程中增加了接口回调</p>
</blockquote>
<h5 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h5><p>NestedScroll机制有两类接口：</p>
<ol>
<li><p>NestedScrollingParent</p>
<p>当可滑动的ViewGroup充当父View时实现该接口</p>
</li>
<li><p>NestedScrollingChild</p>
<p>当可滑动的ViewGroup充当子View时实现该接口</p>
</li>
</ol>
<p>先通过一张流程图来熟悉一下NestedScroll的基本工作大致流程</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B1.png" style="zoom:50%;" />

<p>上图还是比较清晰了，嵌套滑动流程都是从子View主动触发的，然后在分发和处理前去寻找和自己关联的可嵌套滑动的父View，简单说就是以父亲为尊，父View的回调也是很有特点的，都是on开头的方法回调</p>
<p>注：这里再强调一下事件消费的问题，在消费流程中会通过一个<code>consumed[2]</code>数组来保存消费的多少，<code>consumed[0]</code>表示水平方向消费的距离，<code>consumed[1]</code>表示竖直方向消费的距离，因为传递的是引用，所以父亲消费结束后，回到子View，子View再消费剩下的部分，如果子View没有完全消费完，那么还会再询问父亲要不要<strong>继续消费</strong>，分配到具体的阶段就是，预滚动和滚动阶段，会询问两次</p>
<h5 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h5><p>下面来具体分析一下上述两个接口中具体的方法，当然，随着后续的扩展还会有后缀2和3的对应接口，这里分析原始的接口</p>
<ol>
<li><p>NestedScrollingChild</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface NestedScrollingChild &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 启用或禁用嵌套滚动的方法，设置为true，并且当前界面的View的层次结构是支持嵌套滚动的</span><br><span class="line">    * (也就是需要NestedScrollingParent嵌套NestedScrollingChild)，才会触发嵌套滚动。</span><br><span class="line">    * 一般这个方法内部都是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    void setNestedScrollingEnabled(boolean enabled);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 判断当前View是否支持嵌套滑动。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    boolean isNestedScrollingEnabled();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 表示view开始滚动了,一般是在ACTION_DOWN中调用，如果返回true则表示父布局支持嵌套滚动。</span><br><span class="line">    * 一般也是直接代理给NestedScrollingChildHelper的同名方法即可。这个时候正常情况会触发Parent的onStartNestedScroll()方法</span><br><span class="line">    */</span><br><span class="line">    boolean startNestedScroll(@ScrollAxis int axes);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 一般是在事件结束比如ACTION_UP或者ACTION_CANCLE中调用,告诉父布局滚动结束。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    void stopNestedScroll();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 判断当前View是否有嵌套滑动的Parent。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    */</span><br><span class="line">    boolean hasNestedScrollingParent();</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 在当前View消费滚动距离之后。通过调用该方法，把剩下的滚动距离传给父布局。如果当前没有发生嵌套滚动，或者不支持嵌套滚动，调用该方法也没啥用。</span><br><span class="line">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">    * dxConsumed：被当前View消费了的水平方向滑动距离</span><br><span class="line">    * dyConsumed：被当前View消费了的垂直方向滑动距离</span><br><span class="line">    * dxUnconsumed：未被消费的水平滑动距离</span><br><span class="line">    * dyUnconsumed：未被消费的垂直滑动距离</span><br><span class="line">    * offsetInWindow：输出可选参数。如果不是null，该方法完成返回时，</span><br><span class="line">    * 会将该视图从该操作之前到该操作完成之后的本地视图坐标中的偏移量封装进该参数中，offsetInWindow[0]水平方向，offsetInWindow[1]垂直方向</span><br><span class="line">    * @return true：表示滚动事件分发成功,fasle: 分发失败</span><br><span class="line">    */</span><br><span class="line">    boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 在当前View消费滚动距离之前把滑动距离传给父布局。相当于把优先处理权交给Parent</span><br><span class="line">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可。</span><br><span class="line">	* dx：当前水平方向滑动的距离</span><br><span class="line">	* dy：当前垂直方向滑动的距离</span><br><span class="line">	* consumed：输出参数，会将Parent消费掉的距离封装进该参数consumed[0]代表水平方向，consumed[1]代表垂直方向</span><br><span class="line">	* @return true：代表Parent消费了滚动距离</span><br><span class="line">    */</span><br><span class="line">    boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,</span><br><span class="line">            @Nullable int[] offsetInWindow);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    *将惯性滑动的速度分发给Parent。内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span><br><span class="line">	* velocityX：表示水平滑动速度</span><br><span class="line">	* velocityY：垂直滑动速度</span><br><span class="line">	* consumed：true：表示当前View消费了滑动事件，否则传入false</span><br><span class="line">	* @return true：表示Parent处理了滑动事件</span><br><span class="line">	*/</span><br><span class="line">    boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 在当前View自己处理惯性滑动前，先将滑动事件分发给Parent,一般来说如果想自己处理惯性的滑动事件，</span><br><span class="line">    * 就不应该调用该方法给Parent处理。如果给了Parent并且返回true，那表示Parent已经处理了，自己就不应该再做处理。</span><br><span class="line">    * 返回false，代表Parent没有处理，但是不代表Parent后面就不用处理了</span><br><span class="line">    * @return true：表示Parent处理了滑动事件</span><br><span class="line">    */</span><br><span class="line">    boolean dispatchNestedPreFling(float velocityX, float velocityY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>NestedScrollingParent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface NestedScrollingParent &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 当NestedScrollingChild调用方法startNestedScroll()时,会调用该方法。主要就是通过返回值告诉系统是否需要对后续的滚动进行处理</span><br><span class="line">    * child：该ViewParen的包含NestedScrollingChild的直接子View，如果只有一层嵌套，和target是同一个View</span><br><span class="line">    * target：本次嵌套滚动的NestedScrollingChild</span><br><span class="line">    * nestedScrollAxes：滚动方向</span><br><span class="line">    * @return </span><br><span class="line">    * true:表示我需要进行处理，后续的滚动会触发相应的回到</span><br><span class="line">    * false: 我不需要处理，后面也就不会进行相应的回调了</span><br><span class="line">    */</span><br><span class="line">    //child和target的区别，如果是嵌套两层如:Parent包含一个LinearLayout，LinearLayout里面才是NestedScrollingChild类型的View。这个时候，</span><br><span class="line">    //child指向LinearLayout，target指向NestedScrollingChild；如果Parent直接就包含了NestedScrollingChild，</span><br><span class="line">    //这个时候target和child都指向NestedScrollingChild</span><br><span class="line">    boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 如果onStartNestedScroll()方法返回的是true的话,那么紧接着就会调用该方法.它是让嵌套滚动在开始滚动之前,</span><br><span class="line">    * 让布局容器(viewGroup)或者它的父类执行一些配置的初始化的</span><br><span class="line">    */</span><br><span class="line">    void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 停止滚动了,当子view调用stopNestedScroll()时会调用该方法</span><br><span class="line">    */</span><br><span class="line">    void onStopNestedScroll(@NonNull View target);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 当子view调用dispatchNestedScroll()方法时,会调用该方法。也就是开始分发处理嵌套滑动了</span><br><span class="line">    * dxConsumed：已经被target消费掉的水平方向的滑动距离</span><br><span class="line">    * dyConsumed：已经被target消费掉的垂直方向的滑动距离</span><br><span class="line">    * dxUnconsumed：未被tagert消费掉的水平方向的滑动距离</span><br><span class="line">    * dyUnconsumed：未被tagert消费掉的垂直方向的滑动距离</span><br><span class="line">    */</span><br><span class="line">    void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 当子view调用dispatchNestedPreScroll()方法是,会调用该方法。也就是在NestedScrollingChild在处理滑动之前，</span><br><span class="line">    * 会先将机会给Parent处理。如果Parent想先消费部分滚动距离，将消费的距离放入consumed</span><br><span class="line">    * dx：水平滑动距离</span><br><span class="line">    * dy：处置滑动距离</span><br><span class="line">    * consumed：表示Parent要消费的滚动距离,consumed[0]和consumed[1]分别表示父布局在x和y方向上消费的距离.</span><br><span class="line">    */</span><br><span class="line">    void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 你可以捕获对内部NestedScrollingChild的fling事件</span><br><span class="line">    * velocityX：水平方向的滑动速度</span><br><span class="line">    * velocityY：垂直方向的滑动速度</span><br><span class="line">    * consumed：是否被child消费了</span><br><span class="line">    * @return</span><br><span class="line">    * true:则表示消费了滑动事件</span><br><span class="line">    */</span><br><span class="line">    boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 在惯性滑动距离处理之前，会调用该方法，同onNestedPreScroll()一样，也是给Parent优先处理的权利</span><br><span class="line">    * target：本次嵌套滚动的NestedScrollingChild</span><br><span class="line">    * velocityX：水平方向的滑动速度</span><br><span class="line">    * velocityY：垂直方向的滑动速度</span><br><span class="line">    * @return</span><br><span class="line">    * true：表示Parent要处理本次滑动事件，Child就不要处理了</span><br><span class="line">    */</span><br><span class="line">    boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 返回当前滑动的方向，一般直接通过NestedScrollingParentHelper.getNestedScrollAxes()返回即可</span><br><span class="line">    */</span><br><span class="line">    @ScrollAxis</span><br><span class="line">    int getNestedScrollAxes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①这里值得注意的是target和child的区别，target是可以嵌套滑动的子View，并不一定是直接子View，直接子View又称Child</p>
<p>②扩展的2接口新增了<code>type</code>参数，主要是为了区别事件类型：touch(触摸)和fling(惯性滑动)，3新增了cousumed引用</p>
</li>
</ol>
<p>上面提到，嵌套滑动的处理流程是从子View开始的，它会不断向上递归父View，寻找可嵌套滑动的父View，然后再自己消费，介绍了这么多，还是得回到如何使用这两个接口，下面通过一个小例子来展示效果</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8show.gif" style="zoom:50%;" />

<p>可以看到效果很明显，滚动的优先级以父View为尊，如果图片可见，并且向上滚动，则父View先消费，如果图片不可见，并且向下滚动，则父View先消费，剩余的才给子View消费，相比于传统的方式，传统的做不到把剩余的给子View消费，而这种接口回调的方式可以</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/57f7e45c3b5bba1c73d7c396e1a57ee1ad87c5ac">自定义嵌套滑动机制</a></p>
<p>其实代码实现也很少，很简单，接口中的方法都是交给各自对应的Helper类去管理，唯一要处理的就是预滚动和滚动中的逻辑</p>
<p>关于Helper，这里就不做介绍了，源码实在有点多，毕竟本文的关键在于看懂大致流程，并能使用，源码其实比较清晰，比如向上递归寻找可嵌套的父View就是交给Helper类来做的，另外就是，由于起点是子View，所以ChildHelper得源码会比较多一点，具体要调用哪些，可以参考我的代码链接，最后再附上NestedScroll机制的几张流程图，方便记忆</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B2.png" style="zoom:50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B3.png" style="zoom:30%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/NestedScroll%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B4.png" style="zoom:25%;" />

<p>在文末还是留点东西，如果想更改开始的那个传统滑动嵌套机制又该如何实现，很明显内部的RecyclerView不就是NestedScrollingChild的实现类吗，所以只需要让外部的容器实现NestedScrollingParent就好了，方法什么的都和自定义的方式一模一样，附上代码链接</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/8ffefc87eecc398680673a3c4559d293b677c950">更改传统的嵌套滑动机制</a></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>有了事件分发的基础，其实理解NestedScroll很容易的，上面从传统-&gt;自定义-&gt;更改传统的链条展示了NestedScroll相关接口的用法，还是蛮有意思的，这为接下来的自定义Behavior打下基础</p>
</blockquote>
]]></content>
      <categories>
        <category>Android UI系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView回收与复用源码分析</title>
    <url>/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>RecyclerView可以说是项目中使用频度很高的一个系统控件，相比于ListView，它最大优势就是常听到的四级缓存，ListView只有两级缓存(缓存屏幕中看到的、屏幕外的)，下面通过源码流程来分析RecyclerView的回收复用机制</p>
</blockquote>
<h3 id="二-回收复用的入口"><a href="#二-回收复用的入口" class="headerlink" title="二.回收复用的入口"></a>二.回收复用的入口</h3><blockquote>
<p>回收有两个入口，一是在布局onLayout时，二是在fill填充itemView时，下面通过流程图的方式来梳理</p>
</blockquote>
<p>①onLayout</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/onLayout%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B.png"></p>
<ol>
<li><p>因为RecyclerView的具体onLayout是交给具体的LayoutManager来实现的，所以回收复用的具体操作是由LayoutManager来完成，在自定义LayoutManager时需考虑这一点，参考系统提供的LinearLayoutManager</p>
</li>
<li><p>上图的两个重心是LinearLayoutManager中回收入口的分叉和Recycler中的实际回收情况，而我们在自定义LayoutManager时，回收Holder只需要通过<code>detachAndScrapAttachedViews</code>这一个方法即可，具体是如何进行回收的我们不关心，但需要知道有哪几种，因为这对应了几种缓存</p>
</li>
<li><p>我们在Recycler这一层来划分缓存方式：</p>
<ol>
<li>mChangedScrap(和动画有关)</li>
<li>mAttachedScrap(缓存以及展示出来的item)</li>
<li>mCachedViews(类似于一个高速缓存，默认大小是2)</li>
<li>mViewCacheExtension自定义缓存(在复用的时候会介绍)</li>
<li>RecyclerPool缓存池</li>
</ol>
<p>很多博客说的都是四级缓存，默认没有将与动画有关的mChangedScrap考虑在内</p>
</li>
<li><p>下面介绍一下缓存池和mCachedViews的关系</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E7%BC%93%E5%AD%98%E6%B1%A0%E4%B8%8E%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" style="zoom:40%;" />

<p>当回收缓存一个holder时，因为mCachedViews的大小为2，所以一旦超过这个大小，就得将头部的holder移入缓存池，1号位前           移，然后将holder添加到末尾，所以缓存池中的Holder都来自mCachedViews，另外就是在添加到缓存池前holder中的数据会被清空，并且mCachedViews只能存同一种holder，即viewtype相同，如果有变化，则直接存入缓存池，并且缓存池中的每一中type只能存5个，通过一个SparseArray来管理，键是viewtype，值是对应的holder数组</p>
<p>②fill</p>
</li>
</ol>
<p>​    <img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/fill%E7%9A%84%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B.png" style="zoom: 75%;" /></p>
<p>​    在fill中只考虑了recycleViewHolderInternal这种情况，滑动过程中会触发</p>
<h3 id="三-复用入口"><a href="#三-复用入口" class="headerlink" title="三.复用入口"></a>三.复用入口</h3><blockquote>
<p>上面通过回收流程的分析，了解到了有几种缓存，下面同样通过流程图的方式来理解复用流程，入口同样有两个，布局时以及滑动时</p>
</blockquote>
<p>①onLayout</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/onLayout%E5%A4%8D%E7%94%A8%E6%B5%81%E7%A8%8B.png"></p>
<p>上面的重点在于<code>tryGetViewHolderForPositionByDeadline</code>获取缓存的holder，可能的复用过程通过函数的命名也就知道是从哪个缓存中取出了</p>
<p>@onTouchEvent</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/onTouch%E5%A4%8D%E7%94%A8%E5%85%A5%E5%8F%A3.png"></p>
<p>对比onLayout的入口，其实很相似，都是在fill中进行复用</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>分多级缓存就是为了提高复用效率，这里暂且谈常规的缓存，自定义缓存几乎不会用到，系统做回收的时候也没有考虑到自定的</p>
<ol>
<li>从mAttachedScrap、mChangedScrap、mCachedViews中取出的holder不需要再绑定数据</li>
<li>从RecyclerPool取出的holder需要重新绑定数据</li>
<li>mAttachedScrap、mChangedScrap缓存的是屏幕看到的holder</li>
</ol>
<blockquote>
<p>小编最初就被这多级缓存搞过心态，忘记了需要重新绑定数据，上面的流程多走几遍倒也有些印象，需要知道大致会经历哪些流程，如何进行回收复用的</p>
</blockquote>
<h3 id="五-参考文章"><a href="#五-参考文章" class="headerlink" title="五.参考文章"></a>五.参考文章</h3><p><a href="https://blog.csdn.net/yzpbright/article/details/108953435">https://blog.csdn.net/yzpbright/article/details/108953435</a></p>
<p><a href="https://juejin.cn/post/6854573221702795277">https://juejin.cn/post/6854573221702795277</a></p>
]]></content>
      <categories>
        <category>系统控件</category>
      </categories>
      <tags>
        <tag>系统高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Okhttp源码解读以及自搭网络框架</title>
    <url>/Okhttp%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E8%87%AA%E6%90%AD%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面已经了解了Okhttp的基本组成以及用法，除此之外我们还需深入源码了解Okhttp的运行机制，并且能够自己搭建一个类似的网络请求框架，其实弄懂Okhttp一个网络框架，其他的网络开源库自然容易理解</p>
</blockquote>
<p>先上Okhttp的整体框架图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Okhttp%E6%A1%86%E6%9E%B6%E5%9B%BE.png" style="zoom: 40%;" />

<p>下面将从以下三个方面剖析Okhttp的运行机制：</p>
<ol>
<li>请求发送到哪里去了</li>
<li>请求是被谁处理的</li>
<li>请求是怎么被维护的</li>
</ol>
<p>以请求为中心展开分析</p>
<h3 id="二-请求发送到哪里去了"><a href="#二-请求发送到哪里去了" class="headerlink" title="二.请求发送到哪里去了"></a>二.请求发送到哪里去了</h3><blockquote>
<p>为了便于理解，下面以异步请求即请求入队列的方式来分析源码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized void enqueue(AsyncCall call) &#123;</span><br><span class="line">  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过跟踪<code>enqueue()</code>方法，我们发现两个队列：<code>runningAsyncCalls</code>和<code>readyAsyncCalls</code>，即运行中的队列和等待中的队列，只有同时满足运行队列中任务的个数小于64以及对同一个目标的访问数小于5时才会被添加到运行中的队列，并执行，否则添加到等待中的队列</p>
<h3 id="三-请求是被谁处理的"><a href="#三-请求是被谁处理的" class="headerlink" title="三.请求是被谁处理的"></a>三.请求是被谁处理的</h3><p>从上面的代码可以看到，任务被丢给了<code>executorService()</code>来处理，即线程池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized ExecutorService executorService() &#123;</span><br><span class="line">   if (executorService == null) &#123;</span><br><span class="line">     executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">         new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));</span><br><span class="line">   &#125;</span><br><span class="line">   return executorService;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面通过一张图先来解释一下线程池</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%BE%E8%A7%A3.png" style="zoom:50%;" />

<p>而此处内部创建的是<code>SynchronousQueue</code>无容量的队列，即只要有任务丢进线程池就会立即执行，即使没有空闲线程也会立即创建，所以在设置最大线程数时用的是<code>Integer.MAX_VALUE</code>，相当大的一个值</p>
<blockquote>
<p>在第一步时说到Okhttp本身就有两个队列，等待和运行，也就意味着它自己本身就可以控制同一时间最多可以执行多少个任务，超过数量就进入等待的队列，所以就没必要再在线程池中自己维护一个有容量的队列，效率也不太高</p>
</blockquote>
<p>当任务交给线程池后，线程池会找一个空闲线程调用<code>run()</code>方法去执行具体的任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override protected void execute() &#123;</span><br><span class="line">     boolean signalledCallback = false;</span><br><span class="line">     try &#123;</span><br><span class="line">       Response response = getResponseWithInterceptorChain();</span><br><span class="line">       if (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">         signalledCallback = true;</span><br><span class="line">         responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         signalledCallback = true;</span><br><span class="line">         responseCallback.onResponse(RealCall.this, response);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">       if (signalledCallback) &#123;</span><br><span class="line">         // Do not signal the callback twice!</span><br><span class="line">         Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         eventListener.callFailed(RealCall.this, e);</span><br><span class="line">         responseCallback.onFailure(RealCall.this, e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       client.dispatcher().finished(this);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">   // Build a full stack of interceptors.</span><br><span class="line">   List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">   interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">   interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">   if (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">       originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">       client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">   return chain.proceed(originalRequest);</span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure>

<p>这是<code>RealCall</code>的内部类<code>AsyncCall</code>中的方法，调用该方法后，首先进入的是<strong>责任链</strong>模式</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png"></p>
<p>在请求发送到服务器之前需要通过一系列关卡的检查，这些关卡就是所谓的<strong>拦截器</strong>，只有当符合所有条件的请求才能通过，最终通过<code>RealInterceptorChain</code>发送请求，此过程提升了网络请求的效率</p>
<h3 id="四-请求是怎么被维护的"><a href="#四-请求是怎么被维护的" class="headerlink" title="四.请求是怎么被维护的"></a>四.请求是怎么被维护的</h3><p>在<code>execute()</code>方法中有一个<code>finally</code>代码块，调用了<code>client.dispatcher().finished(this)</code>，进入到<code>finished()</code>方法内部可以看到<code>promoteCalls()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void promoteCalls() &#123;</span><br><span class="line">    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.</span><br><span class="line">    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</span><br><span class="line"></span><br><span class="line">    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当一个请求被处理完毕后，会执行以上代码块进行维护，其实就是下图所示的循环</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E5%85%B7%E4%BD%93%E7%BB%B4%E6%8A%A4.png" style="zoom:50%;" />

<p>通过线程间的执行进行维护</p>
<h3 id="五-自定义网络框架"><a href="#五-自定义网络框架" class="headerlink" title="五.自定义网络框架"></a>五.自定义网络框架</h3><p>经历了上述三个过程发现Okhttp框架其实很清晰，下面模仿它的思路自定义一个请求Json数据的网络框架，先上图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6.png" style="zoom:50%;" />

<p>通过核心线程进行维护，和上述的Okhttp思路相似，只不过线程池中的队列不再是无容量的，而是指定了空闲线程数以及容量的队列</p>
<p>说明：由于该Demo涉及到泛型，而Kotlin中个人感觉是不兼容，因此使用Java语言</p>
<ol>
<li><p>首先我们需要先写好线程池部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ThreadPoolManager &#123;</span><br><span class="line">    private LinkedBlockingQueue&lt;Runnable&gt; mQueue = new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    private ThreadPoolExecutor mThreadPoolExecutor;</span><br><span class="line">    public Runnable coreThread = new Runnable() &#123;</span><br><span class="line">        Runnable runn = null;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    runn = mQueue.take();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                mThreadPoolExecutor.execute(runn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private ThreadPoolManager()&#123;</span><br><span class="line">        mThreadPoolExecutor = new ThreadPoolExecutor(3, 10, 15, TimeUnit.SECONDS, new ArrayBlockingQueue&lt; Runnable &gt;(5)</span><br><span class="line">                , new RejectedExecutionHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void rejectedExecution(Runnable runnable, ThreadPoolExecutor threadPoolExecutor) &#123;</span><br><span class="line">                addTask(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mThreadPoolExecutor.execute(coreThread);</span><br><span class="line">    &#125;</span><br><span class="line">    private static  ThreadPoolManager instance = new ThreadPoolManager();</span><br><span class="line">    public static ThreadPoolManager getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addTask(Runnable runnable)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mQueue.put(runnable);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列采用的是阻塞式的，保证同步性，线程安全</p>
<p><strong>核心线程是通过死循环不断监听队列中是否有任务，这和Okhttp通过线程之间的交互连接实现的死循环很类似，此处使用死循环也不会造成很大的开销，毕竟只是一个子线程，只要思路相似即可</strong></p>
</li>
<li><p>封装请求部分</p>
<p>首先需要定义封装请求方法的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IHttpRequest &#123;</span><br><span class="line">    void setUrl(String url);</span><br><span class="line">    void setData(byte[] data);</span><br><span class="line">    void setListener(CallbackListener listener);</span><br><span class="line">    void excute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JsonHttpRequest implements IHttpRequest &#123;</span><br><span class="line">    private String url;</span><br><span class="line">    private byte[] data;</span><br><span class="line">    private CallbackListener mCallbackListener;</span><br><span class="line">    private HttpURLConnection urlConnection;</span><br><span class="line">    @Override</span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">            this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setData(byte[] data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setListener(CallbackListener listener) &#123;</span><br><span class="line">            this.mCallbackListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void excute() &#123;</span><br><span class="line">        URL url = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            url = new URL(this.url);</span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            urlConnection.setConnectTimeout(6000);</span><br><span class="line">            urlConnection.setUseCaches(false);//不使用缓存</span><br><span class="line">            urlConnection.setInstanceFollowRedirects(true);</span><br><span class="line">            urlConnection.setReadTimeout(3080);</span><br><span class="line">            urlConnection.setDoInput(true);</span><br><span class="line">            urlConnection.setDoOutput(true);</span><br><span class="line">            urlConnection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">            urlConnection.setRequestProperty( &quot;Content-Type&quot;,&quot;application/json;charset=UTF-8&quot;);</span><br><span class="line">            urlConnection.connect();</span><br><span class="line">            OutputStream out = urlConnection.getOutputStream();</span><br><span class="line">            BufferedOutputStream bos = new BufferedOutputStream(out);</span><br><span class="line">            bos.write(data);</span><br><span class="line">            bos.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            bos.close();</span><br><span class="line">            if (urlConnection.getResponseCode() == HttpURLConnection.HTTP_OK)&#123;</span><br><span class="line">                InputStream in = urlConnection.getInputStream();</span><br><span class="line">                mCallbackListener.onSuccess(in);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于为什么要封装<code>excute()</code>方法，因为子线程会调用<code>run()</code>方法，最终会调用任务本身的<code>excute()</code>去具体执行任务</p>
</li>
<li><p>封装数据回调</p>
<p>首先定义回调的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface CallbackListener &#123;</span><br><span class="line">    void onSuccess(InputStream inputStream);</span><br><span class="line">    void onFailure();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为网络请求带回来的是<code>InputStream</code>，然后再将流中的数据写入到内存，转换成具体的对象带出去，一般网络请求的用法大抵如此</p>
<p>定义带出数据的类，即将网络请求的数据转换成具体需要的对象回调带出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class JsonCallbackListener&lt;T&gt; implements CallbackListener &#123;</span><br><span class="line">    private Class&lt;T&gt; responseClass;</span><br><span class="line">    private IJsonDataTransforListener listener;</span><br><span class="line">    private Handler mHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">    public JsonCallbackListener(Class&lt;T&gt; responseClass,IJsonDataTransforListener listener)&#123;</span><br><span class="line">        this.responseClass = responseClass;</span><br><span class="line">        this.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(InputStream inputStream) &#123;</span><br><span class="line">            String response = getContent(inputStream);</span><br><span class="line">            final T clazz = JSON.parseObject(response,responseClass);</span><br><span class="line">            mHandler.post(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    listener.onSuccess(clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getContent(InputStream inputStream)&#123;</span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line"></span><br><span class="line">            String line = null;</span><br><span class="line">            while (((line = reader.readLine()) != null)) &#123;</span><br><span class="line">                builder.append(line).append(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是数据回调的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IJsonDataTransforListener&lt;T&gt; &#123;</span><br><span class="line">    void onSuccess(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后还差封装具体的网络请求任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HttpTask&lt;T&gt; implements Runnable &#123;</span><br><span class="line">    private IHttpRequest httpRequest;</span><br><span class="line">    public HttpTask(String url,T requestData,IHttpRequest httpRequest,CallbackListener listener)&#123;</span><br><span class="line">        this.httpRequest = httpRequest;</span><br><span class="line">        httpRequest.setUrl(url);</span><br><span class="line">        httpRequest.setListener(listener);</span><br><span class="line">        String content = JSON.toJSONString(requestData);</span><br><span class="line">        try &#123;</span><br><span class="line">            httpRequest.setData(content.getBytes(&quot;utf-8&quot;));</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        httpRequest.excute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候还需组装一个请求任务，为了体现高度的封装性，再提供一个类进行封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyHttp &#123;</span><br><span class="line">    public static&lt;T,M&gt; void sendJsonRequest(String url,T requestData,Class&lt;M&gt; response,IJsonDataTransforListener listener)&#123;</span><br><span class="line">        IHttpRequest httpRequest = new JsonHttpRequest();</span><br><span class="line">        CallbackListener callbackListener = new JsonCallbackListener&lt;&gt;(response,listener);</span><br><span class="line">        HttpTask httpTask = new HttpTask(url,requestData,httpRequest,callbackListener);</span><br><span class="line">        ThreadPoolManager.getInstance().addTask(httpTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义数据类型，进行实战演练</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyBean&#123;&quot; +</span><br><span class="line">                &quot;resultCode=&quot; + resultCode +</span><br><span class="line">                &quot;, reason=&#x27;&quot; + reason + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int resultCode;</span><br><span class="line"></span><br><span class="line">    public int getResultCode() &#123;</span><br><span class="line">        return resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setResultCode(int resultCode) &#123;</span><br><span class="line">        this.resultCode = resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getReason() &#123;</span><br><span class="line">        return reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReason(String reason) &#123;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String reason;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private String url = &quot;http://apis.juhe.cn/simpleWeather/query&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        OkHttpClient client = new OkHttpClient();</span><br><span class="line">        for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            sendRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sendRequest()&#123;</span><br><span class="line">        MyHttp.sendJsonRequest(url, null, MyBean.class, new IJsonDataTransforListener&lt;MyBean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onSuccess(MyBean myBean) &#123;</span><br><span class="line">                Log.v(&quot;cx&quot;,&quot;返回的数据：&quot;+myBean.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的那个数据回调是否有点像Okhttp中的异步回调呢，经历了以上步骤还是清晰的看出网络访问框架就是这样一层一层封装的，下面上效果图</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83.png"></p>
</li>
</ol>
<blockquote>
<p>可以看到发送的十次请求都有了结果，速度也是很快的</p>
</blockquote>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><blockquote>
<p>经过以上的折磨，我们也大概知道Okhttp的运行原理了，小编也是头一回写网络框架，感觉还不错，只要把握好整体的结构，需要回调带出数据时便定义接口，初级阶段只要清楚原理即可</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/myhttp-demo">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView自定义LayoutManager实现脉脉卡片滑动</title>
    <url>/RecyclerView%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%E5%AE%9E%E7%8E%B0%E8%84%89%E8%84%89%E5%8D%A1%E7%89%87%E6%BB%91%E5%8A%A8.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍了RecyclerView的回收复用流程，熟悉源码是为了自定义做准备，很多时候可以参照系统的写法，本文会通过自定义LayoutManager来实现脉脉中的卡片滑动效果，系统提供的LayoutManager实在单一</p>
</blockquote>
<h3 id="二-通过绘制实现RecyclerView吸顶效果"><a href="#二-通过绘制实现RecyclerView吸顶效果" class="headerlink" title="二.通过绘制实现RecyclerView吸顶效果"></a>二.通过绘制实现RecyclerView吸顶效果</h3><blockquote>
<p>在使用RecyclerView时，通常会关心ViewType展示多种Holder，以及Adapter的数据填充样式，对于ItemDecoration很多时候只会用来实现分割线，如果要实现个性化的绘制可以使用ItemDecoration提供的绘制方法，下面展示Demo效果</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/RecyclerView%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C.gif" style="zoom:50%;" />

<p>这个吸顶效果就是通过ItemDecoration提供的绘制方法实现的</p>
<ol>
<li><p>onDraw</p>
<p>在绘制每个itemView之前绘制，上图中的每个跟着滑动的头部就是在此处绘制</p>
</li>
<li><p>onDrawOver</p>
<p>在绘制了每个itemView之后绘制，上图中固定的顶部在此处绘制</p>
</li>
</ol>
<p>注：根据以上的介绍，itemView可以覆盖onDraw绘制的内容，onDrawOver可以覆盖itemView</p>
<p>实现思路：</p>
<ol>
<li><p>根据三者的覆盖关系，显然onDraw需要额外的空间来绘制头部，因此需要在<code>getItemOffsets</code>预留足够的高度，因为屏幕的宽度是固定的，所以横向预留大小缩减最终itemView的宽度，纵向预留大小增加itemView的高度，所以可以将绘制的可移动的头部归为itemView的一部分。</p>
</li>
<li><p>然后在onDraw方法中通过判断当前itemView是否是一个组的第一个，如果是则绘制头部，因为是第一个，所以肯定在<code>getItemOffsets</code>方法中已经预留了足够的空间用于绘制头部。</p>
</li>
<li><p>在onDrawOver中绘制固定的头部，这里需要额外处理的是固定顶部被推动的效果，如果当前可见的itemView是当前组的最后一个，那么下一个组的头部往上滑动时，需要固定顶部往上推出，推出这个效果其实就是通过改变固定头部的bottom即可，绘制的文本位置取决于bottom的位置，那么这个逻辑如何来确定，因为上面的itemView和绘制的头部差不多大，所以当第一个可见的itemView的下一个位置是一个组的头部时，这时候就需要改变固定头部的bottom</p>
</li>
<li><p>这里还有一个稍微懵的点，顶部被推出时，如何确定绘制文本的基准线，这点在自定义绘制中有提到如何让绘制的文本处于纵向居中，参考<a href="https://wiwiyiyi.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC.html">自定义文本绘制</a>，其实我们只需清楚什么变，什么不变，绘制的文本之所以不会按照预想的位置居中显示，就是因为需要将文本的位置向下移动一个space的距离，博客中有写到这个space的偏移，然后以此时的bottom为准向上移动到预想的中线，再向下偏移一个space即可</p>
</li>
<li><p>画布剪裁，这里RecyclerView设置了paddingTop，所以紫色区域是不能绘制，因此在onDrawOver中绘制文本时需要剪裁画布，剪裁画布通常都会搭配<code>save</code>和<code>restore</code>方法，在此区间内绘制是一层画布，多次剪裁就类似于PS中的图层叠加，<strong>其实剪裁画布很多时候也是为了防止过度绘制</strong>，剪裁的画布只对后面最近的一次绘制有效，而这里绘制文本后不需要再绘制其他内容，所以不需要save和restore</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c.clipRect(left,top,right,top+bottom)</span><br><span class="line">c.drawText(text, left+Utils.dp2px(20),baseLine,mTextPaint)</span><br></pre></td></tr></table></figure></li>
</ol>
<p> <a href="https://gitee.com/wiwiyiyi/improving-repository/blob/master/app/src/main/java/com/bytedance/improvingroad/widget/RVTestDecoration.kt">代码链接</a></p>
<h3 id="三-自定义LayoutManager"><a href="#三-自定义LayoutManager" class="headerlink" title="三.自定义LayoutManager"></a>三.自定义LayoutManager</h3><blockquote>
<p>上面的内容只是一个补充，顺带复习之前的内容，下面将介绍通过自定义LayoutManager实现一个特色卡片拖动效果</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/%E5%8D%A1%E7%89%87%E6%BB%91%E5%8A%A8.gif" style="zoom:50%;" />

<p>这里每个itemView布局简单，就是通过自定LayoutManager来决定每个ItemView的摆放，这里不像LinearLayoutManager那样可以滑动，没有重写<code>scrollVerticallyBy</code>以及<code>scrollHorizontallyBy</code>，滑动效果通过TouchHelper来实现</p>
<p>实现思路：</p>
<ol>
<li><p>唯一不同的是LayoutManager，具体怎么摆放，所以Adapter以及其他操作和普通使用相同</p>
</li>
<li><p>LayoutManager必须重写<code>onLayoutChildren</code>方法，当数据发生改变时，会重新布局，并且还需<code>detachAndScrapAttachedViews</code>处理回收，<code>recycler.getViewForPosition(i)</code>获取对应位置的View，在源码流程中可以看到</p>
</li>
<li><p>测量view，摆放时需要考虑通过ItemDecoration预留的间距<code>layoutDecoratedWithMargins</code></p>
</li>
<li><p>随着展示item的位置，itemView的大小会进行缩放以及移动，这个就靠手动调试，找出合适的值，下面贴出关键代码</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onLayoutChildren(recycler: RecyclerView.Recycler?, state: RecyclerView.State?) &#123;</span><br><span class="line">        //ViewHolder回收复用</span><br><span class="line">        if (recycler == null) &#123;</span><br><span class="line">            Log.e(&quot;onLayoutChildren&quot;, &quot;recycler is null&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        detachAndScrapAttachedViews(recycler!!)</span><br><span class="line"></span><br><span class="line">        val itemCount = itemCount</span><br><span class="line">        val bottomPos = if (itemCount &lt; CardConfig.MAX_SHOW_COUNT) &#123;</span><br><span class="line">            0</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            itemCount - CardConfig.MAX_SHOW_COUNT</span><br><span class="line">        &#125;</span><br><span class="line">        for (i in bottomPos until itemCount) &#123;</span><br><span class="line">            val view = recycler.getViewForPosition(i)</span><br><span class="line">            addView(view)</span><br><span class="line"></span><br><span class="line">            measureChildWithMargins(view, 0, 0)</span><br><span class="line">            val widthSpace = width - getDecoratedMeasuredWidth(view)</span><br><span class="line">            val heightSpace = height - getDecoratedMeasuredHeight(view)</span><br><span class="line"></span><br><span class="line">            // 布局 ---draw -- onDraw ,onDrawOver, onLayout</span><br><span class="line">            layoutDecoratedWithMargins(</span><br><span class="line">                view, widthSpace / 2, heightSpace / 2,</span><br><span class="line">                widthSpace / 2 + getDecoratedMeasuredWidth(view),</span><br><span class="line">                heightSpace / 2 + getDecoratedMeasuredHeight(view)</span><br><span class="line">            )</span><br><span class="line">            var level = itemCount - i -1</span><br><span class="line">            if (level &gt; 0) &#123;</span><br><span class="line">                if (level &lt; CardConfig.MAX_SHOW_COUNT -1) &#123;</span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * level</span><br><span class="line">                    view.scaleX = 1-CardConfig.SCALE_GAP*level</span><br><span class="line">                    view.scaleY = 1-CardConfig.SCALE_GAP*level</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * (level - 1)</span><br><span class="line">                    view.scaleX = 1-CardConfig.SCALE_GAP*(level-1)</span><br><span class="line">                    view.scaleY = 1-CardConfig.SCALE_GAP*(level-1)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人感觉自定义LayoutManager的关键在于知道调用哪个方法进行回收，以及复用时通过哪个方法拿到缓存的View，剩余的操作在于measure以及layout，为了展示出自定义LayoutManager的优势，定义摆放规则会有些思维瓶颈，另外就是定义TouchHelper的CallBack用于在滑动时重绘itemView，只要处于滑动或拖动的过程，onDraw就会被一直调用，刷新绘制</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>先对自定义LayoutManager做一个小结，类比LinearLayoutManager，线性布局，至上而下，而这里是将所有卡片重叠在了一起，从Z轴的角度来说是自里向外进行摆放，并且越靠近外面，卡片就越大，这就是规则。本篇文章比较偏应用，聚焦点在绘制上面，在滑动事件处理时，肯定会重新绘制，这是需要关注的一点，这里的TouchHelper是ItemDecoration的子类，在onDraw时根据滑动距离来影响后面view的大小，详情可以看代码</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/ba7572b130b2814853d00b187b2bd1fc9477388d">代码链接</a></p>
]]></content>
      <categories>
        <category>系统控件</category>
      </categories>
      <tags>
        <tag>系统高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Room-Android中的小型数据库</title>
    <url>/Room-Android%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面已经学习了SharedPreferences以及了解了DataStore两种实现数据永久保存的方式，但如果在项目中频繁的更新修改数据，局部刷新，那么以上两种方式显得十分笨拙，下面介绍JetPack的另外一个永久化保存的方式Room，它是SQLite的抽象，帮助开发者流畅地访问数据库</p>
</blockquote>
<h3 id="二-准备工作-添加依赖"><a href="#二-准备工作-添加依赖" class="headerlink" title="二.准备工作-添加依赖"></a>二.准备工作-添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  def room_version = &quot;2.2.5&quot;</span><br><span class="line"></span><br><span class="line">  implementation &quot;androidx.room:room-runtime:$room_version&quot;</span><br><span class="line">  annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot; // For Kotlin use kapt instead of annotationProcessor</span><br><span class="line">  // Test helpers</span><br><span class="line">  testImplementation &quot;androidx.room:room-testing:$room_version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果你使用的Kotlin进行开发，则将<code>annotationProcessor</code>替换成<code>kapt</code>，除此之外还需在app模块对应的gradle中添加<code>apply plugin: &#39;kotlin-kapt&#39;</code></strong>,这点很重要，我就是配置出错入坑俩小时</p>
<h3 id="三-Room分点详解"><a href="#三-Room分点详解" class="headerlink" title="三.Room分点详解"></a>三.Room分点详解</h3><p>上面已经提到<code>Room</code>是数据库的抽象，所以如何区分一个类是否是实体类<code>Entity</code>、<code>Dao</code>以及<code>DataBase</code>是通过标记来实现，即使用<strong>注解</strong></p>
<ol>
<li><p>Entity</p>
<p>实体，定义了表的结构，下面以Excel为例</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Room/Entity.png" style="zoom: 67%;" />

<p>所以Excel就类似一个数据库，包括查找，删除，插入等操作</p>
<p>下面通过代码展示使用Entity标签构建一个实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">class Word()&#123;</span><br><span class="line">    @PrimaryKey(autoGenerate = true)</span><br><span class="line">    var id = 0</span><br><span class="line">    @ColumnInfo(name = &quot;english_word&quot;)</span><br><span class="line">    lateinit var word:String</span><br><span class="line">    @ColumnInfo(name = &quot;chinese_meaning&quot;)</span><br><span class="line">    lateinit var meaning:String</span><br><span class="line">    constructor(word:String,meaning:String):this()&#123;</span><br><span class="line">        this.word = word</span><br><span class="line">        this.meaning = meaning</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一列的信息即为字段，上面的写法还不够简洁，推荐使用数据类<code>data class</code></p>
</li>
<li><p>Dao</p>
<p>可以理解为一种操作，和数据库有关的所有操作都将封装在用Dao中，而在实际开发中它用于标记接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface WordDao &#123;</span><br><span class="line">    @Insert</span><br><span class="line">    fun inserWords(vararg words: Word)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    fun update(vararg words: Word)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    fun deleteWords(vararg words: Word)</span><br><span class="line"></span><br><span class="line">    @Query(&quot;DELETE FROM WORD&quot;)</span><br><span class="line">    fun deleteAllWords()</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * From WORD ORDER BY ID DESC&quot;)</span><br><span class="line">    fun getAllLiveWords():LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然相关操作不止上面所提供的，只需要明确标签括号内的语句进行添加方法即可</p>
</li>
<li><p>Database</p>
<p>用于标识数据库，标识的是抽象类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Database(entities = [Word::class],version = 1,exportSchema = false)</span><br><span class="line">abstract class WordDataBase :RoomDatabase()&#123;</span><br><span class="line">    companion object&#123; </span><br><span class="line">        var instance:WordDataBase?=null</span><br><span class="line">        fun getInstance(context: Context) = instance?: synchronized(this)&#123;</span><br><span class="line">            instance?:Room.databaseBuilder(context.applicationContext,WordDataBase::class.java,&quot;word_dataBase&quot;).build().also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract fun getWordDao():WordDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个Entity，那么需要写在<code>entities</code>集合中，并且提供对应的<code>getDao()</code>方法，版本号<code>version</code>也很重要，当你增添字段时需要增加版本号，如果要保证数据不丢失，还需搭配<code>migration</code></p>
<p>另外，由于数据库的实例化非常耗资源，所以提供单例</p>
<h3 id="四-Room使用及其架构"><a href="#四-Room使用及其架构" class="headerlink" title="四.Room使用及其架构"></a>四.Room使用及其架构</h3><ol>
<li>使用ViewModel管理界面中的数据</li>
<li>创建一个Repository类进行真正的数据读取与存储操作，ViewModel中也提供相应的方法供外部调用</li>
<li>Dao是支持返回LiveData数据的，因此在Activity/Fragment中添加监听</li>
</ol>
<blockquote>
<p>数据库的读取插入等操作相当耗时，所以不能在主线程中执行，Kotlin开发首选协程，切换到IO线程上执行耗时任务，如果需要返回值并操控UI控件，则用<code>withContext</code>切换线程，此Demo中用到了可变参数，详情可以参考下面的文章</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/174c0e254713">Kotlin中如何使用和传递可变参数</a></p>
<p><strong>下面上代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    lateinit var myViewModel: MyViewModel</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        myViewModel = ViewModelProvider(this,MyViewModelFactory(application)).get(MyViewModel::class.java)</span><br><span class="line">            myViewModel.allWordsLive.observe(this)&#123;words-&gt;</span><br><span class="line">                var text =&quot;&quot;</span><br><span class="line">                words.forEach &#123;</span><br><span class="line">                    text+=it.id.toString() + &quot;:&quot; +it.word + &quot;=&quot; + it.meaning + &quot;\n&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                showText.text = text</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        insert.setOnClickListener &#123;</span><br><span class="line">            val word1 = Word(&quot;Hello&quot;,&quot;你好呀&quot;)</span><br><span class="line">            val word2 = Word(&quot;World&quot;,&quot;世界！&quot;)</span><br><span class="line">            myViewModel.insert(word1,word2)</span><br><span class="line">        &#125;</span><br><span class="line">        clear.setOnClickListener &#123;</span><br><span class="line">            myViewModel.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        modify.setOnClickListener &#123;</span><br><span class="line">            val word = Word(&quot;Hi&quot;,&quot;我是夹克&quot;)</span><br><span class="line">            word.id = 454</span><br><span class="line">            myViewModel.modify(word)</span><br><span class="line">        &#125;</span><br><span class="line">        delete.setOnClickListener &#123;</span><br><span class="line">            val word = Word(&quot;afsdaf&quot;,&quot;hga&quot;)</span><br><span class="line">            word.id = 454</span><br><span class="line">            myViewModel.delete(word)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">class WordRepository private constructor() &#123;</span><br><span class="line">    var allWordsLive: LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class="line">        private set</span><br><span class="line">    var wordDao: WordDao</span><br><span class="line">    private var scope: CoroutineScope</span><br><span class="line">    private val job = Job()</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        val wordDataBase = WordDataBase.getInstance(context.applicationContext)</span><br><span class="line">        wordDao = wordDataBase.getWordDao()</span><br><span class="line">        allWordsLive = wordDao.getAllLiveWords()</span><br><span class="line">        scope = CoroutineScope(Dispatchers.Main + job)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        var instance: WordRepository? = null</span><br><span class="line">        lateinit var context: Context</span><br><span class="line">        fun getInstance(context: Context): WordRepository &#123;</span><br><span class="line">            this.context = context</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(this) &#123;</span><br><span class="line">                    if (instance == null) &#123;</span><br><span class="line">                        instance = WordRepository()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun insert(vararg words: Word) &#123;</span><br><span class="line">        scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            wordDao.inserWords(*words)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun clear() &#123;</span><br><span class="line">        scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            wordDao.deleteAllWords()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun modify(vararg words: Word) &#123;</span><br><span class="line">        scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            wordDao.update(*words)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(vararg words: Word) &#123;</span><br><span class="line">        scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">            wordDao.deleteWords(*words)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ViewModel层的代码省略，也会提供相应的方法进行一层转接，因为如果对数据的真正处理放在ViewModel中的话，会显得很臃肿</p>
</blockquote>
<p>安装app后，会在data/data/包名/databases文件夹中找到相应的文件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Room/dataBase.jpg" style="zoom:50%;" /></li>
</ol>
<h3 id="五-版本迁移"><a href="#五-版本迁移" class="headerlink" title="五.版本迁移"></a>五.版本迁移</h3><blockquote>
<p>如果我们要对数据库中的字段进行增删改等操作时，必须增加版本号的值，另外在创建数据库对象时还需进行版本迁移，迁移有以下两种方式</p>
</blockquote>
<ol>
<li>fallbackToDestructiveMigration()破坏式迁移，暴力地将当前的数据清空，重新构建一个数据库，所以当你重新安装时，之前的数据都丢失了，显然这样是不合理的</li>
<li>addMigrations(MIGRATION_1_2)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val MIGRATION_1_2 = object :Migration(1, 2)&#123;</span><br><span class="line">            override fun migrate(database: SupportSQLiteDatabase) &#123;</span><br><span class="line">                database.execSQL(&quot;ALTER TABLE word ADD COLUMN bar_data INTEGER NOT NULL DEFAULT 1&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  Room.databaseBuilder(context.applicationContext,WordDataBase::class.java,&quot;word_dataBase&quot;).addMigrations(MIGRATION_1_2).build()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Migration()构造函数中传入从原始版本号和新版本号，<code>migrate()</code>方法中写增删改操作</p>
</blockquote>
</li>
</ol>
<p><strong>在SQLite中没有删除字段这一操作，所以如果想要删除某一字段需要经历一下四个步骤</strong></p>
<p>① 创建一个新表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database.execSQL(&quot;CREATE TABLE word_temp (id INTEGER PRIMARY KEY NOT NULL,english_word TEXT,chinese_meaning TEXT)&quot;)</span><br></pre></td></tr></table></figure>

<p>② 将旧表中的数据进行复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database.execSQL(&quot;INSERT INTO word_temp (id,english_word,chinese_meaning) SELECT id,english_word,chinese_meaning FROM word&quot;)</span><br></pre></td></tr></table></figure>

<p>③ 删除旧表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database.execSQL(&quot;DROP TABLE word&quot;)</span><br></pre></td></tr></table></figure>

<p>④ 将新表改名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">database.execSQL(&quot;ALTER TABLE word_temp RENAME to word&quot;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在升级版本肯定会优先选择第二种版本迁移的方式，如果想要了解更多操作数据库的语法建议进行深度学习</p>
</blockquote>
<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><blockquote>
<p>以上是Room的用法展示，因为没学过数据库的操作，所以有点手生，接下来会通过项目进行练习，并学习更多有关数据库的操作，甚至系统性地学习数据库</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Room架构实战——记单词神器</title>
    <url>/Room%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E8%AE%B0%E5%8D%95%E8%AF%8D%E7%A5%9E%E5%99%A8.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面以及了解了Room的基本使用以及搭配使用MVVM架构，下面通过一个小Demo进一步巩固，顺带回顾之前所学知识点，Demo演示效果图如下：</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Room/%E8%AE%B0%E5%8D%95%E8%AF%8D%E7%A5%9E%E5%99%A8show.gif" style="zoom:40%;" />

<p>感觉效果还不错，用来记单词的话我觉得还不错，比较小型，基本的功能也具备用到的知识点如下</p>
<ol>
<li>Room高效访问数据库中的数据</li>
<li>使用MVVM搭配Repository架构</li>
<li>菜单栏的设计</li>
<li>RecyclerView，增加了滑动删除功能，这也是很多app热门使用</li>
<li>封装SharedPreferences存储简单键值对</li>
<li>自定义Dialog</li>
<li>Coroutine协程的使用</li>
</ol>
<h3 id="二-实际开发中坑点与知识点分析"><a href="#二-实际开发中坑点与知识点分析" class="headerlink" title="二.实际开发中坑点与知识点分析"></a>二.实际开发中坑点与知识点分析</h3><p>该Demo不算难，架构也清晰，但也需注意以下几点：</p>
<ol>
<li>LiveData观察的是<strong>底层数据</strong>的改变而不是中间层的引用</li>
<li>时刻注意RecyclerView的特性：回收，当ItemView达到一定数量时，滚动的过程中将不会创建新的ItemView，也就意味着，只会执行<code>onBindViewHolder</code>方法，ItemView之前绑定过的监听事件同样有效，所以监听事件的绑定就放在<code>onCreateViewHolder</code>，这样效率更高</li>
<li>理解RecyclerView中的适配器模式，同一个RecyclerView展示怎样的视图是由Adapter决定的，所以切换多个视图只需准备多个Adapter</li>
<li>清楚什么时候才应该调用<code>notifyDataSetChanged()</code>方法刷新界面，只有当数据库中的数据数量改变时才需要刷新，而单个数据内部的属性即分量改变时不需要调用此方法，该方法本身就相当消耗内存</li>
<li>掌握另一种提示框<code>Snackbar</code>，使用与<code>Toast</code>类似</li>
<li>数据库的模糊匹配搭配LiveData以及适配器模式更换数据达到数据筛选的功能</li>
<li>使用协程虽然在主线程中依然无法实现同步返回数据的功能，但在同一个协程域中可以做到，因此执行耗时任务的方法可以有返回值，只要它的执行线程不在Main线程即可，有了协程，不用去顾虑返回值能不能同步拿到的问题，只需要关心它应不应该有返回值，这是一个需要转换的观念</li>
</ol>
<h3 id="三-心得体会"><a href="#三-心得体会" class="headerlink" title="三.心得体会"></a>三.心得体会</h3><blockquote>
<p>该小Demo融合的知识点实在丰富，并且实际意义也挺大，只可惜，事时间原因不能将它做得更加完善，下面上代码链接</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/recite-words">代码链接</a></p>
]]></content>
      <categories>
        <category>Android实战集</category>
      </categories>
      <tags>
        <tag>Android开发小Demo</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewBing的高级用法</title>
    <url>/ViewBinding%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>在以前的日常开发中，免不了对每个控件的初始化-&gt;findViewById，使用Kotlin的扩展可以避免，但是xml中的id值通常以下划线分割，所以在实际使用时对于我这种强迫症患者来说不友好，很多时候还是会选择findViewById来初始化控件，使用Kotlin扩展还有一个不方便的地方，多个xml可能会存在id重复的情况，管理不方便，所以后续Google不推荐此方式，而是推出了ViewBinding，原理很简单，开启ViewBinding后，会根据xml的命名编译生成对应的Binding类，这个Binding类会和对应的xml进行绑定，解析时只需传入LayoutInflater即可，解析工作交给了Binding类，返回的ViewBinding对象就可以拿到所有的控件信息，个人觉得蛮好用的</p>
</blockquote>
<h3 id="二-ViewBinding的用法升级"><a href="#二-ViewBinding的用法升级" class="headerlink" title="二.ViewBinding的用法升级"></a>二.ViewBinding的用法升级</h3><blockquote>
<p>经过上面的介绍，发现一个问题，通过ViewBinding的解析，不用再使用findViewById，但ViewBinding也是需要我们自己初始化的，因为是编译期生成的Binding类，所以我们只能动态初始化，貌似没有一个模板可以用，前两天，小编在Github上发现了一个ViewBinding的工具类，只能说非常好用，通过指定泛型的方式就可以实现一个模板解析，下面先看用法，改造BaseActivity</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class BaseActivity&lt;VIEW: ViewBinding&gt;: AppCompatActivity() &#123;</span><br><span class="line">    lateinit var binding: VIEW</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        binding = inflateBindingWithGeneric(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        initData()</span><br><span class="line">        initListener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun initData()</span><br><span class="line"></span><br><span class="line">    abstract fun initListener()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类Activity中就可以直接通过binding这个属性来访问控件，免去了一个动态初始化的过程，因为Binding类是编译生成的，所以我们并不知道具体用哪个Binding类来解析，所以肯定会用到泛型，但是它仅仅是一个泛型而已，如何能通过这个泛型来解析呢，这个问题其实就是<strong>泛型+反射</strong>的解决方案</p>
<h3 id="三-原理探析"><a href="#三-原理探析" class="headerlink" title="三.原理探析"></a>三.原理探析</h3><blockquote>
<p>上面提到Binding类是编译生成的，所以运行时一定就存在，存在即可反射调用其内部的方法，通过查看生成的Binding类文件，内部其实就是一些解析方法，并且是静态的，所以传入类型直接反射调用得到具体的Binding对象，反射不难，这里的关键点是<strong>传入具体的Binding类型</strong>，可以看到上面的使用用例，子类在使用时肯定会指定具体的Binding类型，所以这时候我们就可以拿到具体的类型，下面看一下具体操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private fun &lt;VB : ViewBinding&gt; withGenericBindingClass(any: Any, block: (Class&lt;VB&gt;) -&gt; VB): VB &#123;</span><br><span class="line">    var genericSuperclass = any.javaClass.genericSuperclass</span><br><span class="line">    var superclass = any.javaClass.superclass</span><br><span class="line">    while (superclass != null) &#123;</span><br><span class="line">        if (genericSuperclass is ParameterizedType) &#123;</span><br><span class="line">            genericSuperclass.actualTypeArguments.forEach &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return block.invoke(it as Class&lt;VB&gt;)</span><br><span class="line">                &#125; catch (e: NoSuchMethodException) &#123;</span><br><span class="line">                &#125; catch (e: ClassCastException) &#123;</span><br><span class="line">                &#125; catch (e: InvocationTargetException) &#123;</span><br><span class="line">                    throw e.targetException</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        genericSuperclass = superclass.genericSuperclass</span><br><span class="line">        superclass = superclass.superclass</span><br><span class="line">    &#125;</span><br><span class="line">    throw IllegalArgumentException(&quot;There is no generic of ViewBinding.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法就是拿到父类中被指定的具体的泛型类型，可能存在多层继承的情况，所以需要通过一个循环来获取，便捷是便捷了许多，但效率不高，试想如果父类可指定的泛型很多，下面的循环是两层，不仅要遍历所有的父类，还要遍历父类可指定的所有泛型类型，而且每次都会invoke，将拿到的Class对象回调出去，所以会看到多个catch异常处理，但是使用已经很方便了，日常开发中损耗一点效率并无大碍</p>
<p><a href="https://github.com/DylanCaiCoding/ViewBindingKTX">工具地址</a></p>
<h3 id="四-关于反思"><a href="#四-关于反思" class="headerlink" title="四.关于反思"></a>四.关于反思</h3><blockquote>
<p>小编刚开始没想过去看这个原理，因为和泛型、反射挂钩，过于抽象，日常开发中也很少用到反射，说白了就是一种恐惧感罢了，近日心血来潮，偶然接触到关于反射的一些理解，搭配注解进行一些改造，突发觉得反射也就那么回事，多练练手就好，比如下面的ID注入</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object ViewIdInject &#123;</span><br><span class="line">    fun injectView(activity: Activity) &#123;</span><br><span class="line">        activity.javaClass.declaredFields.forEach &#123; field -&gt;</span><br><span class="line">            if (field.isAnnotationPresent(AutoWired::class.java)) &#123;</span><br><span class="line">                val autoWiredId = field.getAnnotation(AutoWired::class.java)</span><br><span class="line">                val view = activity.findViewById&lt;View&gt;(autoWiredId.id)</span><br><span class="line">                field.isAccessible = true</span><br><span class="line">                field.set(activity,view)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了一遍，基本能够想象出基本流程，再写一遍，嗯，就挺好的，对于java高级编程这块只能说多看，多用，多理解，多练手，更憧憬的是APT随心所欲搞一个自己的框架</p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
  </entry>
  <entry>
    <title>Retrofit源码解读</title>
    <url>/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面以及学习了如何使用Retrofit发起常用的网络请求，确实感觉Retrofit是目前来说非常好用的网络框架，虽然它不是独立的，只是对Okhttp的一层封装，下面小编想通过查看源码的方式去了解Retrofit是如何运作的</p>
</blockquote>
<h3 id="二-Retrofit中注解的解析流程"><a href="#二-Retrofit中注解的解析流程" class="headerlink" title="二.Retrofit中注解的解析流程"></a>二.Retrofit中注解的解析流程</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/retrofit%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" style="zoom: 25%;" />

<p>在此就不贴源码了，实在太多，上述流程大致分为以下步骤：</p>
<ol>
<li>通过Method获取到所有的注解并保存</li>
<li>通过一个方法进行解析，此方法在下面列出</li>
<li>通过解析获取到的所有参数以及路径进行构造request，最终还是回到了OkHttpCall上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void parseMethodAnnotation(Annotation annotation) &#123;</span><br><span class="line">     if (annotation instanceof DELETE) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof GET) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof HEAD) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof PATCH) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);</span><br><span class="line">     &#125; else if (annotation instanceof POST) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);</span><br><span class="line">     &#125; else if (annotation instanceof PUT) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);</span><br><span class="line">     &#125; else if (annotation instanceof OPTIONS) &#123;</span><br><span class="line">       parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);</span><br><span class="line">     &#125; else if (annotation instanceof HTTP) &#123;</span><br><span class="line">       HTTP http = (HTTP) annotation;</span><br><span class="line">       parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">     &#125; else if (annotation instanceof retrofit2.http.Headers) &#123;</span><br><span class="line">       String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">       if (headersToParse.length == 0) &#123;</span><br><span class="line">         throw methodError(method, &quot;@Headers annotation is empty.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       headers = parseHeaders(headersToParse);</span><br><span class="line">     &#125; else if (annotation instanceof Multipart) &#123;</span><br><span class="line">       if (isFormEncoded) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isMultipart = true;</span><br><span class="line">     &#125; else if (annotation instanceof FormUrlEncoded) &#123;</span><br><span class="line">       if (isMultipart) &#123;</span><br><span class="line">         throw methodError(method, &quot;Only one encoding annotation is allowed.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       isFormEncoded = true;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>当然这类解析方法还有多个，都是进行具体注解解析，获取到所有参数，用于拼接路径，构建Okhttp请求</p>
<h3 id="三-Retrofit的运作流程"><a href="#三-Retrofit的运作流程" class="headerlink" title="三.Retrofit的运作流程"></a>三.Retrofit的运作流程</h3><p>先上从构建Retrofit对象到发起请求最后返回结果的整体流程图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/retrofit%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" style="zoom: 50%;" />

<blockquote>
<p>相信流程图已经很详细了，下面根据流程图贴出部分源码</p>
</blockquote>
<ol>
<li><p>在Retrofit的建造者模式中，会有一个Platform类，Android手机返回Android()对象，该平台提供了下面的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class MainThreadExecutor implements Executor &#123;</span><br><span class="line">      private final Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void execute(Runnable r) &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因此使用异步请求时，可以将结果返回到UI主线程</p>
</li>
<li><p>使用动态代理模式创建接口的实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(T) Proxy.newProxyInstance(</span><br><span class="line">           service.getClassLoader(),</span><br><span class="line">           new Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">           new InvocationHandler() &#123;</span><br><span class="line">             private final Platform platform = Platform.get();</span><br><span class="line">             private final Object[] emptyArgs = new Object[0];</span><br><span class="line">             @Override</span><br><span class="line">             public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)</span><br><span class="line">                 throws Throwable &#123;</span><br><span class="line">               // If the method is a method from Object then defer to normal invocation.</span><br><span class="line">               if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                 return method.invoke(this, args);</span><br><span class="line">               &#125;</span><br><span class="line">               args = args != null ? args : emptyArgs;</span><br><span class="line">               return platform.isDefaultMethod(method)</span><br><span class="line">                   ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                   : loadServiceMethod(method).invoke(args);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<p>loadServiceMethod(method).invoke(args);此方法开始解析接口中通过注解定义的方法，接下来的流程对应了上面提到的注解解析流程，在此不再赘述</p>
</li>
<li><p>进行网络请求时，是通过具体的CallAdpter调用get方法获取到与之适配的Call对象，并在与之对应的工厂类中调用Okhttp的Call方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123;</span><br><span class="line">    final Executor callbackExecutor;</span><br><span class="line">    final Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      this.callbackExecutor = callbackExecutor;</span><br><span class="line">      this.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void enqueue(final Callback&lt;T&gt; callback) &#123;</span><br><span class="line">      Objects.requireNonNull(callback, &quot;callback == null&quot;);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(</span><br><span class="line">          new Callback&lt;T&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</span><br><span class="line">              callbackExecutor.execute(</span><br><span class="line">                  () -&gt; &#123;</span><br><span class="line">                    if (delegate.isCanceled()) &#123;</span><br><span class="line">                      // Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on</span><br><span class="line">                      // cancellation.</span><br><span class="line">                      callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                      callback.onResponse(ExecutorCallbackCall.this, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</span><br><span class="line">              callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>真正在执行请求的是Okhttp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private okhttp3.Call createRawCall() throws IOException &#123;</span><br><span class="line">    okhttp3.Call call = callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    if (call == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过此方法转换到Okhttp中call对象上，因此最终调用的也是Okhttp中的enqueue方法</p>
</li>
<li><p>若请求成功，则通过parseResponse()方法进行数据转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</span><br><span class="line">   ResponseBody rawBody = rawResponse.body();</span><br><span class="line">   </span><br><span class="line">   // Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span><br><span class="line">   rawResponse =</span><br><span class="line">       rawResponse</span><br><span class="line">           .newBuilder()</span><br><span class="line">           .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">           .build();</span><br><span class="line">   </span><br><span class="line">   int code = rawResponse.code();</span><br><span class="line">   if (code &lt; 200 || code &gt;= 300) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       // Buffer the entire body to avoid future I/O.</span><br><span class="line">       ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">       return Response.error(bufferedBody, rawResponse);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       rawBody.close();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   if (code == 204 || code == 205) &#123;</span><br><span class="line">     rawBody.close();</span><br><span class="line">     return Response.success(null, rawResponse);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);</span><br><span class="line">   try &#123;</span><br><span class="line">     T body = responseConverter.convert(catchingBody);</span><br><span class="line">     return Response.success(body, rawResponse);</span><br><span class="line">   &#125; catch (RuntimeException e) &#123;</span><br><span class="line">     // If the underlying source threw an exception, propagate that rather than indicating it was</span><br><span class="line">     // a runtime exception.</span><br><span class="line">     catchingBody.throwIfCaught();</span><br><span class="line">     throw e;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>转换完成后，通过success()方法回调带出结果</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>经过以上流程，也大致对Retrofit的运作原理有了一定的了解，结合流程图会更清晰。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>SharedPreference与DataStore</title>
    <url>/SharedPreference%E4%B8%8EDataStore.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面已经学习了ViewModel，其最大的优势就是可以管理界面的数据，比如屏幕旋转时保存数据等，但如果退出app后，数据依然消失，如果我们想永久保存用户的登录信息如用户名以及密码等要另择它法，本篇文章将介绍<code>SharedPreferences</code>和<code>DataStore</code>两种永久保存数据的方式，它们的本质都是将数据保存至SD卡中的文件</p>
</blockquote>
<h3 id="二-SharedPreferences存储方式"><a href="#二-SharedPreferences存储方式" class="headerlink" title="二.SharedPreferences存储方式"></a>二.SharedPreferences存储方式</h3><p><code>SharedPreferences</code>在实际应用中十分简单，它是通过key-value键值对的形式来存储数据，但缺陷也挺大，所以JetPack推出了<code>DataStore</code>，在写小项目时，我们通常会将<code>SharedPreferences</code>进行封装，并提供单例进行数据的存储以及读取，这样会方便很多</p>
<blockquote>
<p>存储数据和读取数据首先都会获取到<code>SharedPreferences</code>的对象，并同时生成存储数据的文件，值得注意的一点是，<code>SharedPreferences</code>是Context提供的，所以要获取对象得使用一个context，我们习惯性的会将activity作为context，但这样会导致<code>内存泄漏</code>，比如activity销毁了，<code>SharedPreferences</code>中记录的还是那个context，所以在此我们使用<code>applicationContext</code>，它本身是单例，最顶层，伴随着整个app，所以很合适</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val preference = mContext?.getSharedPreferences(FILE_NAME,Context.MODE_PRIVATE)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其次是文件的存储读取模式，通常选取私有的，供当前的app进行操作</p>
</blockquote>
<ol>
<li><p>存储数据</p>
<p>写入数据是通过<code>editor</code>来操作，通过其提供的put方法来存入具体的数据，最后进行提交</p>
<p>提交有两种方式，一是<code>apply()</code>，而是<code>commit()</code>，但推荐使用<code>apply()</code>，因为apply采用的是非同步的提交，如果有多个editor同时提交数据的话，它会以最后提交的那个数据写入文件，而commit是同步的，意思是每次提交都会写入文件，效率太低</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun savePassWord(pwd:String)&#123;</span><br><span class="line">        val preference = mContext?.getSharedPreferences(FILE_NAME,Context.MODE_PRIVATE)</span><br><span class="line">        preference?.edit()?.apply &#123;</span><br><span class="line">            putString(KEY,pwd)</span><br><span class="line">            apply()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取数据</p>
<p>读取数据只需要获取<code>SharedPreferences</code>的对象即可，再根据键获取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun getPassWord():String?&#123;</span><br><span class="line">        val preference = mContext?.getSharedPreferences(FILE_NAME,Context.MODE_PRIVATE)</span><br><span class="line">        return preference?.getString(KEY,null)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>具体使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//存入密码</span><br><span class="line">SharedPreferenceUtil.getInstance(applicationContext).savePassWord(&quot;123456&quot;)</span><br><span class="line">//取出密码</span><br><span class="line">val pwd = SharedPreferenceUtil.getInstance(applicationContext).getPassWord()</span><br><span class="line">Log.v(&quot;cx&quot;,&quot;密码是：$pwd&quot;)</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/SharedPreferences/SharedPreference%E5%AD%98%E5%82%A8.png" style="zoom: 50%;" /></li>
</ol>
<h3 id="三-DataStore-Preferences-DataStore"><a href="#三-DataStore-Preferences-DataStore" class="headerlink" title="三.DataStore-Preferences DataStore"></a>三.DataStore-Preferences DataStore</h3><blockquote>
<p>DataStore是JetPack系列中的一员，官网推出它旨在替代SharedPreferences，但就目前而言，我觉得其使用不方便，毕竟才出不久，不是很成熟，特别是Proto DataStore配置相当繁琐，小编还未成功配置，日后有时间会再次尝试并补充</p>
</blockquote>
<p>本次先演示Preferences DataStore的基本使用，该方式同SharedPreferences一样通过键值对的方式存储基本数据，但最大的不同是Preferences DataStore是基于Flow读取数据，并且读和写都支持协程，本世纪是协程的时代，所以还是建议掌握DataStore的基本使用，虽然它目前不太方便，下面进行详解</p>
<p><strong>存入和读取数据首先得需要通过<code>context</code>创建DataStore对象，另外还需通过<code>preferencesKey</code>创建Key</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private val FILE_NAME = &quot;userInfor&quot;</span><br><span class="line">private val KEY1 = &quot;user_name&quot;</span><br><span class="line">val dataStore = mContext?.createDataStore(FILE_NAME)</span><br><span class="line">val name = preferencesKey&lt;String&gt;(KEY1)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>存入数据</p>
<p>通过<code>edit</code>代码块，类似于数组存值的方式进行写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suspend fun saveData(data:String)&#123;</span><br><span class="line">        val dataStore = mContext?.createDataStore(FILE_NAME)</span><br><span class="line">        val name = preferencesKey&lt;String&gt;(KEY1)</span><br><span class="line">        dataStore?.edit &#123;</span><br><span class="line">            it[name] = data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取数据</p>
<p>通过dataStore.data获取到Flow类型包装后的值，虽然Flow是以异步的方式读取数据，但也有不方便的地方，由于Flow的异步机制，猜测其开启了一个协程，并且是阻塞式的，所以如果Flow没有结束便会阻塞后面的代码进行，需要通过<code>withTimeoutOrNull</code>设置延迟时间来手动结束，这是第一点，第二点是想要返回具体的数据而不是Flow类型，还需通过<code>collect</code>代码块进行转换，综上dataStore确实使用起来没有SharedPreferences那样简单，下面贴出代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suspend fun getData():String?&#123;</span><br><span class="line">        val dataStore = mContext?.createDataStore(FILE_NAME)</span><br><span class="line">        val name = preferencesKey&lt;String&gt;(KEY1)</span><br><span class="line">        val data = dataStore?.data?.map &#123;</span><br><span class="line">            it[name]</span><br><span class="line">        &#125;</span><br><span class="line">        var result:String?=null</span><br><span class="line">        withTimeoutOrNull(300) &#123;</span><br><span class="line">            data?.collect &#123;</span><br><span class="line">                result = it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><a href="https://blog.csdn.net/vitaviva/article/details/104103958">有关Flow的介绍可以参考该篇文章</a></p>
<blockquote>
<p>最后暂时只能先写到这里了，Proto dataStore尚在研究中，相信它的功能更强大，毕竟能存储对象，可以将多个值封装起来，而不用具体分类存哪些数据，相信不久的将来，DataStore会做得更好</p>
</blockquote>
<p>   <strong>Preferences DataStore封装后的全部代码</strong></p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class PreferenceDataStore &#123;</span><br><span class="line">    private val FILE_NAME = &quot;userInfor&quot;</span><br><span class="line">    private val KEY1 = &quot;user_name&quot;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        private var instance:PreferenceDataStore?=null</span><br><span class="line">        private var mContext:Context?=null</span><br><span class="line">        fun getInstance(context: Context):PreferenceDataStore&#123;</span><br><span class="line">            mContext = context</span><br><span class="line">            if (instance==null)&#123;</span><br><span class="line">                synchronized(this)&#123;</span><br><span class="line">                    if (instance==null)&#123;</span><br><span class="line">                        instance = PreferenceDataStore()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    suspend fun saveData(data:String)&#123;</span><br><span class="line">        val dataStore = mContext?.createDataStore(FILE_NAME)</span><br><span class="line">        val name = preferencesKey&lt;String&gt;(KEY1)</span><br><span class="line">        dataStore?.edit &#123;</span><br><span class="line">            it[name] = data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    suspend fun getData():String?&#123;</span><br><span class="line">        val dataStore = mContext?.createDataStore(FILE_NAME)</span><br><span class="line">        val name = preferencesKey&lt;String&gt;(KEY1)</span><br><span class="line">        val data = dataStore?.data?.map &#123;</span><br><span class="line">            it[name]</span><br><span class="line">        &#125;</span><br><span class="line">        var result:String?=null</span><br><span class="line">        withTimeoutOrNull(2000) &#123;</span><br><span class="line">            data?.collect &#123;</span><br><span class="line">                result = it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>使用DataStore存入数据会生成下图所示文件</strong></p>
   <img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/SharedPreferences/dataStore.jpg" style="zoom:50%;" />]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>ViewPager2的使用</title>
    <url>/ViewPager2%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在学习了系统的一个高级U<code>RecyclerView</code>后，小编今天又学习了<code>ViewPager2</code>，它在项目中的使用也是相当频繁的，并且也可以当<code>RecyclerView</code>使用，也可以作为app的一个二级入口，现在的app都使用了这个，底部导航属于一级入口，而一个页面内左右滑动还可以有很多页面，这就是二级入口，此外，<code>ViewPager2</code>用来浏览图片也是相当的香，下面开始教程</p>
</blockquote>
<h3 id="二-用法一：App二级入口"><a href="#二-用法一：App二级入口" class="headerlink" title="二.用法一：App二级入口"></a>二.用法一：App二级入口</h3><p>此处就不展示搭配底部导航栏的一级入口了</p>
<ol>
<li><p>首先创建几个页面，这里的页面都是Fragment</p>
</li>
<li><p>在搭建界面时，需要下载viewPager2，下载完毕后，先拖入一个<code>TabLayout</code>，它是一个顶部导航栏，和ViewPager中的各个页面相关联，在拖入一个<code>viewPager2</code>在它下面</p>
</li>
<li><p>搭建好界面后就是绑定界面，viewPager2和RecyclerView类似，同样通过一个适配器来决定展示什么内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class viewPagerAdapter(fragmentActivity: FragmentActivity) :</span><br><span class="line">    FragmentStateAdapter(fragmentActivity) &#123;</span><br><span class="line">    override fun getItemCount() = 3</span><br><span class="line"></span><br><span class="line">    override fun createFragment(position: Int) = when (position) &#123;</span><br><span class="line">        0 -&gt; RotateFragment()</span><br><span class="line">        1 -&gt; ScaleFragment()</span><br><span class="line">        else -&gt; TranslateFragment()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个方法是返回ViewPager中需要展示的页面数量，第二个方法是根据滚动的位置即当前是第几个页面来创建对应的Fragment显示页面</p>
</blockquote>
</li>
<li><p>给<code>viewPager2</code>设置adapter，并绑定顶部导航</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewpager2.adapter = viewPagerAdapter(this)</span><br><span class="line">TabLayoutMediator(tablayout,viewpager2)&#123; tab: TabLayout.Tab, i: Int -&gt;</span><br><span class="line">            when(i)&#123;</span><br><span class="line">                0-&gt;tab.text = &quot;旋转&quot;</span><br><span class="line">                1-&gt;tab.text = &quot;缩放&quot;</span><br><span class="line">                else-&gt;tab.text = &quot;移动&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.attach()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据当前是第几个页面来给顶部导航栏设置标题</p>
</blockquote>
</li>
</ol>
<p><strong>以上便是viewPager2作为二级入口的用法，流程其实很简单，下面展示效果</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/viewPager2show.gif" style="zoom: 33%;" />

<blockquote>
<p>在tabLayout和viewPager2之间加一条分隔线效果如图所示，tabLayout的<code>tabIndicatorColor</code>属性可以设置顶部导航栏的下划线颜色，三个Fragment较为简单，中央放置一张图片，并给它添加属性动画</p>
</blockquote>
<h3 id="三-用法二：浏览图片"><a href="#三-用法二：浏览图片" class="headerlink" title="三.用法二：浏览图片"></a>三.用法二：浏览图片</h3><blockquote>
<p>对于此用法，个人感觉和<code>RecyclerView</code>并无区别，<code>ViewPager2</code>同样采用的是适配器模式，展示什么样的内容完全由adapter来决定，使用步骤和<code>RecyclerView</code>基本一样，下面开始撸码</p>
</blockquote>
<ol>
<li><p>创建单个视图的布局文件</p>
</li>
<li><p>创建适配器adapter类，此处依旧使用RecyclerView中的ListAdapter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class PagerPhotoListAdapter: ListAdapter&lt;PhotoItem, PagerPhotoListAdapter.PagerPhotoViewHolder&gt;(DiffCallBack) &#123;</span><br><span class="line">    object DiffCallBack:DiffUtil.ItemCallback&lt;PhotoItem&gt;()&#123;</span><br><span class="line">        override fun areItemsTheSame(oldItem: PhotoItem, newItem: PhotoItem): Boolean &#123;</span><br><span class="line">            return oldItem === newItem</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun areContentsTheSame(oldItem: PhotoItem, newItem: PhotoItem): Boolean &#123;</span><br><span class="line">            return oldItem.id == newItem.id</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    class PagerPhotoViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PagerPhotoViewHolder &#123;</span><br><span class="line">        LayoutInflater.from(parent.context).inflate(R.layout.pager_photo_view,parent,false).also &#123;</span><br><span class="line">            return PagerPhotoViewHolder(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: PagerPhotoViewHolder, position: Int) &#123;</span><br><span class="line">        Glide.with(holder.itemView)</span><br><span class="line">            .load(getItem(position).largeImageURL)</span><br><span class="line">            .placeholder(R.drawable.photo_placeholder)</span><br><span class="line">            .into(holder.itemView.pagerPhoto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置适配器的同时提供数据源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PagerPhotoListAdapter().apply &#123;</span><br><span class="line">            viewPager2.adapter = this</span><br><span class="line">            submitList(photoList)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>以上是使用ViewPager2浏览图片的步骤，本次的Demo是在上次的简易画廊的基础上进行的优化，将第二个页面改装成了浏览图片，为了实现效果，还要设置以下viewPager2的两个事件监听</p>
</blockquote>
<p><strong>当页面被滑动时，即切换图片的监听事件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() &#123;</span><br><span class="line">            override fun onPageSelected(position: Int) &#123;</span><br><span class="line">                super.onPageSelected(position)</span><br><span class="line">                photoTag.text = getString(R.string.photoTag, position + 1, photoList?.size)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>设置底部的页数显示随着左右滑动更新</p>
<p><strong>设置当前应该显示数据源中哪个内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewPager2.setCurrentItem(arguments?.getInt(&quot;PHOTO_POSITION&quot;) ?: 0, false)</span><br></pre></td></tr></table></figure>

<p>从其他页面跳转到此页面时触发</p>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/viewPager2%E6%B5%8F%E8%A7%88%E5%9B%BE%E7%89%87.gif" style="zoom: 33%;" />

<p>代码中使用到了动态申请权限，小编在之前的文章也写到过，由于在低版本的Android系统中，文件的写入属于危险权限，所以此处添加了动态申请权限，并且还搭配了协程</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>以上是ViewPager2的两种用法，学会使用它相信对于项目开发是如鱼得水，确实很好用</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/viewpager2-gallery">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>系统高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>error: src refspec master does not match any.</title>
    <url>/error-src-refspec-master-does-not-match-any.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>可以说Git版本控制在项目开发中相当重要，但有本地仓库还不够，还得将我们的仓库部署到远端，以实现合作，这类教程文章网上很多，在此不作赘述，小编今天在进行本地仓库部署到远端时发生了标题所示的错误，网上的博客都没效，经过两个小时的折腾才测试出问题所在，个人感觉是Windows系统的问题，只能说Mac从不会发生今天这种奇奇怪怪的问题。</p>
</blockquote>
<h3 id="二-原因分析"><a href="#二-原因分析" class="headerlink" title="二.原因分析"></a>二.原因分析</h3><p>小编按照某篇使用Mac实现本地仓库部署到远端的教程，在Github上创建了一个具有<strong>README.md、LISCENSE、.gitignore</strong>三个基本初始化的文件的一个仓库，问题就出在这儿，经过后面的测试，发现在Windows系统上将这样的一个仓库拷贝到本地，然后在push到远端时发生标题所示错误，这个时候本地仓库并不是空的，但就是推送失败，url也是正确的，所以强制要求在创建github仓库时必须创建一个空仓库，还挺无语的，不过没关系，上述的三个初始化文件可以后面自己手动添加，下面介绍一下从clone到push的完整过程。</p>
<h3 id="三-本地仓库和远端仓库clone-gt-push的全过程"><a href="#三-本地仓库和远端仓库clone-gt-push的全过程" class="headerlink" title="三.本地仓库和远端仓库clone-&gt;push的全过程"></a>三.本地仓库和远端仓库clone-&gt;push的全过程</h3><ol>
<li><p>在github上创建一个<strong>空仓库</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git1.png" style="zoom:50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git2.png" style="zoom: 33%;" /></li>
<li><p>将远端仓库clone到本地文件夹中(通常是某个Android项目的根目录)</p>
<p>通过<code>git clone 仓库地址</code>命令来下载远端仓库以及对应的文件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git3.png" style="zoom:50%;" /></li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git4.png" style="zoom: 50%;" />

<p>​        将拷贝的文件夹下的所有内容复制到项目根目录后，删除拷贝的文件夹，那么此时，项目根目录就是本地仓库，并且与远端仓库一一        对应</p>
<ol start="3">
<li><p>通过<code>git add .</code>将项目根目录的文件添加到缓存区中</p>
</li>
<li><p><code>git commit -m 推送说明</code>将缓存区中的文件提交到本地仓库中</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git5.png" style="zoom: 67%;" /></li>
<li><p>最后通过<code>git push origin master</code>将本地仓库部署到远端</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git6.png"></p>
</li>
</ol>
<p>经过以上步骤，我们就完成了本地仓库关联远端仓库并部署到远端的操作</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git7.png" style="zoom: 50%;" />

<p>可以看到README文件确实提交上去了，gitignore文件不需要手动创建，Android Studio会帮我们创建好的，所以只需要push即可，最后是LICSENSE文件的创建</p>
<p>①点击add file</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git8.png" style="zoom:50%;" />

<p>②填入文件类型后会出现选择对应模板的选项</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git9.png"></p>
<p>③具体创建</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git10.png" style="zoom: 50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git11.png" style="zoom:50%;" />

<p>④刷新后可以发现创建成功</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/git12.png" style="zoom:50%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><p>可以说以上步骤算是Git版本控制的入门，基本的使用就是pull和push，如果还想了解如何创建分支以及使用分支(合并)等操作建议参考其他博客，但入门还是很重要的，得明白每一步到底做了些什么</p>
]]></content>
      <categories>
        <category>问题总结集</category>
      </categories>
  </entry>
  <entry>
    <title>ViewPager实现Banner轮播图效果</title>
    <url>/ViewPager%E5%AE%9E%E7%8E%B0Banner%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>电商类App基本上都会有一个Banner(轮播图)来展示图片广告信息，日常开发中有时也用得着，所以就抽空去玩了玩，github上已经有封装好的Banner供使用，下面先从一般的ViewPager实现开始，主要是介绍用法</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/Banner%E6%95%88%E6%9E%9C.gif"></p>
<h3 id="二-ViewPager实现Banner轮播图片"><a href="#二-ViewPager实现Banner轮播图片" class="headerlink" title="二.ViewPager实现Banner轮播图片"></a>二.ViewPager实现Banner轮播图片</h3><blockquote>
<p>要说轮播，RecyclerView和ViewPager都可以轻松实现，搞一个定时器不断变化当前的Position即可，但是要无限轮播还要搭配指示器的变化还是得费点功夫</p>
</blockquote>
<p>这里就不粘代码了，附上代码链接，下面主要理一下思路</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/49062104ab8a6f51c5c450d936099eaa8b2dd21c">ViewPager实现Banner链接</a></p>
<ol>
<li>准备一个存储所有ImageView的数组，这是后续添加到ViewPager中的数据源，遍历添加的同时添加一个指示器(点)，每个指示器有两种状态，通过selector的xml配置即可</li>
<li>通过一个线程无限轮询，每隔一段时间切换到主线程改变当前展示的Item，因为是无限轮播，所以当前的Index索引会不断累加</li>
<li>实现PagerAdapter，在<strong>instantiateItem</strong>提供视图的方法中通过取余的方式拿到当前应该展示哪个ImageView，在添加之前还得在<strong>destroyItem</strong>视图移除方法中将当前ImageView的parent移除，否则无法添加进去，PagerAdapter的功能就是提供视图来源</li>
<li>添加页面滑动监听，在轮询线程中通过改变当前展示视图的Index，这是动力源，切换到下一个视图时，需要更新文本信息和指示器的状态，所以需要一个全局变量用来标识上一个索引值</li>
</ol>
<blockquote>
<p>此方式可以实现无限轮播且改变相应信息的效果，但缺点很明显，没有移植性，封装性也没有，让Activity中的代码难以管理，但理解了基本原理即可：轮询线程改变索引(动力源)+PagerAdapter(视图来源)+页面滑动监听(信息更新)</p>
</blockquote>
<h3 id="三-Banner的封装以及高级用法"><a href="#三-Banner的封装以及高级用法" class="headerlink" title="三.Banner的封装以及高级用法"></a>三.Banner的封装以及高级用法</h3><p>上面实现的Banner不仅缺点明显，并且效果也普通，因为没有动画和其他附加效果，下面介绍一下github上比较🔥的一个Banner开源库，看源码其实就是封装加扩展，下面还是介绍用法</p>
<ol>
<li><p>指示器</p>
<p>该开源库提供了如下几种指示器的样式，原理就是自定义View，根据当前的选中Index做绘制</p>
<ul>
<li>NumIndicator：数字指示器，自定义的，1/6的样式，比较简单，就是绘制文本</li>
<li>CircleIndicator：圆形指示器，如果需要定义自己的样式，比如选中和非选中的大小，指示器间的间距，需要继承并自定义，这是不太好的地方，应该提供一个接口供用户配置</li>
<li>DrawableIndicator：将某个小的icon图标作为指示器样式</li>
<li>RectangleIndicator：不连贯的圆角矩形指示器</li>
<li>RoundLinesIndicator：圆形线条指示器</li>
</ul>
<p>注：DrawableIndicator有坑，它只能外置，单独作为一个View，然后获取到indicator对象赋值给Banner，其他三个都可以通过new的方式注入给Banner</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binding.banner.setAdapter(ImageAdapter(bannerModels))</span><br><span class="line">						//.setIndicator(RoundLinesIndicator(context))</span><br><span class="line">            .setIndicator(binding.indicator,false)</span><br><span class="line">                //添加画廊效果</span><br><span class="line">            .setBannerGalleryEffect(50, 10)                        </span><br></pre></td></tr></table></figure>

<p>对比可以看到区别，一个是来自XML布局</p>
</li>
<li><p>页面的切换动画</p>
<ul>
<li>AlphaPageTransformer：透明度变化的切换效果</li>
<li>ScaleInTransformer：当前图片缩小退出</li>
<li>RotateDownPageTransformer：以下边界的中点为圆心进行旋转切换</li>
<li>RotateUpPageTransformer：以上边界边界的中点为圆心进行旋转切换</li>
<li>DepthPageTransformer：当前图片淡出，下一张图片从后面放大展示，营造一种由里向外的感觉</li>
<li>RotateYTransformer：围绕Y轴旋转，整体效果类似于方块于方块之间的切换</li>
<li>ZoomOutPageTransformer：当前图片先缩小再放大，同时伴随平移，有点向进入房间后再出房间</li>
<li>MZScaleInTransformer：内部实现魅族效果使用的，单独使用可能效果不一定好，和Scale效果有点类似</li>
</ul>
<p>注：官网上说可以相互搭配使用，但是会有叠加影响，推荐和AlphaPageTransformer搭配使用，有了透明度的变化可能会更酷</p>
</li>
<li><p>关联视图(Fragment/Activity的生命周期)</p>
<p>当前的视图已经不可见的时候就应该停止轮播</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">banner.addBannerLifecycleObserver(LifecycleOwner owners)</span><br></pre></td></tr></table></figure>

<p>如此更便于管理</p>
</li>
</ol>
<p>总的来说，该库用于实现基本的图片轮播还是很方遍的，我是踩过一点坑，只要效果好也还行</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/banner%E6%95%88%E6%9E%9C.gif"></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>这个库还是蛮不错的，里面的效果都推荐尝试尝试，日常开发基本够用了</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/03e8196762c61bd8df824afc7ac69f6798258e19">代码链接</a></p>
]]></content>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字和ThreadLocal</title>
    <url>/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8CThreadLocal.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>对于线程同步/安全是一定要通过加锁的方式来实现，下面将介绍使用较多的volatile关键字和ThreadLocal(线程本地变量)</p>
</blockquote>
<h3 id="二-volatile关键字"><a href="#二-volatile关键字" class="headerlink" title="二.volatile关键字"></a>二.volatile关键字</h3><blockquote>
<p>volatile的功能简单说就是线程间可见，有以下特性：</p>
</blockquote>
<ol>
<li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ol>
<p>volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2</p>
<p>注：所以volatile只是保证数据的可见性，并不保证安全性，使用场景，一写多读，volatile是比较轻量的一种同步机制</p>
<p>使用比较简单，直接在声明变量时加上该关键字即可，这里一笔带过，Kotlin中是通过注解的方式来标识</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Volatile</span><br><span class="line">var i = 0</span><br></pre></td></tr></table></figure>

<h3 id="三-ThreadLocal"><a href="#三-ThreadLocal" class="headerlink" title="三.ThreadLocal"></a>三.ThreadLocal</h3><blockquote>
<p>ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。与加锁完全不同，加锁是同一时刻只能让一个线程访问变量</p>
</blockquote>
<ol>
<li><p>ThreadLocal的基本使用</p>
<ul>
<li><p>void set(Object value) </p>
<p>设置当前线程的线程局部变量的值。</p>
</li>
<li><p>public Object get() </p>
<p>该方法返回当前线程所<strong>对应的线程</strong>局部变量。</p>
</li>
<li><p>public void remove() </p>
<p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p>
</li>
<li><p>protected Object initialValue() </p>
<p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TestThread(val intLocal: ThreadLocal&lt;Int&gt;,val mId: Int): Thread() &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">        println(&quot;$&#123;currentThread().name&#125;---intLocalValue:$&#123;intLocal.get()&#125;&quot;)</span><br><span class="line">        intLocal.set(intLocal.get()+mId)</span><br><span class="line">        println(&quot;$&#123;currentThread().name&#125;---intLocalValue:$&#123;intLocal.get()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main() &#123;</span><br><span class="line">    val intLocal = object : ThreadLocal&lt;Int&gt;()&#123;</span><br><span class="line">        override fun initialValue(): Int &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i in 1..3) &#123;</span><br><span class="line">        TestThread(intLocal,i).start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ThreadLocal</p>
<p>每个线程内部都有一个ThreadLocalMap，key是ThreadLocal实例，value是其保存的值</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/ThreadLocal%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>在线程内部存存值时，首先拿到当前线程的ThreadLocalMap，然后将当前的ThreadLocal作为key，ThreadLocal包裹的值为value存入，所以就有了上图，多个线程的key是同一个ThreadLocal实例，但value是不同，因为是新建的一个副本，可以看到上面<code>initialValue</code>方法中返回值都是新建的副本，如果没有重写这个方法，或者在赋初值时不是new出来的副本，同样不是线程安全的</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/Entry%E7%BB%93%E6%9E%84.png"></p>
<p>观察一下Entry的结构，继承了弱引用，这点很关键，即便如此也会存在内存泄漏</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png"></p>
<p>根据上面的分析，很容易得出上面的两个引用链，图中的虚线就是Entry继承了弱引用的缘故，如果外部对ThreadLocal的引用解除，发生垃圾回收时ThreadLocal的实例就会被回收，那么此时Entry中的Key就会为null，正因此下次赋值前若发现key==Null,就会对value进行回收，就可以减少内存泄漏，如果ThreadLocal使用完，最好调用remove移除</p>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>volatile比较简单，平时开发中也常用，ThreadLocal倒用的很少，开源框架如EventBus中有见过，需要注意的两个问题就是保存一定要是副本才能保证线程安全，用完后一定要调用remove进行移除防止内存泄漏</p>
</blockquote>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+github搭建博客问题总结</title>
    <url>/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h3><p>为了搭建自己的博客，选择不同于简书平台以及CSDN等的风格样式，我选择了在github上搭建静态网页，windows系统在搭建时bug频频，本文总结了我在搭建过程中遇到的问题以及解决方案</p>
<p><strong>推荐一个前辈的博客，我跟着他搭建还算比较顺利</strong></p>
<p><a href="http://182.254.228.71/">小石头前辈的博客链接</a></p>
<h3 id="2-问题一"><a href="#2-问题一" class="headerlink" title="2.问题一"></a>2.问题一</h3><p>当我们将本地仓库的博客推送到github上时，并进行了秘钥添加，但当访问https://仓库名.github.io时无法访问，这是最近才出现的问题</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/1.png" alt="1"></p>
<p><strong>解决方法如下：</strong></p>
<p>①. <a href="http://tool.chinaz.com/dns?type=1&host=wiwi289.github.io&ip=">查询DNS</a></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/2.png"></p>
<p>②.进入C:\Windows\System32\drivers\etc找到host文件，由于对此文件的修改需要管理员权限，所以将其复制一份到桌面</p>
<p>③.打开复制到桌面的host文件，将查找出来的所有DNS拼接上<strong>仓库名.github.io</strong>并添加到host文件的末尾</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/3.png"></p>
<p>④.再将修改好的host文件移动到etc文件中，替换之前的host</p>
<p><a href="https://blog.csdn.net/qq_32627137/article/details/108046461">参考文章-解决访问github上的个人博客遭到拒绝</a></p>
<h3 id="3-问题二"><a href="#3-问题二" class="headerlink" title="3.问题二"></a>3.问题二</h3><p>我在下载next主题时，使用的是DOS命令，网速特别慢，而且下载失败很多次，都是下载超时，这就让人很头疼，这里不建议使用DOS命令在终端进行下载，你可以直接去官网下载压缩包，然后解压到themes文件夹下，并重命名为next即可，速度快多了，此处我直接在百度网盘上提供next的压缩包</p>
<p><a href="https://pan.baidu.com/s/15mtSV9Ud8psTcYwm9zbeUQ">next压缩包链接</a></p>
<p><strong>提取码：va5q</strong></p>
<h3 id="4-问题三"><a href="#4-问题三" class="headerlink" title="4.问题三"></a>4.问题三</h3><p>在启用next主题后，在本地 <a href="http://localhost:4000/">http://localhost:4000/</a> 进行预览时显示一堆英文符号，没有CSS样式，困扰了我一天，如下图<br><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/4.png" /><br>产生这种现象的原因是hexo 5高版本把 swig 渲染插件删了，需要单独安装，进入到本地博客的文件，右键Git Bash Here</p>
<p>输入<strong>npm i hexo-renderer-swig</strong>安装插件，然后hexo clean ,hexo g ,hexo s就可正常预览</p>
<h3 id="5-问题四"><a href="#5-问题四" class="headerlink" title="5.问题四"></a>5.问题四</h3><p>修改配置时，一定要看清是站点配置文件还是主题配置文件，还有就是很多问题都是由于空格数量或者位置不对产生的，在你不确定需要几个空格时，可以先看下系统板块有多少空格以及空格的位置，这点很关键</p>
<h3 id="6-问题五"><a href="#6-问题五" class="headerlink" title="6.问题五"></a>6.问题五</h3><p>为了让谷歌和百度收录我们的博客，我们需要提交sitemap，小石头前辈写得很详细了，但我在注册谷歌账号的时候，发生了这样一个尴尬的情况，我注册成功谷歌邮箱后，说是有异常，让我进行手机号验证，但让人头疼的时，输入手机号无法进行验证，无论是啥手机号都不行，网上都说被封号了，刚注册就封？？？没办法，只能去淘宝买一个谷歌账号，5块钱解决问题，不用担心什么隐私问题，毕竟我们只是需要一个谷歌账号进行收录网站，网站本身就是公开的，所以不用担心，放心购买。</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/Screenshot_20201021_223945_com.tencent.androidqqm.jpg" style="zoom:25%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/Screenshot_20201021_224023_com.taobao.taobao.jpg" style="zoom:25%;" />

<h3 id="7-问题六"><a href="#7-问题六" class="headerlink" title="7.问题六"></a>7.问题六</h3><p>我在coding平台上构建静态网页时，难受了一两个小时，因为coding更新了，在网上找的博客，界面会和你的不一样，我大部分时间花在了找构建静态网页的入口上，下面提供图示</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/7.gif"></p>
<p>左下角的<strong>项目设置</strong>，按照图示找到功能开关，打开<strong>持续集成</strong>和<strong>持续部署</strong>两个开关，然后就会出现持续部署这个选项，再进行实名认证即可创建静态网页，还有创建<strong>普通静态网页</strong>即可，<strong>不需要选择hexo网页</strong>，反而会部署失败，因为hexo类型严格要求格式以及内容，普通的即可，使用没有问题，最后还想说，coding官网的企业微信小哥哥很热心，我问了他好多问题，回答都很及时，在官网的文档末尾能找到他的微信</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/5.png" style="zoom:50%;" />

<p>再重新进行hexo clean、hexo g &amp;&amp; gulp、hexo d，再次向百度提交站点，这时就可以成功抓取信息</p>
<h3 id="8-问题七"><a href="#8-问题七" class="headerlink" title="8.问题七"></a>8.问题七</h3><p>他的博客中还提了将博客部署到gitee即码云上，但由于目前gitee的网页绑定域名服务关闭了，我没打算继续弄，小石头前辈亲自尝试后说部署过后反而降低了博客加载速度，所以不建议部署到gitee上，另外我又尝试了使用腾讯CDN进行加速网页加载，但效果并不明显，第一次加载都很慢，最好的方式是拥有自己的服务器，但目前不考虑，实在太贵了</p>
<h3 id="9-问题八"><a href="#9-问题八" class="headerlink" title="9.问题八"></a>9.问题八</h3><p>在给github上的仓库添加域名解析时，主机的线路类型一定要选择<strong>境外</strong>，不然会和后面绑定coding发生冲突</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/hexo%2Bgithub%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/6.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>搭建属于自己的博客需要很有耐心，并且花连续的时间，最后的效果一定很棒！</p>
</blockquote>
<p><strong>最后再提供几篇参考文章进行美化界面：</strong></p>
<p><a href="https://www.wolfdan.cn/Hexo-Next-Gemini%E4%B8%BB%E9%A2%98%E9%80%8F%E6%98%8E%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E6%9B%B4%E6%94%B9/">Hexo-Next-Gemini主题透明化以及背景图片的更改</a></p>
<p><a href="https://blog.csdn.net/csdnSR/article/details/78300820">修改nexT Pisces主题内容区宽度</a></p>
<p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93797964">Hexo博客NexT主题下添加文章边框阴影效果</a></p>
]]></content>
      <categories>
        <category>问题总结集</category>
      </categories>
      <tags>
        <tag>hexo博客搭建问题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>三种事件回调详解</title>
    <url>/%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在日常开发中，我发现事件的回调常常用到，无论是事件监听还是普通的状态判断(符合某个状态便做某件事)都使用了事件的回调，事件回调分为三种：</p>
<ol>
<li>保存一个类的对象。比如类B的某个成员方法在执行到某个程度时(即满足一个条件)需要用到类A中的一个成员方法，那么类B就需要保存一个类A的对象，通过类A的对象自然可以调用A的成员方法</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83/%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.png"></p>
<p>这是最简单但用得也最少的方式，耦合性不但高，还不灵活(没有复用性)，比如不想调用Teacher中的方法而想调用Father类的方法，那岂不是Student类中还需要保存一个Father类的对象，显然不太好，接口回调可以解决这个问题，提高复用性</p>
<ol start="2">
<li>保存一个接口的对象。其实本质和方式1差不多，但灵活性很高。</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83/%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%832.png"></p>
<p>如果Student的对象现在想向Father类要钱，那么只需要Father类实现接口，并重写<code>callBack()</code>方法，让后重新设置listener的值，让它保存Father类的一个对象即可，如此一想，接口回调是不是灵活了很多</p>
<ol start="3">
<li>在Kotlin中事件回调采用高阶函数，高阶函数解决了很多麻烦，相当好用</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83/%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%833.png"></p>
<p>使用高阶函数回调的优势：</p>
<p>① 高阶函数的回调保存的是函数对象，而不是像前两种保存的是一个类的对象，不会引发安全性问题，这在Android开发界面的生命周期中很关键，一旦Activity被销毁，就意味着对象就没了，在进行回调肯定会发生错误，很严重</p>
<p>② 高阶函数的返回值可以为任意类型，使用的时候可以返回也可以不返回，不像接口回调中的抽象函数，要么有返回要么就没有返回，必须确定下来，不太方便，向Father类要钱，肯定会返回一个值，但原本接口中的方法是没有返回值的，这就很麻烦</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>近年来，Kotlin语言广泛使用，所以建议掌握，对比了以上三种回调方式后，首选的回调方式肯定是高阶函数的回调，真的很好用</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>主要元素</title>
    <url>/%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,5,9,5,9,5,5,5]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>看到此题目后，首先第一个想法是利用桶思想，将它们各自放入一个桶中，然后依次计数，但是发现这样特别耗内存，因为你并不知道给定数组中元素的范围，并且貌似不太好操作，然后便想到了使用键值对的方式进行存储，下面展示代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int majorityElement(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int value = map.get(nums[i])==null ? 1 :map.get(nums[i])+1;</span><br><span class="line"></span><br><span class="line">            map.put(nums[i],value);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">        for (Map.Entry&lt;Integer,Integer&gt; temp:entry)&#123;</span><br><span class="line">            if (temp.getValue()&gt;nums.length/2)&#123;</span><br><span class="line">                return temp.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-摩尔投票法进行优化"><a href="#三-摩尔投票法进行优化" class="headerlink" title="三.摩尔投票法进行优化"></a>三.摩尔投票法进行优化</h3><p>使用摩尔投票算法可以实现时间复杂度为O(n)，控件复杂度为O(1)，简单理解一下什么是摩尔投票法，让数组中每两个数之间进行“厮杀”，遍历数组，假设当前数为票数最多的，如果下一个数和当前数不相等，则票数减1，类似于抵消，直到票数减为0，然后重新指定下一位数作为票数最多的，显然，通过这样两两抵消的方式，只有出现次数最多的那个数可以留到最后，并且它的票数是大于0的，当然也存在票数相等的状况，但就本题目来说，如果存在“主要元素”，那么票数一定大于0，否则返回-1，即没有，下面上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int VotingAlgorithm(int[] nums)&#123;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int temp:nums)&#123;</span><br><span class="line">            if (count==0)&#123;</span><br><span class="line">                num = temp;</span><br><span class="line">                count=1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                if (num==temp)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count&lt;=0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        count = 0;</span><br><span class="line">        for (int temp:nums)&#123;</span><br><span class="line">            if (temp==num) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count&gt;nums.length/2)&#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>逻辑比较简单，这种相互厮杀的思想确实不错</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>本题究其本质是求数组中两个数的最大差值，并且只能是索引大的数减去索引小的数，很容易想到两层for循环解决问题，一旦数据量很大就会超时，毕竟时间复杂度是O(n<sup>2</sup>)，下面介绍动态规划算法，此处不使用一维数组保存每次最大差值，因为也没必要增加空间复杂度，整体思路是：用<code>minPri</code>记录最小的那个价格，用<code>maxVal</code>记录每次最大的差值，因为作为买家，肯定希望在股价最低的那天买入，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">       int minPri = Integer.MAX_VALUE;</span><br><span class="line">       int maxVal = 0;</span><br><span class="line">       for(int i = 0; i&lt;prices.length;i++)&#123;</span><br><span class="line">           if(prices[i]&lt;minPri)&#123;</span><br><span class="line">               minPri = prices[i];</span><br><span class="line">           &#125;else if(prices[i]-minPri&gt;maxVal)&#123;</span><br><span class="line">               maxVal = prices[i]-minPri;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return maxVal;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果难以理解，可以举个例子，[3,2,7,4,1,5]，显然最大价值是5，只需要记住无论最低价格是多少，<code>maxVal</code>记录的始终是最大的差值，就算后面的1比前面的2价格更低，但1后面的价格差值不如2与7的大</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>小编刚开始没有想到动态规划，因为没有理清上一阶和下一阶的依赖关系，其实这里也谈不上依赖关系，只是不断比较<code>maxVal</code>的值罢了</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>事件分发机制以及滑动冲突的处理</title>
    <url>/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>Android UI中比较复杂的两个方面就是自定义和事件分发，此前没有过多时间来沉淀事件分发，这里做一个补充</p>
</blockquote>
<h3 id="二-源码分析"><a href="#二-源码分析" class="headerlink" title="二.源码分析"></a>二.源码分析</h3><p>对于时间分发可从两个维度去分析：</p>
<ol>
<li>从ViewGroup-&gt;View的分发过程：dispatchTouchEvent</li>
<li>从View-&gt;Activity的消费过程：onTouchEvent、onClick</li>
</ol>
<p>简单说就是从根到叶、叶回根的两个过程</p>
<p><strong>对于ViewGroup和View比较容易糊的一点：</strong></p>
<ul>
<li>从类的关系上来说：ViewGroup是View的孩子，所以在看源码的时候，一旦到了叶子节点，dispatchTouchEvent不是分发，而是消费的开始</li>
<li>从视图层级上来说：View是ViewGroup的孩子，Android的UI结构是视图树，所以是从ViewGroup开始的一个递归过程，无论是经典的测量、布局、绘制过程还是事件分发都是如此，因此在看源码的时候需要有这么一个层级关系</li>
</ul>
<p>本文对于事件分发考虑单点触摸：</p>
<ol>
<li>ACTION_DOWN事件：手指初次接触到屏幕时触发</li>
<li>ACTION_MOVE事件：手指在屏幕上滑动时触发，会<strong>多次触发</strong>，多次触发是重点</li>
<li>ACTION_UP事件：手指离开屏幕时触发</li>
<li>ACTION_CANCEL事件：事件被上层拦截时触发(源码中具体分析)</li>
</ol>
<p>只关心Down和Move事件，Down事件的分发是起始点，下图是基本流程，这里就带过了</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" style="zoom: 33%;" />

<p>ViewGroup：既可以处理事件也可以分发事件</p>
<p>View: 只能处理事件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:40%;" />

<p>这里为了好叙述，用上图为例</p>
<p>①Down事件处理流程</p>
<p>第一个层级：总经理(ViewGroup)</p>
<p>第二个层级：总监(ViewGroup)</p>
<p>第三个层级：清洁(View)</p>
<ol>
<li><p>总经理(DecorView)拿到Down事件-&gt;dispatchTouchEvent</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/Down%E4%BA%8B%E4%BB%B6%E5%BC%80%E5%A7%8B.png" style="zoom:30%;" />

<p>点击事件是开端，所以需要重置之前的所有状态</p>
</li>
<li><p>判断事件是否拦截</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%BA%8C%E6%AD%A5.png" style="zoom:35%;" />

<p>第一次进来<code>disallowIntercept</code>必定为false，所以需要通过<code>onInterceptTouchEvent()</code>方法询问总经理是否要拦截此次点击事件</p>
</li>
<li><p>如果需要拦截事件，则需要进行分发或者处理</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%B8%89%E6%AD%A5.png" style="zoom:38%;" />

<p>所以是否进行处理在<code>dispatchTransformedTouchEvent()</code>此方法中，所以进到此方法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E5%9B%9B%E6%AD%A5.png" style="zoom:45%;" />

<p>所以如果拦截，就会调用父类的<code>dispatchTouchEvent</code>进行处理，ViewGroup的父类就是View，View中的处理方式就是OnTouchEvent或者OnClick，文末会进行补充</p>
</li>
<li><p>如果不拦截则分发</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%BA%94%E6%AD%A5.png" style="zoom:37%;" />

<p>可以看到上图，只有ACTION_DOWN事件才会进行分发，这里拿到总经理(DecorView)的<strong>直接子孩子</strong>数量进行遍历分发。比如这里总经理下面就有5个子孩子，对于这些子View肯定是有容器用来承载，装入的顺序也是有讲究的，仔细看后面，遍历其实是倒着来的，也就是说真正意义上的第一个子View是容器里的最后一个元素，具体排序规则是按照Z轴来排的，如果都没有设置Z轴则按先后顺序来倒序装入容器</p>
</li>
<li><p>拿到第一个孩子进行分发前还会进行判断是否可以接受点击事件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E5%85%AD%E6%AD%A5.png" style="zoom:36%;" />

<p>①<code>View#canReceivePointerEvents</code>方法用于判断当前孩子是否可见或者说看不到的话有没有设置过Animation动画</p>
<p>②<code>isTransformedTouchPointInView</code>判断触摸点是否在当前孩子内</p>
<p>如果不满足上述两个条件，就认为当前孩子没有能力进一步处理或分发该事件，就寻找下一个孩子</p>
</li>
<li><p>如果当前的第一个孩子可以接收点击事件，则进行分发，当前分发的ViewGroup对象肯定会从总经理变成总监，因此需要将当前的第一个孩子即总监传入进行新一轮的分发(递归)</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/dwon%E4%BA%8B%E4%BB%B6%E7%AC%AC%E4%B8%83%E6%AD%A5.png" style="zoom:35%;" />

<p>这个方法在拦截里面也会调用，因为是拦截所以传入的child为null，而这传入的是当前的第一个孩子，内部调用的是</p>
<p><code>child.dispatchTouchEvent(event)</code>，之后就会重复上述过程</p>
<p>如果总经理下有一个孩子消费了down事件，则会赋值<code>mFirstTouchTarget</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC%E5%85%AB%E6%AD%A5.png" style="zoom:35%;" />

<p>在<code>addTouchTarget(child, idBitsToAssign)</code>方法中进行标志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br></pre></td></tr></table></figure>

<p>之后break退出遍历</p>
</li>
<li><p>那如果第一个孩子及其内部的孩子没有消费这个down事件，那么就得找总经理下面的第二个孩子(其他总监)，继续循环。如果总经理的孩子都没有处理这个事件，那<code>mFirstTouchTarget</code>还是为Null，就该自己处理，这和拦截是一样的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/down%E4%BA%8B%E4%BB%B6%E7%AC%AC9%E6%AD%A5.png" style="zoom:33%;" />

<p>如果有孩子处理了，那总经理肯定就不需要处理了，走上图流程，注意单点触摸的while循环只会循环一次，这个在addTouchTarget方法中可以看到target.next = null，此处的while循环是为了多点触摸设置的</p>
</li>
</ol>
<p>②Move事件的处理流程</p>
<p>经过down事件的分发，就可以确定一条处理链，比如：总经理-市场总监-市场研发，最终交由市场研发来处理事件，即便如此，move事件也会从总经理开始处理流程</p>
<ol>
<li><p>move事件也会检查当前ViewGroup是否拦截</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B61.png" style="zoom:33%;" /></li>
<li><p>down事件走过的分发流程move事件不会再走(这个过程是寻找谁处理可以处理事件)，进入下图分发给具体的孩子</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B62.png" style="zoom:33%;" />

<p><code>dispatchTransformedTouchEvent</code>此方法又是一个递归，最终调用叶节点的dispatchTouchEvent(event)即处理move事件</p>
</li>
</ol>
<p>③move事件的拦截(事件冲突的处理)</p>
<p>经过上述流程发现，down事件用于寻找谁处理，move事件直接递归分发给寻找到的孩子</p>
<p>这里单独将move事件的拦截抽离出来是为了解决事件冲突</p>
<p>所以大致有两个过程，对于拦截，都会想到孩子有一把尚方宝剑阻止父亲拦截孩子的事件，下面看一下源码</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B63.png" style="zoom:33%;" />

<p>这个图看了很多次了，在判断父亲是否拦截前，还得看孩子的意愿，但是孩子得有机会表达自己的意愿才行，所以父亲是不可以拦截down事件的，<code>disallowIntercept</code>这个标志位是在move分发时才有用，down事件是首次并且会清空标志位，所以只能是move事件才会有用，这个运算过程可以自行百度，就是普通的位运算，所谓的尚方宝剑就是下面的方法，孩子通过parent来调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123;</span><br><span class="line">            // We&#x27;re already in this state, assume our ancestors are too</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Pass it up to our parent</span><br><span class="line">        if (mParent != null) &#123;</span><br><span class="line">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面再看一下父容器拦截move事件后续的流程</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B64.png" style="zoom:33%;" />

<p>如果总经理要拦截，那么cancelChild就为true，进入到<code>dispatchTransformedTouchEvent</code>方法，会将cancelChild传入</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B65.png" style="zoom:30%;" />

<p>所以也就理解了ACTION_CANCEL事件如何触发的</p>
<p>如果本次move事件被父亲拦截了，那下一次move事件又该如何？</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B66.png" style="zoom:33%;" />

<p>因为上一次的move事件被父亲拦截了，那下一次move在经过父亲分发时就默认会被拦截</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/move%E4%BA%8B%E4%BB%B67.png" style="zoom:30%;" />

<p>所以总结一下第一个move事件的作用：</p>
<ol>
<li>因为父亲要拦截，所以调用孩子的cancel事件</li>
<li>将mFirstTouchTarget置为Null</li>
</ol>
<p>后续的move事件都会由父亲拦截，相当于走down事件的第3步，传入的child为null，自己处理</p>
<h3 id="三-滑动事件冲突的解决方案"><a href="#三-滑动事件冲突的解决方案" class="headerlink" title="三.滑动事件冲突的解决方案"></a>三.滑动事件冲突的解决方案</h3><blockquote>
<p>经过对源码的分析，这里做一个小结，其实得弄清楚down事件的寻找target过程，以及move事件的拦截(重点是第一次move事件的处理，第一次move事件其实还没有开始处理具体的业务逻辑，只是在处理标志位)，所以这两个首次很重要，首次down，首次move</p>
</blockquote>
<p>通过以上的分析再来处理滑动冲突就很简单了，两种方案：</p>
<ol>
<li><p>内部拦截(孩子拦截)</p>
<p>之前提到过尚方宝剑，孩子使用尚方宝剑是有前提的，父亲不能拦截down事件，所以在父亲的<code>onInterceptTouchEvent</code>方法中放过down事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123;</span><br><span class="line"> if (ev?.action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        super.onInterceptTouchEvent(ev)</span><br><span class="line">        return false</span><br><span class="line">     &#125;</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>孩子拿到了down事件，就需要使用尚方宝剑告诉父亲不要拦截move事件，当然不是所有事件都不拦截，是有条件的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun dispatchTouchEvent(ev: MotionEvent?): Boolean &#123;</span><br><span class="line">        when(ev?.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(true)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">            		//如果是横向滑动就放出事件，让父亲处理</span><br><span class="line">                if (abs(ev.x-lastX) &gt; abs(ev.y-lastY)) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(false)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastX = ev?.x ?: 0f</span><br><span class="line">        lastY = ev?.y ?: 0f</span><br><span class="line">        return super.dispatchTouchEvent(ev)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以内部拦截法是孩子掌握了事件处理的优先权，给不给父亲处理由孩子决定</p>
</li>
<li><p>外部拦截法(父亲处理)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123;</span><br><span class="line">        when(ev?.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                lastX = ev.x</span><br><span class="line">                lastY = ev.y</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                if (abs(ev.x-lastX) &gt; abs(ev.y-lastY)) &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(ev)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里是以ViewPager嵌套ListView为例展示，只有横向滑动时才拦截，其他事件都可以放给孩子，末尾调用了super的方法，因为ViewPager内部做了处理，小编看了一下，ViewPager是可以拦截Down事件的，但是是横向拖拽的情况，经过调试，没有能触发此种情况，也就是说平常情况下ViewPager是不会拦截down事件的，上面也提到过，<strong>down事件必须可以让孩子拿到</strong>，因为如果孩子连down事件都拿不到，后续的move事件不可能拿到，因为会默认被拦截，详情看move事件的拦截</p>
</li>
</ol>
<p>小结：对比两种方案，如果真的遇到了滑动冲突，会首选外部拦截法，因为内部拦截法需要重写父亲和孩子，过于繁琐，但是如果我们希望上下滑动的同时可以左右滑动就必须使用内部拦截法，因为父亲可以抢孩子的事件，但孩子抢不了父亲的事件，一旦决定由父亲处理了，孩子是不可能拿到后续的move事件，这点通过上述的分析，相信很清晰</p>
<h3 id="四-孩子事件消费补充"><a href="#四-孩子事件消费补充" class="headerlink" title="四.孩子事件消费补充"></a>四.孩子事件消费补充</h3><blockquote>
<p>开头提到过会在文末补充事件的消费，常见的事件响应有onClick和onTouchEvent两个，但后者优先级更高，如果onTouchEvent返回来true，即把点击事件消费了，就不会再调用onClick的监听回调了，下面通过源码简单分析一下调用流程</p>
</blockquote>
<p>因为是View的事件消费，所以直接看dispatchTouchEvent方法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%BF%9B%E9%98%B6/View%E6%B6%88%E8%B4%B91.png" style="zoom:33%;" />

<p>可以看到上述的逻辑判断是短路&amp;连接，如果设置了onTouchListener，那一系列null的判断肯定不满足，一定会调用onTouch方法，如果onTouch返回了true，则onTouch消费了，那么result为true，自然就不会再调用onTouchEvent消费事件</p>
<p>进入到onTouchEvent中，因为onClick是在ACTION_UP中处理的，ACTION_UP中有一个函数<code>performClickInternal()</code>调用，内部接着调用performClick</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">        // We still need to call this method to handle the cases where performClick() was called</span><br><span class="line">        // externally, instead of through performClickInternal()</span><br><span class="line">        notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">        final boolean result;</span><br><span class="line">        final ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            li.mOnClickListener.onClick(this);</span><br><span class="line">            result = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(true);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里就看到了onClick的身影，onClick是没有返回值的，因为一但设置点击事件的监听回调，执行后默认被消费，可以自定义一个View进行测试可以很明显看到onTouch、onTouchEvent、onClick的调用优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyView @JvmOverloads constructor(context: Context, attr: AttributeSet? = null, style: Int = 0): View(</span><br><span class="line">    context,attr,style</span><br><span class="line">) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        initListener()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">        setMeasuredDimension(Utils.dp2px(50),Utils.dp2px(50))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;ClickableViewAccessibility&quot;)</span><br><span class="line">    private fun initListener() &#123;</span><br><span class="line">        setOnClickListener &#123;</span><br><span class="line">            Log.e(&quot;cx&quot;,&quot;OnClickListener&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        setOnTouchListener &#123; v, event -&gt;</span><br><span class="line">            Log.e(&quot;cx&quot;,&quot;OnTouchListener&quot;)</span><br><span class="line">            false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onTouchEvent(event: MotionEvent?): Boolean &#123;</span><br><span class="line">        Log.e(&quot;cx&quot;,&quot;onTouchEvent&quot;)</span><br><span class="line">        //return true就不会调用onClick</span><br><span class="line">        return super.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onTouch&gt;onTouchEvent&gt;onClick</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/effee0768a5370ea281f02e234a0f1de85cf7d2c">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
  </entry>
  <entry>
    <title>今日打卡APP</title>
    <url>/%E4%BB%8A%E6%97%A5%E6%89%93%E5%8D%A1APP.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本Demo用于参加学院举办的软件设计大赛，主要功能是定位打卡，以及图片的上传和下载，和服务器的交互，下面先上效果图</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E9%A1%B9%E7%9B%AE/SignAppShow.gif" style="zoom:150%;" />

<h3 id="二-项目大致结构介绍"><a href="#二-项目大致结构介绍" class="headerlink" title="二.项目大致结构介绍"></a>二.项目大致结构介绍</h3><p>设计此项目时还处在Android开发的基础阶段，所以采用的还是MVC设计模式，当然这也是最后一个MVC项目，页面的搭建使用的是Fragment+Navigation，还用到了抽屉式布局用于展示用户的基本信息，比较简洁，通过<code>RecyclerView</code>展示数据，网络访问框架使用的是<code>OkHttp3</code>，当数据请求成功并返回时，通过<code>Adapter</code>提供的<code>notifyDataSetChanged</code>实现界面刷新，但该方法效率较低，通过<code>ViewPager2</code>来管理二级入口</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E9%A1%B9%E7%9B%AE/APP%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>项目大致结构如上图所示</p>
<h3 id="三-第三方平台"><a href="#三-第三方平台" class="headerlink" title="三.第三方平台"></a>三.第三方平台</h3><p>该项目使用到了如下地方平台：</p>
<ul>
<li>比目科技短信验证</li>
<li>高德SDK</li>
<li>极光推送SDK</li>
<li>阿里的OOS对象存储</li>
</ul>
<p>集成第三方平台容易遇到坑，也算是一个学习过程吧，小编也总结了坑点</p>
<h3 id="四-总结分析"><a href="#四-总结分析" class="headerlink" title="四.总结分析"></a>四.总结分析</h3><p>该Demo也不算小，也不再是以前那些没有网络请求数据的静态APP，该项目开发过程遇到过很多坑点，基本上都是由于数据传递问题导致的空指针，同时也对网络有了更深层次的理解，由于当时处于初级阶段，所以使用不是很成熟，作为最后一个MVC项目，在开发过程中就已经感觉到MVVM的强大了，可惜没有时间重构。该项目比较复杂的地方就是网络请求数据并刷新界面了，由于没有使用ViewModel进行数据的管理，这使得数据的传递变得相当麻烦，通过Handler实现数据的异步回调，相比协程来说是在麻烦不少，需要对不同的数据类型通过Message中的类型来进行标识，数据一旦变多，就很难管理，此外也体会到了<code>Retrofit</code>的便捷，由于使用校园网进行项目演示，而IP地址时常变化，所以将其作为全局变量来管理，但使用Retrofit方便多了，并且很多代码不需要自己实现，总之，此项目为日后进行项目开发奠定了坚实的基础。</p>
]]></content>
      <categories>
        <category>Android项目</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>如果我们不希望一个类暴露给外部，包括创建以及使用，这时候可以选择代理模式，由代理类来完成对象的创建</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>当水果店发展壮大，囊括了海外代购，代购顾名思义需要一个中间人来完成购买任务，下面上类图</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface OrderService &#123;</span><br><span class="line">    fun saveOrder()</span><br><span class="line">&#125;</span><br><span class="line">class OrderServiceImpl: OrderService &#123;</span><br><span class="line">    override fun saveOrder() &#123;</span><br><span class="line">        println(&quot;下单成功订单号：555555&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class OutOrderServiceImpl: OrderService &#123;</span><br><span class="line">    override fun saveOrder() &#123;</span><br><span class="line">        println(&quot;海外代购成功，订单号：6666&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ProxyOrder: OrderService&#123;</span><br><span class="line">    private val outOrderServiceImpl = OutOrderServiceImpl()</span><br><span class="line"></span><br><span class="line">    override fun saveOrder() &#123;</span><br><span class="line">        outOrderServiceImpl.saveOrder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代理类持有不希望暴露给外部使用的类的实例，为了外部调用，代理类同样需要实现接口</p>
</blockquote>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>对比一下装饰模式和代理模式，都是当前对象无法胜任主功能，转给第三方对象来完成主功能，装饰目标是增强自身（第三方是我内部），代理目标是找经纪人/甩锅（外部）</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>使用Idea创建JavaWeb应用以及Servlet的坑</title>
    <url>/%E4%BD%BF%E7%94%A8Idea%E5%88%9B%E5%BB%BAJavaWeb%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8AServlet%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天小编开始了一个新的领域知识的学习-Java后端，在Android开发过程中请求网络的链接指向的就是服务器提供的端口，也叫后端应用，用于处理用户发送的请求，网页端同理，可能很多朋友使用的是Eclipse写后端应用，毕竟是免费的，小编用的是IDEA工具，在创建Servlet应用的过程中坑点特多，下面一一列出</p>
</blockquote>
<h3 id="二-坑点解决"><a href="#二-坑点解决" class="headerlink" title="二.坑点解决"></a>二.坑点解决</h3><ol>
<li><p><strong>An incompatible version [1.1.30] of the APR based Apache Tomcat Native library</strong></p>
<p>这是由于Tomcat安装文件夹bin目录中的<strong>tcnative-1.dll</strong>版本不一致问题，<a href="https://blog.csdn.net/readyyy/article/details/87703334">参考此篇文章下载对应的版本</a>，该博客中说将32位的拖到对应的文件夹，但我的不行，我需要64位的，即<strong>x86</strong>文件夹下对应的文件</p>
</li>
<li><p><strong>运行tomcat时出现 Can’t load IA 32-bit .dll on a AMD 64-bit platform</strong></p>
<p>此问题是由于你安装的jdk和Tomcat版本不一致造成的，可以百度一下自己应该安装多少版本的jdk</p>
</li>
<li><p>即使手动导入了servlet-api.jar也不无法使用HttpServlet类</p>
<p>虽不清楚这是怎么回事但可以将Tomcat安装目录下的lib文件夹中的jar包拷贝到WEB-INF目录下的lib文件夹，然后右键点击<strong>add as Library</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/servlet-api.jar%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98.png" style="zoom: 50%;" /></li>
</ol>
<blockquote>
<p>经历了上述过程，坑点基本上已经解决完毕了，下面我们来看怎么创建Servlet应用，<a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">详情请看此篇文章</a>，其实在导入了servlet包后，可以直接创建Servlet类，很方便，至于Tomcat的配置还需见上面的文章，在此不做赘述</p>
</blockquote>
<h3 id="三-认识javaWeb应用基本的配置"><a href="#三-认识javaWeb应用基本的配置" class="headerlink" title="三.认识javaWeb应用基本的配置"></a>三.认识javaWeb应用基本的配置</h3><ol>
<li><p>可以说Servlet类就是一个后端程序，添加的注解便是访问它的url路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;/swu.cx.web.MyServlet&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(&quot;text/html;charSet=UTF-8&quot;);//设置respponse的文档类型及编码方式</span><br><span class="line"></span><br><span class="line">        PrintWriter out=resp.getWriter();</span><br><span class="line"></span><br><span class="line">        out.print((&quot;&lt;script&gt;alert(\&quot;hello world!\&quot;);&lt;/script&gt;&quot;));</span><br><span class="line"></span><br><span class="line">        out.print(&quot;这是一个简单的例子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本路径拼接上配置注解中的应用路径就是完整的url链接</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/url%E8%A7%A3%E8%AF%BB1.png"></p>
</li>
<li><p>显然上面的方式访问不太合理，常见的链接后缀有php、html、py等，这些是通过WEB-INF目录下的web.xml文件配置的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;MyFirstWebApp&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;swu.cx.web.MyServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;MyFirstWebApp&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/MyWebApp.php&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>以上两对标签是配套使用的，第一对标签仅仅是命个名，对某个具体的Servlet类添加个名字，建立映射关系，第二对标签是根据上面命名的指向更改url中的名称，<code>http://localhost:8080/MyWebApp.php</code>是新的访问链接，使用类名同样能够访问</p>
</li>
<li><p>如何指定Tomcat运行起来默认显示的html页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;welcome-file-list&gt;</span><br><span class="line">     &lt;welcome-file&gt;mydata.jsp&lt;/welcome-file&gt;</span><br><span class="line">&lt;/welcome-file-list&gt;</span><br></pre></td></tr></table></figure>

<p>通过这对标签可以指定显示哪个页面，创建的页面和index.jsp位于同一目录下</p>
</li>
<li><p>如何相应用户的访问</p>
<p>在Servlet类中通过重写<code>doGet</code>和<code>doPost</code>两个方法可以进行相应，显然处理GET请求使用第一个，处理POST请求使用第二个，通过参数中的<code>HttpServletResponse</code>对象进行操作，这里就不进行具体演示了</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>初次接触后端应用的开发，感觉还是蛮有趣的，毕竟可以自己写一些简单GET、POST请求相应供Android开发进行网络测试学习，了解即可</p>
</blockquote>
]]></content>
      <categories>
        <category>问题总结集</category>
      </categories>
  </entry>
  <entry>
    <title>关于Java并发的总结以及CAS</title>
    <url>/%E5%85%B3%E4%BA%8EJava%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8ACAS.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>关于java并发，这里对以往做一个小结，以及补充一些新的东西</p>
</blockquote>
<h3 id="二-Java多线程小结"><a href="#二-Java多线程小结" class="headerlink" title="二.Java多线程小结"></a>二.Java多线程小结</h3><ol>
<li><p>开启线程的方式只有两种：①继承Thread ②实现Runnable并交付Thread，<strong>JDK源码是这样标识的，Callable不算，本质还是Runnable</strong>，Thread是对线程的抽象，Runnable是对任务的抽象</p>
</li>
<li><p>同一个线程对象不能两次调用start启动，否则抛异常，因为存在是否是首次启动的标志判断</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/thread_start.png" style="zoom:50%;" /></li>
<li><p>关于中断线程，不要使用stop、destroy方法，而应该将业务代码放在<code>isInterrupted()</code>判断的代码块中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(isInterrupted()) &#123;</span><br><span class="line"> 	只有没有被设置中断位才执行逻辑</span><br><span class="line"> 	另外如果有休眠操作，还需要捕获异常，并在catch语句中再次interrupt()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>外部调用interrupt()标识要中断线程不再执行业务代码，而Thread.interrupted()不会改变中断标志位，所谓的中断方法并非真正中断了线程，而是改变标识，这里不要通过手动设置一个变量来控制线程是否中断，因为如果存在sleep或者其他阻塞式调用，不起作用</p>
</li>
<li><p>使用join()可以让多个线程<strong>顺序执行</strong></p>
</li>
<li><p>通过setDaemon()可以让用户级线程变成守护线程，当所有用户线程结束，守护线程才会结束，fianlly代码块在守护线程中不一定会执行，但在用户线程是一定会执行</p>
</li>
<li><p>finalize()方法用来进行资源的回收，但系统不推荐在这里面进行，因为有可能不会执行</p>
</li>
<li><p>设置线程的优先级有可能没有意义，取决于操作系统怎么调度，不过可以用，像IO操作、下载操作的优先级可以弄高点</p>
</li>
</ol>
<h3 id="三-关于锁的小结"><a href="#三-关于锁的小结" class="headerlink" title="三.关于锁的小结"></a>三.关于锁的小结</h3><p>关于死锁的原因：</p>
<ol>
<li>存在多个操作者争夺资源，并且操作者的数量大于资源数量</li>
<li>争夺资源的顺序不对</li>
<li>拿到资源不放手</li>
</ol>
<p>官方:</p>
<ol>
<li>互斥条件</li>
<li>请求与保持</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ol>
<p>锁的分类：</p>
<ol>
<li>内置锁(隐式锁)：通过synchronized关键字来实现，要么锁方法，要么锁代码块，出了synchronized的范围才会自动释放锁资源，这里需要注意的是一定要锁同一个对象才会起作用</li>
<li>显示锁：常用的就是ReentrantLock，通过调用lock和unlock来使得这区间的代码块同步</li>
</ol>
<p>根据产生死锁的原因来说，要解决死锁问题，我们可以从2和3入手，通过synchronized改变请求资源的顺序可以解决死锁问题，通过显示锁手动释放资源解决死锁，下面分别简单演示一下</p>
<p>①synchronized合理安排请求顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程一</span><br><span class="line">synchronized(A资源) &#123;</span><br><span class="line">		synchronized(B资源) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程二</span><br><span class="line">synchronized(A资源) &#123;</span><br><span class="line">		synchronized(B资源) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的顺序就是合理的，同一时间只有一个线程才能拿到A锁，进而拿到B锁，如果线程二先拿B锁，那就会发生死锁，相互之间占有锁资源，而又相互请求对方手里的资源</p>
<p>②显示锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程一</span><br><span class="line">if(LockA.tryLock()) &#123;</span><br><span class="line">		try&#123;</span><br><span class="line">				if(LockB.tryLock()) &#123;</span><br><span class="line">						try&#123;</span><br><span class="line">								都拿到了，做业务</span><br><span class="line">						&#125;finally&#123;</span><br><span class="line">							LockB.unLock()</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">					//没拿到B锁，就将A锁释放</span><br><span class="line">					LockA.unLock()</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程二</span><br><span class="line">if(LockB.tryLock()) &#123;</span><br><span class="line">		try&#123;</span><br><span class="line">				if(LockA.tryLock()) &#123;</span><br><span class="line">						try&#123;</span><br><span class="line">								都拿到了，做业务</span><br><span class="line">						&#125;finally&#123;</span><br><span class="line">							LockA.unLock()</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">					//没拿到A锁，就将B锁释放</span><br><span class="line">					LockB.unLock()</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到他们请求的资源顺序其实是不合理的，但是如果另外一个资源被对方拿到，那么就将自己已经拿到的锁资源释放，也就是打破拿到资源不放手</p>
<h3 id="四-关于CAS"><a href="#四-关于CAS" class="headerlink" title="四.关于CAS"></a>四.关于CAS</h3><blockquote>
<p>首先先提一下原子操作，原子操作简单说一气呵成，中间不能被打断，synchronized实现的就是一种原子操作，所以用锁可以实现原子操作</p>
</blockquote>
<p>CAS的全称是Compare And Swap，基本原理是循环一条指令，直到成功为止</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/CAS%E5%8E%9F%E7%90%86.png" style="zoom:50%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/CAS.%E5%AE%9E%E4%BE%8Bpng.png" style="zoom:50%;" />

<p>结合基本流程和一个实例来分析多个线程对一个基本变量的++操作，橙色部分就是CAS指令执行区，只能一个线程执行，箭头标识线程，首先比较原始值是否为0也就是是否有线程已经对它++操作，如果没有，就将它的值更改为1进行++操作。那么下一个线程发现值不等于0，则重新取值，重新计算，重复上述流程，有点类似于一个死循环来控制操作的同步性</p>
<p>根据上面的描述，发现CAS有以下弊端：</p>
<ol>
<li><p>ABA问题：就是说如果有一个线程执行速度很快，先将0变成1，再将1变成0，那么下一个线程看到结果是“值没变，没有线程对它操作”，解决这个问题可以通过打标识的方式，有如下两种：</p>
<p>a.AtomicMarkableReference-&gt;仅仅标识发生了ABA现象</p>
<p>b.AtomicStampedReference-&gt;可以知道发生了几次ABA现象</p>
</li>
<li><p>开销问题：不断地重复操作，肯定会带来一定的开销</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
</li>
</ol>
<p>后续JDK提供了基于CAS的原子类型：AutomicInteger、AutomicBoolean…..</p>
<p>那么我们为什么需要使用到这种原子类型？很多时候如果只是对一个变量简单加加减减操作，使用加锁的方式未免有些重了，这个时候就可以考虑使用原子类型，如果你需要改变多个变量，可以进行封装，通过AtomicReference来管理</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>关于同步的方式，这里介绍了两种，加锁和CAS实现的Automic类型，后续会介绍ThreadLocal，再进行对比三者的优劣，下面再简单说一下线程的几种操作对锁的影响</p>
</blockquote>
<ol>
<li>yield()只是让出时间片，并不会让出其他系统资源，不会释放锁</li>
<li>sleep()同样不会释放当前线程持有的锁</li>
<li>wait()会释放锁</li>
<li>notify/notifyAll对锁不会有影响</li>
</ol>
<p>上面提到两种锁方式，同样也是两种类型</p>
<ol>
<li>synchronized/Lock是悲观锁，考虑最坏的情况，担心会有线程同时修改数据，所以一上来就先锁上</li>
<li>Automic是乐观锁：不管怎样先把数据操作做了，如果有线程修改了重做就是，判断部分是同步过程</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>分治算法是将一个复杂的问题分成两个或者更多的相同或相似的子问题，在把子问题分成更小的子问题…..直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。快速排序和归并排序便使用到了此算法，下面以汉诺塔问题的求解来介绍分治算法</p>
</blockquote>
<h3 id="二-汉诺塔"><a href="#二-汉诺塔" class="headerlink" title="二.汉诺塔"></a>二.汉诺塔</h3><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgedu.lagou.com%2F9909c10440814a6ba9d6bd63be86c8e9.jpg&refer=http%3A%2F%2Fimgedu.lagou.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1619353961&t=858441c25615ce9cb1c65d461d6b5e1a" style="zoom: 80%;" />

<p>游戏描述：有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。</p>
<blockquote>
<p>以两个盘为例，可以发现，一共可以分为3个步骤，首先把A塔底盘上面的所有盘移动到B塔，然后将A塔的底盘移动到C塔，最后将B塔上的所有盘移动到C塔，显然该过程中第一步和最后一步存在递归，第二步只移动一个盘没有递归可言，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void HanoiSolution(int num,char a,char b,char c)&#123;</span><br><span class="line">        if (num==1)&#123;</span><br><span class="line">            System.out.println(&quot;第1个盘从 &quot;+a+&quot;-&gt;&quot;+c);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //1.先将最上面的盘从A移到B塔</span><br><span class="line">            HanoiSolution(num-1,a,c,b);</span><br><span class="line">            //2.将最底部的盘从A移到C塔</span><br><span class="line">            System.out.println(&quot;第&quot;+num+&quot;个盘从 &quot;+a+&quot;-&gt;&quot;+c);</span><br><span class="line">            //3.将B塔的所有盘移到C塔</span><br><span class="line">            HanoiSolution(num-1,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到代码是真的很简单，但为了弄清楚它是如何记录当前是哪个盘，以及怎么移动的，需要进入递归层层跟进，建议以3个盘为例进行推衍，会发现，在递归过程中，通过将三个塔传入不同的参数位置实现盘的的移动，还是挺烧脑的，这类问题只需要从最简单的情况入手，弄清楚解决问题的几大步骤即可</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><p>最后再总结一下分治算法的核心步骤：</p>
<ol>
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li>
<li>解决：若子问题规模较小而容易被解决则直接解决，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解</li>
</ol>
]]></content>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>从今天开始，小编将开始一段新的章程–算法，算法是计算机专业比较重要的一门学科，很多算法思想也会在项目中使用到，下面将以排序中的冒泡排序作为开端</p>
</blockquote>
<h3 id="二-冒泡排序描述"><a href="#二-冒泡排序描述" class="headerlink" title="二.冒泡排序描述"></a>二.冒泡排序描述</h3><p>首先上图演示冒泡排序的原理</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif"></p>
<p>冒泡排序是比较好理解的，分两层循环，内层是控制每一趟，外层是控制总的趟数，如果理不清思路，可以先从一趟冒泡开始，每一趟排序都是让最大的数沉底，每次都是两两比较所以冒泡排序是很稳定的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BubbleSortOptimization &#123;</span><br><span class="line">    static void BubbleSortOptimization(int[] dataArray)&#123;       </span><br><span class="line">        for(int i=dataArray.length-1;i&gt;0;i--)&#123;          </span><br><span class="line">            for(int j = 0; j&lt;i; j++)&#123;</span><br><span class="line">                int temp = 0;</span><br><span class="line">                if (dataArray[j]&gt;dataArray[j+1])&#123;</span><br><span class="line">                    temp = dataArray[j+1];</span><br><span class="line">                    dataArray[j+1] = dataArray[j];</span><br><span class="line">                    dataArray[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是实现冒泡排序最基本的方式，但是缺点很明显，无论是最好的情况还是最坏的情况，时间复杂度都是O(n<sup>2</sup>)，因此做以下算法优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void BubbleSortOptimization(int[] dataArray)&#123;</span><br><span class="line">      boolean hasExchanged = true;</span><br><span class="line">      int lastPosition = dataArray.length-1;</span><br><span class="line">      int k = 0;</span><br><span class="line">      for(int i=dataArray.length-1;i&gt;0&amp;&amp;hasExchanged;i--)&#123;</span><br><span class="line">          hasExchanged = false;</span><br><span class="line">          for(int j = 0; j&lt;lastPosition; j++)&#123;</span><br><span class="line">              int temp = 0;</span><br><span class="line">              if (dataArray[j]&gt;dataArray[j+1])&#123;</span><br><span class="line">                  temp = dataArray[j+1];</span><br><span class="line">                  dataArray[j+1] = dataArray[j];</span><br><span class="line">                  dataArray[j]=temp;</span><br><span class="line">                  hasExchanged = true;</span><br><span class="line">                  k = j;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          lastPosition = k;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此段代码优化了两点，第一点是如果给出的数组是<strong>前半部分排好序的</strong>，那么在某一趟排序中肯定是没有元素交换的，因此可以利用这一点做一个标注，如果某趟排序没有交换元素，就证明已经排好序了，这里通过一个布尔值来标识，第二点是如果某个给定的数组是<strong>后半部分排好序的</strong>，那么可以省略掉几趟排序，我们只需要记录上一趟排序进行<strong>最后一次元素交换的位置</strong>即可，此位置以后都是排好序的，那么下一趟排序就只需要比较到记录位置即可，中间省去了几次比较，也是一种优化方式</p>
</blockquote>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>冒泡排序算是比较简单好用的一种排序方式，初学者都应掌握，下面列出冒泡排序相关性质</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
</tr>
</tbody></table>
<blockquote>
<p>所谓空间复杂度是使用多少<strong>额外的空间</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>动态申请权限以及坑点解决</title>
    <url>/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90%E4%BB%A5%E5%8F%8A%E5%9D%91%E7%82%B9%E8%A7%A3%E5%86%B3.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在涉及到权限管理时发现有些权限即使在清单文件中添加了也不会申请成功，因为那些权限对于Android系统来说是危险的，比如读取公共区域的文件、获取定位等等，那么此时我们就需要<strong>动态申请权限</strong></p>
</blockquote>
<h3 id="二-权限分类"><a href="#二-权限分类" class="headerlink" title="二.权限分类"></a>二.权限分类</h3><p>在进行动态申请权限时，应该了解哪些权限需要动态申请</p>
<ol>
<li><p>普通权限</p>
<p>ACCESS_LOCATION_EXTRA_COMMANDS<br>ACCESS_NETWORK_STATE<br>ACCESS_NOTIFICATION_POLICY<br>ACCESS_WIFI_STATE<br>BLUETOOTH<br>BLUETOOTH_ADMIN<br>BROADCAST_STICKY<br>CHANGE_NETWORK_STATE<br>CHANGE_WIFI_MULTICAST_STATE<br>CHANGE_WIFI_STATE<br>DISABLE_KEYGUARD<br>EXPAND_STATUS_BAR<br>GET_PACKAGE_SIZE<br>INSTALL_SHORTCUT<br>INTERNET<br>KILL_BACKGROUND_PROCESSES<br>MODIFY_AUDIO_SETTINGS<br>NFC<br>READ_SYNC_SETTINGS<br>READ_SYNC_STATS<br>RECEIVE_BOOT_COMPLETED<br>REORDER_TASKS<br>REQUEST_INSTALL_PACKAGES<br>SET_ALARM<br>SET_TIME_ZONE<br>SET_WALLPAPER<br>SET_WALLPAPER_HINTS<br>TRANSMIT_IR<br>UNINSTALL_SHORTCUT<br>USE_FINGERPRINT<br>VIBRATE<br>WAKE_LOCK<br>WRITE_SYNC_SETTINGS</p>
</li>
<li><p>危险权限(共分为9个组)</p>
<p>①group:android.permission-group.CONTACTS<br>  permission:android.permission.WRITE_CONTACTS<br>  permission:android.permission.GET_ACCOUNTS<br>  permission:android.permission.READ_CONTACTS</p>
<p>②group:android.permission-group.PHONE<br>  permission:android.permission.READ_CALL_LOG<br>  permission:android.permission.READ_PHONE_STATE<br>  permission:android.permission.CALL_PHONE<br>  permission:android.permission.WRITE_CALL_LOG<br>  permission:android.permission.USE_SIP<br>  permission:android.permission.PROCESS_OUTGOING_CALLS<br>  permission:com.android.voicemail.permission.ADD_VOICEMAIL</p>
<p>③group:android.permission-group.CALENDAR<br>  permission:android.permission.READ_CALENDAR<br>  permission:android.permission.WRITE_CALENDAR</p>
<p>④group:android.permission-group.CAMERA<br>  permission:android.permission.CAMERA</p>
<p>⑤group:android.permission-group.SENSORS<br>  permission:android.permission.BODY_SENSORS</p>
<p>⑥group:android.permission-group.LOCATION<br>  permission:android.permission.ACCESS_FINE_LOCATION<br>  permission:android.permission.ACCESS_COARSE_LOCATION</p>
<p>⑦group:android.permission-group.STORAGE<br>  permission:android.permission.READ_EXTERNAL_STORAGE<br>  permission:android.permission.WRITE_EXTERNAL_STORAGE</p>
<p>⑧group:android.permission-group.MICROPHONE<br>  permission:android.permission.RECORD_AUDIO</p>
<p>⑨group:android.permission-group.SMS<br>  permission:android.permission.READ_SMS<br>  permission:android.permission.RECEIVE_WAP_PUSH<br>  permission:android.permission.RECEIVE_MMS<br>  permission:android.permission.RECEIVE_SMS<br>  permission:android.permission.SEND_SMS<br>  permission:android.permission.READ_CELL_BROADCASTS</p>
<p><a href="https://blog.csdn.net/qq_35937681/article/details/73469176">更多详情参考这篇文章</a></p>
</li>
</ol>
<h3 id="三-如何进行动态申请权限以及解决对话框不弹出问题"><a href="#三-如何进行动态申请权限以及解决对话框不弹出问题" class="headerlink" title="三.如何进行动态申请权限以及解决对话框不弹出问题"></a>三.如何进行动态申请权限以及解决对话框不弹出问题</h3><blockquote>
<p>所谓动态申请权限就是通过代码来申请权限，在我了解此部分时，发现仅仅通过代码申请有一个问题，就是申请权限的对话框不会弹出，网上也有很多帖子，但其实这不是什么坑，我们只需要在<strong>清单文件中添加权限</strong>就可以了，即使没有什么实际效果，但需要让系统知道我们将动态申请哪些权限，否则代码中比对时将是空对象，下面开始码代码</p>
</blockquote>
<ol>
<li><p>首先准备一个需要动态申请权限的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val permissions = arrayOf(</span><br><span class="line">            Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">            Manifest.permission.ACCESS_BACKGROUND_LOCATION,</span><br><span class="line">            Manifest.permission.READ_CONTACTS,</span><br><span class="line">            Manifest.permission.INTERNET</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li><p>先对数组中的权限进行遍历，筛选出哪些危险权限没有打开，并保存到另一个数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val requiresPermissions = mutableListOf&lt;String&gt;()</span><br><span class="line"> private fun applyJurisdictions()&#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M)&#123;</span><br><span class="line">            permissions.forEach &#123;</span><br><span class="line">                if (ContextCompat.checkSelfPermission(this,it)!=PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    requiresPermissions.add(it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (requiresPermissions.size&gt;0)&#123;</span><br><span class="line">                requestPermissions(requiresPermissions.toTypedArray(),REQUEST_PERMISSIONS)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>if语句中的判断条件基本是死的，照搬即可，然后遍历数组，通过ContextCompat.checkSelfPermission(上下文，权限)进行查找筛选没有申请的权限，并添加到真正需要申请权限的数组中</p>
</blockquote>
</li>
<li><p>筛选完毕后，遍历真正需要进行动态申请权限的数组，通过<code>requestPermissions(权限数组,请求码)</code>方法进行申请，此方法会弹出申请权限的对话框，它是<code>Activity</code>类中的方法，所以如果使用工具类进行封装的话，需要通过Activity对象调用</p>
</li>
<li><p>权限申请完后，还可以处理回调事件，在Activity中重写<code>onRequestPermissionsResult()</code>方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123;</span><br><span class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        if (requestCode== REQUEST_PERMISSIONS)&#123;</span><br><span class="line">            grantResults.forEach &#123;</span><br><span class="line">                if (it!=PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    //没有获取到权限就强制退出app</span><br><span class="line">                    Log.v(&quot;cx&quot;,&quot;请求失败！&quot;)</span><br><span class="line">                    myApp.exitApp()</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Toast.makeText(this,&quot;申请权限成功！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有申请过的权限结果都保存在<code>grantResults</code>数组中，与<code>permissions</code>保存权限的数组一一对应</p>
</blockquote>
</li>
</ol>
<p><strong>现在绝大部分的App都会在启动App后进行危险权限的申请，如果用户拒绝了，它就会强行退出，进制用户使用，本实例中通过Application这个类来实现，即将所有启动过的Activity保存起来，然后通过一个方法一次性销毁，下面上代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyApp:Application() &#123;</span><br><span class="line">    private val activities = mutableListOf&lt;Activity&gt;()</span><br><span class="line">     override fun onCreate() &#123;</span><br><span class="line">         super.onCreate()</span><br><span class="line">     &#125;</span><br><span class="line">     fun addActivity(activity: Activity)&#123;</span><br><span class="line">        activities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line">     fun exitApp()&#123;</span><br><span class="line">        activities.forEach &#123;</span><br><span class="line">            it.finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E6%9D%83%E9%99%90show.gif" style="zoom: 33%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>在一个大型的App中经常会涉及到危险权限申请问题，经过以上的流程，发现动态申请权限其实很简单的</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/apply-jurisdictions">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>列表加载更多</title>
    <url>/%E5%88%97%E8%A1%A8%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>对于列表页面，每当我们滑到底时总会出现加载更多的字样并且搭配一个旋转中的图标，然后便会请求网络加载数据，当数据加载成功并展示时，字样会消失，这便是<strong>加载更多</strong>，各大软件也频繁使用，下面介绍两种实现方式</p>
</blockquote>
<h3 id="二-方式一：普通方式"><a href="#二-方式一：普通方式" class="headerlink" title="二.方式一：普通方式"></a>二.方式一：普通方式</h3><blockquote>
<p>使用普通方式的缺点是代码逻辑繁琐，下面简述一下步骤：</p>
</blockquote>
<ol>
<li><p>首先肯定从界面入手，增加一个布局文件作为末尾<strong>加载更多</strong>的布局，在Adapter中增加<strong>ItemView</strong>的数量，然后在解析单个Item时通过<code>viewType</code>判断处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun getItemViewType(position: Int): Int &#123;</span><br><span class="line">        return if (position == itemCount - 1) FOOTER_VIEW_TYPE else NORMAL_VIEW_TYPE</span><br><span class="line">    &#125;</span><br><span class="line">override fun getItemCount(): Int &#123;</span><br><span class="line">        return super.getItemCount() + 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其次是数据层面，此实例中使用的是<code>ViewModel</code>管理以及获取数据，但对于数据的获取有两种形式，一是全部重新获取，二是在原来的基础上继续获取即加载更多数据，其实本质只需提供一个真正去加载数据的方法，全部重新获取即数据重置，然后再去加载更多数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun resetQuery()&#123;</span><br><span class="line">        currentPage = 1</span><br><span class="line">        totalPage = 1</span><br><span class="line">        currentKey = keywords.random()</span><br><span class="line">        isNewQuery = true</span><br><span class="line">        needToScrollToTop = true</span><br><span class="line">        fetchData()</span><br><span class="line">    &#125;</span><br><span class="line">fun fetchData()&#123;</span><br><span class="line">        if (isLoading) return</span><br><span class="line">        if (currentPage&gt;totalPage) &#123;</span><br><span class="line">            _dataStatusLive.value = DATA_STATUS_NO_MORE</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        isLoading = true</span><br><span class="line">        val stringRequest = StringRequest(</span><br><span class="line">            Request.Method.GET,</span><br><span class="line">            getUrl(),</span><br><span class="line">            &#123;</span><br><span class="line">                with(Gson().fromJson(it,Pixabay::class.java))&#123;</span><br><span class="line">                    totalPage = ceil(totalHits.toDouble()/perPage).toInt()</span><br><span class="line">                    if (isNewQuery)&#123;</span><br><span class="line">                        _photoListLive.value = hits.toList()</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        _photoListLive.value = arrayListOf(_photoListLive.value!!,hits.toList()).flatten()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                _dataStatusLive.value = DATA_STATUS_CAN_LOAD_MORE</span><br><span class="line">                isLoading = false</span><br><span class="line">                isNewQuery = false</span><br><span class="line">                currentPage++</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                isLoading = false</span><br><span class="line">                _dataStatusLive.value = DATA_STATUS_NETWORK_ERROR</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        VolleySingleton.getInstance(getApplication()).requestQueue.add(stringRequest)</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure></li>
<li><p>整体维护，细节处理</p>
<blockquote>
<p>当数据全部加载完毕或者网络异常时，我们需要通过一些常量进行标识，并更新UI告知用户，这便是维护，其中数据监听使用的是LiveData，可变私有化，提供一个不可变的供用户使用监听，其中还有一些小细节比如RecyclerView滑动处理，详情请见代码</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/normal-load-more">代码链接</a></p>
</li>
</ol>
<h3 id="三-方式二：使用Paging库"><a href="#三-方式二：使用Paging库" class="headerlink" title="三.方式二：使用Paging库"></a>三.方式二：使用Paging库</h3><p>首先添加依赖：<code>implementation &#39;androidx.paging:paging-runtime-ktx:2.1.0&#39;</code></p>
<blockquote>
<p>其中的关键组件是PagedList类，用于保存数据，数据从DataSource的实例对象取得，DataSource有以下三个子类</p>
</blockquote>
<ol>
<li><p>PageKeyedDataSource</p>
<p>前后页通过Key通常是整数即页数关联，上一页中包含下一页的Key</p>
</li>
<li><p>ItemKeyedDataSource</p>
<p>上一页包含加载下一页的数据，比如下一个查询之前，上一项的属性定义了如何执行它</p>
</li>
<li><p>PositionalDataSource</p>
<p>基于位置的数据加载器，用于固定大小、可计数的数据集，支持在任意页面位置进行固定大小的加载</p>
</li>
</ol>
<p>在本实例中使用第一个，因为上一项包含下一项的Key，即页码</p>
<p><strong>下面将从两个方面去分析使用Paging架构的实例</strong></p>
<ol>
<li><p>数据如何获得并展示到界面上</p>
<p>在方式一中数据的获取是在viewModel中进行的，而使用Paging库数据源是DataSource，所以我们需要创建PageKeyedDataSource的子类并从网络加载数据，而是如何带出数据，DataSource对象的创建离不开工厂类DataSource.Factory，并且LivePagedListProvider通过构造方法将PagedList与DataSource联系，所以我们通过<strong>DataSource.Factory</strong>的对象即可获取到DataSource对象中的数据，并且类型是**LiveData&lt;PagedList&lt;T&gt;&gt;**，因此我们只需要在viewModel中保存Factory的对象即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private val factory = PixabayDataSourceFactory(application)</span><br><span class="line">val pagedListLiveData = factory.toLiveData(1)</span><br></pre></td></tr></table></figure>

<p>具体代码可以前往代码链接，此处仅展示局部代码，有了LiveData版本的数据，在Fragment中就可以进行监听，并且提交给Adapter，让RecyclerView显示数据</p>
</li>
<li><p>整体的维护</p>
<p>此处的维护是指当网络异常时，数据加载失败，我们需要通过代码保存状态，并且通过界面提示用户继续进行加载</p>
<p>Kotlin的函数式编程很有优势，可以定义一个变量保存函数，当网络恢复后，再次调用该函数，恢复数据加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var retry:(()-&gt;Unit) ?= null</span><br><span class="line">retry = &#123;loadInitial(params,callback)&#125;</span><br></pre></td></tr></table></figure>

<p>当然还需定义枚举类保存状态，在java中推荐使用定义常量，但在Kotlin中更推荐使用枚举类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum class NetworkStatus&#123;</span><br><span class="line">    LOADING,</span><br><span class="line">    FAILED,</span><br><span class="line">    COMPLETED,</span><br><span class="line">    INITIAL_LOADING,</span><br><span class="line">    LOADED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据是否加载成功是在DataSource中得到，所以我们需要在该子类中定义一个保存状态的LiveData监听状态，然后是将该LiveData带出去让外部能够监听，还是通过<strong>DataSource.Factory</strong>来取出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val networkStatus = Transformations.switchMap(factory.pixabayDataSource) &#123; it.networkStatus &#125;</span><br></pre></td></tr></table></figure>

<p>在viewModel中通过此方法取出DataSource对象中保存的LiveData，至于在何处改变networkStatus的值在此不作赘述，请看代码链接，在Fragment中监听到网络状态发生改变后，还需通知Adapter做相应处理，Adapter中提供的方法请看代码链接</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>通过对比以上两种方式的代码实现，使用Paging库实在简洁太多，并且架构清晰，通过此实例深化了对MVVM的认识以及使用，也对RecyclerView中ViewHolder有了更深的理解，视图中加载的每一行在代码中其实就是一个Holder，将繁杂的代码剥离出来，会让Adapter更加简洁</p>
</blockquote>
<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/FinalGalleryShow.gif" style="zoom:45%;" />

<p><a href="https://github.com/wiwi289/GalleryShow">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍完了工厂模式，在日常开发中运用也是很广泛的，举个栗子，对于Activity，有经验的朋友都会抽出一个BaseActivity，会提供initData、initListener的抽象方法供实现类实现，这就是抽象工厂，当然也用到了模板设计模式。单例模式再常见不过了，下面简单介绍一下</p>
</blockquote>
<h3 id="二-再续场景"><a href="#二-再续场景" class="headerlink" title="二.再续场景"></a>二.再续场景</h3><blockquote>
<p>随着水果店的壮大，顾客越来越多，就需要在门口设计一个账本来记录当日的流量，显然这个账本是唯一的，所以就需要用到全局单例</p>
</blockquote>
<ol>
<li><p>饿汉式</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E9%A5%BF%E6%B1%89%E5%BC%8F.png"></p>
<p>饿汉式很粗暴，直接New一个对象，单例模式下，类的构造方法必须私有化，保证全局对象的唯一性</p>
</li>
<li><p>懒汉式</p>
<p>饿汉式的方式弊端很明显，不管你用不用这个单例，都会创建，明显刚开始时会浪费一定的空间，所以只有当我们需要的时候再来创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SessionCount private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private var instance: SessionCount? = null</span><br><span class="line">        </span><br><span class="line">        fun getInstance(): SessionCount &#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                synchronized(this) &#123;  //这里SessionCount::class.java也可以作为锁</span><br><span class="line">                    if (instance == null) &#123;</span><br><span class="line">                        instance = SessionCount()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：这里使用了经典的<strong>DCL(Double Check Lock)<strong>，为了防止多线程并发带来的问题(两个线程会创建两个对象造成不一致)，这里的this锁的是伴生对象，在kotlin中是唯一的，也可以锁Class对象，但在</strong>java中不要用this，java中的this指的是当前的实例对象，这点很重要</strong>，实例对象显然不唯一</p>
<p>鉴于kotlin的语法特殊性，上述代码还可以进行改造，其实就是判空符的运用而已，同样是DCL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SessionCount private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        private var instance: SessionCount? = null</span><br><span class="line">        </span><br><span class="line">        fun getInstance() = instance?: synchronized(this) &#123;</span><br><span class="line">            instance?:SessionCount().also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外kotlin本身也提供了object类用作单例，之前也使用过懒加载 by lazy的方式，它提供了线程安全的模式，只能说kotlin多种多样，如果使用kotlin开发的话推荐使用<strong>by lazy</strong>的方式，因为object通常用来充当工具类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SessionCount private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val instance: SessionCount by lazy(LazyThreadSafetyMode.SYNCHRONIZED) &#123; </span><br><span class="line">            SessionCount()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能说实在轻松，小编在java中还看到几种方式，比如静态内部类、枚举、通过Map来管理所有的单例等，静态内部类已经很好用了，但可惜会被反射，就造成对象不一致，枚举也是很推荐的，因为不会被反射，并且使用简单，但小编很少看到用枚举的方式来管理单例</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>单例模式比较简单，实际开发中司空见惯，因为小编爱用kotlin，java中提到的单例模式这里就不写了，可以自行百度，做一个了解，java开发中更多的还是DCL，只能说经典。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍动态规划算法以及几个案例求解，动态规划的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法，与分治算法不同的是，动态规划中下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解，具有依赖关系，<strong>动态规划可以通过填表的方式来逐步推进，得到最优解</strong>，下面通过具体案例来分析</p>
</blockquote>
<h3 id="二-01背包问题"><a href="#二-01背包问题" class="headerlink" title="二.01背包问题"></a>二.01背包问题</h3><p><strong>背包问题：有一个背包，容量为4磅，现有如下物品</strong></p>
<table>
<thead>
<tr>
<th align="center">物品</th>
<th align="center">重量</th>
<th align="center">价格</th>
</tr>
</thead>
<tbody><tr>
<td align="center">吉他(G)</td>
<td align="center">1</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">音响(S)</td>
<td align="center">4</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center">电脑(L)</td>
<td align="center">3</td>
<td align="center">2000</td>
</tr>
</tbody></table>
<p>要求：</p>
<ol>
<li>达到的目标为装入的背包的总价值最大，并且重量不超出</li>
<li>装入的物品不能重复</li>
</ol>
<p>下面先列出关键公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) v[i][0]=v[0][j]=0 //初始化，第一行第一列都为0</span><br><span class="line">(2) 当w[i]&gt;j时：v[i][j] = v[i-1][j]</span><br><span class="line">(3) 当j&gt;=w[i]时：v[i][j] = max&#123;v[i-1][j]，val[i]+v[i-1][j-w[i]]&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<blockquote>
<p>这里v是一个二维数组，行对应的是所装物品，列对应的是不同的容量，w数组是每个物品对应的重量，val数组是每个物品对应的价值，下面通过填表来解释上面公式</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3.png" style="zoom:65%;" />

<p><strong>v[i][j] =  v[i-1][j]就是依赖于上一个子阶段求解结果，装不下更多的物品显然只能使用上一次最佳的情况</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void knapsackProblem()&#123;</span><br><span class="line">        int[] w = new int[]&#123;1,4,3&#125;;</span><br><span class="line">        int[] val = new int[]&#123;1500,2500,2000&#125;;</span><br><span class="line">        int capacity = 4;</span><br><span class="line">        int count = 3;</span><br><span class="line">        int[][] v = new int[count+1][capacity+1];</span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][0] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; v[0].length; i++) &#123;</span><br><span class="line">            v[0][i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;</span><br><span class="line">                if(j&lt;w[i-1])&#123;</span><br><span class="line">                    v[i][j] = v[i-1][j];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    v[i][j] = Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; v[0].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是第一行第一列由于实际意义都为0，所以代码中指针值需要减一才能对应两个一维数组中的值</p>
</blockquote>
<h3 id="三-钢材切割问题"><a href="#三-钢材切割问题" class="headerlink" title="三.钢材切割问题"></a>三.钢材切割问题</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2.png"></p>
<p>思路分析：</p>
<blockquote>
<p>对于一定长度的钢材，它可以先分成两段，其中的每一段还可以继续往下分，直到不能分为止，然后对每次分段结果进行求出最大值，所以它是存在递归公式的，下面呢是各长度的钢条的最佳价格，可以重上述价格表中拼凑而得</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%92%A2%E6%9D%90%E9%97%AE%E9%A2%98%E5%A1%AB%E8%A1%A8.png"></p>
<p><strong>r<sub>n</sub>=max(p<sub>n</sub>,r<sub>1</sub>+r<sub>n-1</sub>,r<sub>2</sub>+r<sub>n-2</sub>,r<sub>1</sub>+r<sub>n-1</sub>,…….r<sub>n-1</sub>+r<sub>1</sub>,)</strong></p>
<blockquote>
<p>上述便是递推公式，p<sub>n</sub>表示不切割对应的价格，然后和剩余所有切割的情况取最大值，该公式还可进行简化，如下：</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E7%AE%80%E5%8C%96%E9%92%A2%E6%9D%90%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F.png"></p>
<p><strong>该公式是指定左边不切割，切割右边，p<sub>i</sub>指左边不切割对应的价格，不断对该结果取最大值</strong></p>
<p>注：上述r数组就是进行迭代的最大价格数组，在下面代码中指的是maxValue数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int cutRodNoRecursion(int n)&#123;</span><br><span class="line">        int[] p = &#123;0,1,5,8,9,10,17,17,20,24,30&#125;;</span><br><span class="line">        int[] maxValue = new int[n+1];</span><br><span class="line">        int[] s = new int[n+1];</span><br><span class="line">        maxValue[0] = p[0];</span><br><span class="line">        s[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            int res_s = 0;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                if (p[j]+maxValue[i-j]&gt;res)&#123;</span><br><span class="line">                    res = p[j]+maxValue[i-j];</span><br><span class="line">                    res_s = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxValue[i] = res;</span><br><span class="line">            s[i] = res_s;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        while (n&gt;0)&#123;</span><br><span class="line">            ans.add(s[n]);</span><br><span class="line">            n-=s[n];</span><br><span class="line">        &#125;</span><br><span class="line">        //输出切割方案</span><br><span class="line">        int max = maxValue[n];</span><br><span class="line">        for(int temp:ans) System.out.print(temp+&quot; &quot;);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%92%A2%E6%9D%90%E5%88%87%E5%89%B2%E6%96%B9%E6%A1%88%E4%BF%9D%E5%AD%98.png"></p>
<blockquote>
<p>通过s数组来保存左边的钢材长度，然后通过最终结果依次往回寻，便可得到切割方案，比如长度为9时，可以看到，左边切3，那么剩余6，然后看到6对应的值s[6]为6，所以右边剩余0，那么便可以得到方案[3,6]，个人觉得还是很巧妙的</p>
</blockquote>
<h3 id="四-最长公共子序列"><a href="#四-最长公共子序列" class="headerlink" title="四.最长公共子序列"></a>四.最长公共子序列</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.png"></p>
<p><strong>子序列中字符的相对顺序必须和原字符串中的一样</strong></p>
<p>在知道什么是子序列后，下面我们来研究如何求两个字符串中最长的公共子序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X=&#x27;ABCD&#x27; Y=&#x27;ABD&#x27; Z=&#x27;ABC&#x27;</span><br><span class="line">(1) 对于X、Y两个字符串来说，它们最后一个字符相等，那么它们的长度各自减1，如果各自减1后的公共子序列的长度为k，那么最终长度肯定为k+1</span><br><span class="line">(2) 对于X、Z来说，最后一个字符不相等，那么也就意味着，最长公共子序列要么是X长度减1中取得，要么就是Z减1中取得</span><br></pre></td></tr></table></figure>

<p>针对以上情况，可以得出下列状态转移方程，也叫递推式</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%80%92%E6%8E%A8%E5%BC%8F.png" style="zoom:67%;" />

<blockquote>
<p>二维数组c的行表示字符串1，列表示字符串2，不相等的时候显然取上一子阶段获得的最大值，这也是动态规划的特点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int LongestCS(String s1,String s2)&#123;</span><br><span class="line">        int[][] c = new int[s1.length()+1][s2.length()+1];</span><br><span class="line">        int[][] b = new int[s1.length()+1][s2.length()+1];</span><br><span class="line">        // 1表示来自左上方，2表示来自上方，3表示来自左方</span><br><span class="line">        for(int i=0;i&lt;s1.length()+1;i++)&#123;</span><br><span class="line">            c[i][0] = 0;</span><br><span class="line">            b[i][0] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;s2.length()+1;i++) &#123;</span><br><span class="line">            c[0][i] = 0;</span><br><span class="line">            b[0][i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; s1.length()+1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; s2.length()+1; j++) &#123;</span><br><span class="line">                if (s1.charAt(i-1)==s2.charAt(j-1))&#123;</span><br><span class="line">                    c[i][j] = c[i-1][j-1]+1;</span><br><span class="line">                    b[i][j] = 1;</span><br><span class="line">                &#125;else if (c[i-1][j]&gt;c[i][j-1])&#123;</span><br><span class="line">                    c[i][j] = c[i-1][j];</span><br><span class="line">                    b[i][j] = 2;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    c[i][j] = c[i][j-1];</span><br><span class="line">                    b[i][j] = 3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //回溯输出最长公共子序列</span><br><span class="line">        int i = s1.length(),j = s2.length();</span><br><span class="line">        ArrayList&lt;Character&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        while (i&gt;0&amp;&amp;j&gt;0)&#123;</span><br><span class="line">            switch (b[i][j])&#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    res.add(s1.charAt(i-1));</span><br><span class="line">                    i-=1;</span><br><span class="line">                    j-=1;</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    i-=1;</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    j-=1;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        for (char temp: res)&#123;</span><br><span class="line">            System.out.print(temp+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return c[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>学完以上三个动态规划的问题后，发现动态规划的关键点就是建立递推方程，即状态转移方程，只要列出递推式，剩下的也就不难了，对于动态规划中的最佳方案需要用到回溯，有些思维难度，都需要辅助空间来记录每一步的状态，然后倒过来进行遍历</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>命令模式的核心就是面向接口编程，依赖接口，比如说客户端的一个列表页面，需要请求数据，如果说某一天后端返回的数据类型有变，导致样式改变，这时候就需要更改之前的请求代码，显然不优雅，如果将请求数据的功能抽离出来，通过注入接口类型的方式来请求不同类型的数据，改动小，并且符合开闭原则，拆卸容易</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>根据上面的描述，模拟列表请求不同类型的数据，中间抽离一个Command层</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%9E%8B.png"></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Command &#123;</span><br><span class="line">    public abstract String execute();</span><br><span class="line">&#125;</span><br><span class="line">public class DiscountCommand extends Command &#123;</span><br><span class="line"></span><br><span class="line">    private DiscountHandler handler = new DiscountHandler();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String execute() &#123;</span><br><span class="line">        return handler.getDiscounts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DiscountHandler &#123;</span><br><span class="line">    public String getDiscounts()&#123;</span><br><span class="line">        System.out.println(&quot;返回优惠商品列表&quot;);</span><br><span class="line">        return &quot;优惠商品列表&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ListView &#123;</span><br><span class="line"></span><br><span class="line">    private Command command; //维持一个抽象命令对象的引用</span><br><span class="line"></span><br><span class="line">    //为功能键注入命令</span><br><span class="line">    public void setCommand(Command command) &#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //请求列表</span><br><span class="line">    public void getList() &#123;</span><br><span class="line">        System.out.print(&quot;首页请求&quot;);</span><br><span class="line">        String result = command.execute();</span><br><span class="line">        System.out.println(&quot;当前列表：&quot;+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">ListView listView = new ListView();</span><br><span class="line">listView.setCommand(new DiscountCommand());</span><br><span class="line">listView.getList();</span><br></pre></td></tr></table></figure>

<p>通过新增一层命令层，如果需要新的数据形式，直接新增对应的命令以及具体的数据请求即可，动态注入</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>命令模式在平常使用可能不会在意它是否是标准的，只要符合基本原则，拆卸容易，使用优雅，理解它的基本思想即可</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>发布开源库到MavenCentral详细教程</title>
    <url>/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0MavenCentral.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>本文将介绍发布自己的开源库到MavenCentral，之前是发布到JCenter，但JCenter已经停止发布开源库了，所以刚开始我去bintray的官网还找了半天的注册入口，蛮坑的，网页被魔改了，下面开始MavenCentral发布的流程</p>
</blockquote>
<h3 id="二-准备流程"><a href="#二-准备流程" class="headerlink" title="二.准备流程"></a>二.准备流程</h3><p>本文参考自<a href="https://blog.csdn.net/guolin_blog/article/details/119706565">郭婶的发布流程博客</a>，只是郭婶的发布方式是通过自己购买的域名做路径，所以如果想使用io.github的形式免费发布开源库，还得参考<a href="https://mp.weixin.qq.com/s/FVR6_zMp5DxO5N4ptVuA6g">io.github形式</a>，好巧不巧，这篇文章是windows版本的，并且使用的是官方的maven-publish插件进行发布，会额外增加一些代码，郭婶的发布方式比较简洁，下面结合二者的优势吧，开始踩坑之旅。。</p>
<ol>
<li><p>在<a href="https://issues.sonatype.org/secure/Dashboard.jspa">Sonatype平台</a>注册账号并创建工单</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%901.png"></p>
<p>注册账号，填密码的时候不要选择官方给你推荐什么Google浏览器会记住密码的推荐，使用自己的密码即可，因为后面在发布的时候需要使用到你的Sonatype账号和密码，另外，登录成功后，它会自动弹窗引导你创建一个issue，直接cancel吧，挺烦人的，然后就进入到上图所示的界面，点击create创建即可</p>
</li>
<li><p>填写工单信息，下面就展示一下我填写的信息吧</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%902.png" style="zoom:40%;" />

<blockquote>
<p>注：Group Id很重要，既然选择了io.github的形式，并且为了方便工作人员审查，所以最好是你的github账号倒过来，但不是com.github.用户名，我这里是io.github.wiwi289，并且在后面发布的时候也需要使用这个Group Id</p>
</blockquote>
</li>
<li><p>再提交工单后，一会儿就会在下面出现来自工作人员的评论</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%903.png" style="zoom:60%;" />

<p>我是周末提交的，但回的还是很快，不像郭婶说的那般非工作日很慢，很迷，第一个评论就是说要求我们在github上创建一个以<strong>工单号</strong>命名的空仓库，直接复制这个工单号去创建即可，比如这里是<code>OSSRH-77062</code>    </p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%904.png" style="zoom:40%;" />                                                            

<p>然后就可以如上图一样回复工作人员已经创建成功，等待检查</p>
</li>
<li><p>等待工作人员检查完毕，会有相应的回复，这里就不贴结果了，看到回复就表明我们的Maven仓库已经就可以使用了，下面要做的就是发布开源库到Maven仓库</p>
</li>
<li><p>创建秘钥，这里展示mac的方式，windows可以参考上面提到的windwos版本的方式，不过个人觉得只参考秘钥的创建即可</p>
<p><code>brew install gpg</code>，mac使用HomeBrew安装，这里也感觉蛮坑的吧，输入命令后会像下图一般，进入等待更新，一直等着，所以需要ctrl+c停止，否则真不知道要等到什么时候</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%905.png"></p>
</li>
<li><p>安装成功后，输入以下命令生成秘钥，并设置秘钥密码，这两个都很重要</p>
<p><code>gpg --full-generate-key</code></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%906.png" style="zoom:50%;" />

<p>弹出第一个信息很重要，一定要选择RSA加密的，前面的信息只有这一步需要注意，其他的回车即可，然后确认，并退出，退出的时候会让你设置密码，之后就可以看到生成的秘钥ID了</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%907.png"></p>
<p>可以看到这里生成的类型是RSA，这点很重要，否则在后面发布的时候会报加密异常，就是因为没有使用RSA加密方式</p>
</li>
<li><p>上传秘钥到GPG服务器，秘钥ID很长，但只需要最后8位，这点超重要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --keyserver hkp://pgp.mit.edu --send-keys DC0B6B98</span><br></pre></td></tr></table></figure>

<p>这里可能会上传不成功，超坑，需要下面的命令进行检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --keyserver hkp://pool.sks-keyservers.net --search-keys DC0B6B98</span><br></pre></td></tr></table></figure>

<p>如果显示No Name，则上传不成功，不用再试了，感觉不会成功的，哭了，这时候就通过下面的网址手动上传秘钥</p>
<p><a href="https://keys.openpgp.org/upload/">https://keys.openpgp.org/upload/</a></p>
<p>手动上传前还需要导出我们的秘钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --export 1111111@qq.com &gt; ~/Downloads/my_key.pub</span><br></pre></td></tr></table></figure>

<p>然后再通过网站手动上传，网站会提示上传成功的</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%908.png" style="zoom:50%;" />

<p>上传成功后，通过终端命令查询还是查不到(我的是这样)，不过网站显示成功即可，后续的验证就不会有问题</p>
</li>
<li><p>最后一步是生成私钥文件，一行命令搞定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg --export-secret-keys  -o 文件路径/secring.gpg</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三-发布流程"><a href="#三-发布流程" class="headerlink" title="三.发布流程"></a>三.发布流程</h3><blockquote>
<p>经过以上步骤的折磨，下面就稍微轻松很多了，唯一需要仔细的是AS中文件的信息填写</p>
</blockquote>
<p>发布的方式这里还是推崇使用<a href="https://github.com/vanniktech/gradle-maven-publish-plugin">gradle-maven-publish-plugin</a>插件发布，只能说步骤少，效率高，超爽</p>
<p>使用方式也很简单、亲民</p>
<ol>
<li><p>在你要开源的库的所在模块的build.gradle中添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.vanniktech:gradle-maven-publish-plugin:0.17.0&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//plugin ids放在这里</span><br><span class="line">allprojects &#123;</span><br><span class="line">    plugins.withId(&quot;com.vanniktech.maven.publish&quot;) &#123;</span><br><span class="line">        mavenPublish &#123;</span><br><span class="line">            sonatypeHost = &quot;S01&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &quot;com.vanniktech.maven.publish&quot;</span><br></pre></td></tr></table></figure>

<p>这里有一个坑点，buildscript{}闭合必须放在文件顶部，即所有插件的前面，否则报错，详情可以前往<a href="https://github.com/wiwi289/GradualShowTextView/">我的github项目(本次开源对象)查看</a></p>
</li>
<li><p>在项目根目录下的gradle.properties文件增加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GROUP=io.github.wiwi289</span><br><span class="line">POM_ARTIFACT_ID=GradualShowTextView</span><br><span class="line">VERSION_NAME=1.0.0</span><br><span class="line"></span><br><span class="line">POM_NAME=GradualShowTextView</span><br><span class="line">POM_DESCRIPTION=A convenient text gradient TextView</span><br><span class="line">POM_INCEPTION_YEAR=2021</span><br><span class="line">POM_URL=https://github.com/wiwi289/GradualShowTextView/</span><br><span class="line"></span><br><span class="line">POM_LICENSE_NAME=The Apache Software License, Version 2.0</span><br><span class="line">POM_LICENSE_URL=https://www.apache.org/licenses/LICENSE-2.0.txt</span><br><span class="line">POM_LICENSE_DIST=repo</span><br><span class="line"></span><br><span class="line">POM_SCM_URL=https://github.com/wiwi289/GradualShowTextView/</span><br><span class="line">POM_SCM_CONNECTION=scm:git:git://github.com/wiwi289/GradualShowTextView.git</span><br><span class="line">POM_SCM_DEV_CONNECTION=scm:git:ssh://github.com/wiwi289/GradualShowTextView.git</span><br><span class="line"></span><br><span class="line">POM_DEVELOPER_ID=chenxiong</span><br><span class="line">POM_DEVELOPER_NAME=Chen Xiong</span><br><span class="line">POM_DEVELOPER_URL=https://github.com/wiwi289/</span><br><span class="line"></span><br><span class="line">signing.keyId=密钥ID的后8位(我的是DC0B6B98)</span><br><span class="line">signing.password=密钥密码(详情见上面的准备流程，生成秘钥时，系统让你设置的密码)</span><br><span class="line">signing.secretKeyRingFile=私钥文件路径(导出的路径)</span><br><span class="line"></span><br><span class="line">mavenCentralUsername=Sonatype账号</span><br><span class="line">mavenCentralPassword=Sonatype密码</span><br></pre></td></tr></table></figure>

<p>上面的前三项决定着你的开源库的包路径是什么，比如这里，我的开源包路径就变成了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.github.wiwi289:GradualShowTextView:1.0.0</span><br></pre></td></tr></table></figure>

<p>其他的内容其实在准备阶段也有强调，可以进行回顾，特别注意的是这个gradle.properties文件有太多隐私信息，需要排除在版本控制外</p>
</li>
<li><p>最后就可以点击AS右边的Gradle下的publish进行发布了，当然了我发了好几次也没发出去，不过踩过的坑点都在上面了，如果按照我的格式来发布的话，应该能直接起飞</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%909.png" style="zoom:33%;" />

<p>成功的话，就显示Build Successfully，否则就看抛什么异常吧，仔细检查检查，一般都没问题</p>
</li>
<li><p>经过以上的发布步骤，虽然是发布出去了，但是还没有发布到MavenCentral中去，只是发送到了<a href="https://s01.oss.sonatype.org/">https://s01.oss.sonatype.org/</a>这个仓库中，直接登录，账号和密码是前面申请的Sonatype账号，登录成功后点击左边的<strong>Staging Repositories</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9010.png" style="zoom:50%;" />

<p>可看到现在的状态是open的，就算你勾选了这个仓库，上面的Release按钮不可点击，所以我们需要勾选它，点击上面的close</p>
<p>，会有一个弹窗，点击Confirm即可，然后就等待它的校验流程，可以选中它，看到下面的Activity窗口，会展示校验流程，并且还可以查看失败日志，这个很重要，如果后面刷新发现状态还是open，说明没有关闭成功，这时候就得查日志，只有状态变成closed，Release按钮才可点击</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9011.png"></p>
<p>我之前就是因为秘钥上传不成功，才导致关闭失败，查日志才发现，坑炸了</p>
</li>
<li><p>如果后面点击Refresh，发现已关闭，那么就可点击Release进行发布了，会有弹窗，直接点Confirm即可，然后这个仓库就会消失，容易想到，消失的它正在被送往MavenCentral，所以过一会儿，你之前创建的工单下面会多一个评论</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9012.png"></p>
<p>好了，看到这个消息，总算可以松口气了，等待同步到MavenCentral即可，几个小时后，你就可以使用你发布的开源了，使用方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;io.github.wiwi289:GradualShowTextView:1.0.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步成功后也可以在<a href="https://search.maven.org/">search.maven.org/</a>搜索Group Id就能搜出你发布的所有开源库了</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%BC%80%E6%BA%9013.png"></p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>怎么说呢，一路艰辛，疯狂踩坑，从JCenter到MavenCentral，再到最后的豁然开朗，不过JCenter被废弃的这一个事实算是记住了，关于下一次再发布开源库，直接跳过准备流程，直接走发布流程即可~</p>
</blockquote>
]]></content>
      <categories>
        <category>问题总结集</category>
      </categories>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍计数排序，它也是桶排序的一种，同时是非比较的排序，究其本质是多关键字的排序，内部其实调用了计数排序</p>
</blockquote>
<h3 id="二-基数排序原理以及代码实现"><a href="#二-基数排序原理以及代码实现" class="headerlink" title="二.基数排序原理以及代码实现"></a>二.基数排序原理以及代码实现</h3><p>首先上图解释</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201904/1258817-20190418104853042-13278997.gif" alt="img"></p>
<blockquote>
<p>原理分析：每次从个位数开始，以个位数为关键字进行计数排序，前面已经介绍过计数排序了，然后再取十位数、百位数…..依次进行计数排序，所以原理很简单，就是依次对一个数字的各位数进行计数排序，基数排序分<strong>低位优先</strong>和<strong>高位优先</strong>，本实例使用的是低位优先，及从个位数开始，高位优先属于分治的思想</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void baseSort(int[] arr,int maxDigit)&#123;</span><br><span class="line">       int[] tempArray = new int[arr.length];</span><br><span class="line">       int[] count = new int[10];</span><br><span class="line">       for (int i = 0; i &lt; maxDigit; i++) &#123;</span><br><span class="line">           int division = (int)Math.pow(10,i);</span><br><span class="line">           for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">               int num = arr[j]/division % 10;</span><br><span class="line">               count[num]++;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int m = 1; m &lt; count.length; m++) &#123;</span><br><span class="line">               count[m] = count[m] + count[m-1];</span><br><span class="line">           &#125;</span><br><span class="line">           for (int n = arr.length-1; n &gt;=0 ; n--) &#123;</span><br><span class="line">               tempArray[--count[arr[n]/division % 10]] = arr[n];</span><br><span class="line">           &#125;</span><br><span class="line">           System.arraycopy(tempArray,0,arr,0,arr.length);</span><br><span class="line">           Arrays.fill(count,0);</span><br><span class="line">       &#125;</span><br><span class="line">       for (int temp:arr) &#123;</span><br><span class="line">           System.out.print(temp + &quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   static int getDigit(int[] arr)&#123;</span><br><span class="line">       int[] copyArr = Arrays.copyOf(arr,arr.length);</span><br><span class="line">       int maxDigit = 0;</span><br><span class="line">       for (int i = 0; i &lt; copyArr.length; i++) &#123;</span><br><span class="line">           int digit = 0;</span><br><span class="line">           for(;copyArr[i]&gt;0;copyArr[i] /= 10)</span><br><span class="line">               digit++;</span><br><span class="line">           maxDigit = Math.max(maxDigit, digit);</span><br><span class="line">       &#125;</span><br><span class="line">       return maxDigit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ol>
<li>每进行一次计数排序需要清空count数组</li>
<li>计算数组中最高位数时需要拷贝一份数组，对拷贝数组进行操作</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>基本计算器</title>
    <url>/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>涉及到混合运算可能大多数朋友都会想到使用栈来存储，但对于混合运算的运算式(乘除法以及括号)我们首先得转换成前缀或者后缀表达式之后再使用栈来存储以及遍历才能完成相应运算，如果没有圆括号的混合运算还可使用两个数组进行保存操作数和操作符，而本题只有加减法搭配圆括号，由于涉及到算式的优先级问题，所以考虑使用栈进行存储，那么你可能迷惑要不要使用两个栈进行存储，显然这里是没有必要的，因为加减法可以使用1或-1来表示，因此操作数和操作符都用一个栈来存储，一旦遇到左括号就将之前的运算结果入栈，同时操作符也入栈并位于栈顶，当遇到右括号时出栈一个运算符和运算数，该过程有点类似递归，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int calculate(String s)&#123;</span><br><span class="line">        String dataString = s.replaceAll(&quot; &quot;,&quot;&quot;);</span><br><span class="line">        //保存结果</span><br><span class="line">        int res = 0;</span><br><span class="line">        int sign = 1;</span><br><span class="line">        //记录操作数</span><br><span class="line">        int num = 0;</span><br><span class="line">        Stack&lt;Integer&gt; ops = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; dataString.length(); i++) &#123;</span><br><span class="line">            char nowChar = dataString.charAt(i);</span><br><span class="line">            if (Character.isDigit(nowChar))&#123;</span><br><span class="line">                num = 10*num + nowChar-&#x27;0&#x27;;</span><br><span class="line">                if (i&lt;dataString.length()-1 &amp;&amp; dataString.charAt(i+1)&gt;=&#x27;0&#x27; &amp;&amp; dataString.charAt(i+1)&lt;=&#x27;9&#x27;)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if (nowChar==&#x27;+&#x27;||nowChar==&#x27;-&#x27;)&#123;</span><br><span class="line">                sign= nowChar==&#x27;+&#x27;? 1 : -1;</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;else if (nowChar==&#x27;(&#x27;)&#123;</span><br><span class="line">                ops.push(res);</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                res = 0;</span><br><span class="line">                sign = 1;</span><br><span class="line">            &#125;else if (nowChar==&#x27;)&#x27;)&#123;</span><br><span class="line">               sign = ops.pop();</span><br><span class="line">               num = res;</span><br><span class="line">               res = ops.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res+=num*sign;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>每获得一个操作数，res需要更新，而当遇到运算符时，num置0，重新获取操作数，如果遇到左括号则将之前的res和sign入栈并恢复起始状态，进入一个括号相当于开启一个新的运算式，遇到右括号时取出位于栈顶的运算数和运算符进行合并，依次类推</p>
<h3 id="三-扩展"><a href="#三-扩展" class="headerlink" title="三.扩展"></a>三.扩展</h3><blockquote>
<p>之前提到过如果仅仅是四则运算的混合，而没有圆括号，可以使用两个数组进行操作，不需要栈，但就目前的算法而言还是有缺陷的，因为数字都放在了一个数组里面，所以无法区分操作数到底是一个几位数，所以这里挺局限的，仅对一位数进行操作</p>
</blockquote>
<p>基本思路：</p>
<p>首先遍历运算表达式的字符串，依次将数组放进一个数组，运算符放进一个数组，然后使用两个计数器分别操作两个数组取出对应的元素，由于不能统一控制循环次数，所以都采用while循环，首先取出运算符，然后根据是否之前有运算结果取操作数，如果遇到乘除号，我们需要另启一个while循环直到高级运算执行完毕，由于低级运算和高级运算返回时会导致操作数1和操作数2改变方式不同，所以需要一个变量记录是否是经过了高级运算后返回的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int calculate(String s) &#123;</span><br><span class="line">        String dataString = s.replaceAll(&quot; &quot;,&quot;&quot;);</span><br><span class="line">        ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Character&gt; operatorChar = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i= 0;i&lt; dataString.length();i++)&#123;</span><br><span class="line">            char nowChar = dataString.charAt(i);</span><br><span class="line">            if (Character.isDigit(nowChar))&#123;</span><br><span class="line">                nums.add(nowChar-&#x27;0&#x27;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                operatorChar.add(nowChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int firstResult = 0;</span><br><span class="line">        int secondResult = 0;</span><br><span class="line">        int firstNum = 0;</span><br><span class="line">        int secondNum = 0;</span><br><span class="line">        int i = 0,j = 0;</span><br><span class="line">        char nowOperator = &#x27; &#x27;;</span><br><span class="line">        boolean lastIsNormOperator = true;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            nowOperator= lastIsNormOperator ? operatorChar.get(i++) : nowOperator;</span><br><span class="line">            if (nowOperator==&#x27;*&#x27;||nowOperator==&#x27;/&#x27;)&#123;</span><br><span class="line">                firstNum = firstResult==0 ? nums.get(j++) : firstResult;</span><br><span class="line">                secondNum = nums.get(j++);</span><br><span class="line">                firstResult = realCalculate(firstNum,nowOperator,secondNum);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (lastIsNormOperator)&#123;</span><br><span class="line">                firstNum = firstResult==0 ? nums.get(j++) : firstResult;</span><br><span class="line">                secondNum = nums.get(j++);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                secondNum = secondResult;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i==operatorChar.size()||operatorChar.get(i)!=&#x27;*&#x27;&amp;&amp; operatorChar.get(i)!=&#x27;/&#x27;)&#123;</span><br><span class="line">                firstResult = realCalculate(firstNum,nowOperator,secondNum);</span><br><span class="line">                lastIsNormOperator = true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                    char newOperator = operatorChar.get(i++);</span><br><span class="line">                    int newFirst = secondResult==0 ? secondNum :secondNum;</span><br><span class="line">                     int newSecond = nums.get(j++);</span><br><span class="line">                     secondResult = realCalculate(newFirst,newOperator,newSecond);</span><br><span class="line">                    if (i==operatorChar.size()) return realCalculate(firstNum,nowOperator,secondResult);</span><br><span class="line">                    if (operatorChar.get(i)!=&#x27;*&#x27; &amp;&amp; operatorChar.get(i)!=&#x27;/&#x27;) break;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIsNormOperator = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i==operatorChar.size()) return firstResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      int realCalculate(int first,char operator,int second)&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        switch (operator)&#123;</span><br><span class="line">            case &#x27;-&#x27;:</span><br><span class="line">                result = first-second;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;+&#x27;:</span><br><span class="line">                result = first+second;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;*&#x27;:</span><br><span class="line">                result = first*second;</span><br><span class="line">                break;</span><br><span class="line">            case &#x27;/&#x27;:</span><br><span class="line">                result = first/second;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>对于此类问题，首先应该考虑使用什么样的数据结构进行数据存储，思考是否有递归，并且应该从最简单的情况开始考虑</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>字符串匹配算法</title>
    <url>/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>字符串匹配在算法中也算是一个经典，小编接下来将介绍两种字符串匹配的算法，所谓字符串匹配就是在一个字符串中查找某个子串，如果存在目标子串，则返回第一次出现的下标，否则返回-1</p>
</blockquote>
<h3 id="二-暴力匹配算法"><a href="#二-暴力匹配算法" class="headerlink" title="二.暴力匹配算法"></a>二.暴力匹配算法</h3><p>见字思义，这种算法效率十分低，但可以帮助我们理解字符串匹配的整体过程</p>
<img src="https://img-blog.csdnimg.cn/img_convert/5750ee4c59ec352b434eacfca38ed2d1.png" style="zoom:50%;" />

<p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int violenceMatchString(String str1,String str2)&#123;</span><br><span class="line">        char[] s1 = str1.toCharArray();</span><br><span class="line">        char[] s2 = str2.toCharArray();</span><br><span class="line">        int sLen1 = s1.length;</span><br><span class="line">        int sLen2 = s2.length;</span><br><span class="line">        int i = 0,j = 0;</span><br><span class="line">        while (i&lt;sLen1 &amp;&amp; j&lt;sLen2)&#123;</span><br><span class="line">            if (s1[i] == s2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                i = i-(j-1);</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j==sLen2)&#123;</span><br><span class="line">            return i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论是哪种匹配算法，都存在双指针<code>i</code>、<code>j</code>，上面的动图已经很清晰了，该算法的效率之所以效率低，是因为一旦发现不匹配，指针<code>i</code>会回溯，并且还会遍历已经遍历过的子串，反反复复，效率肯定低下</p>
</blockquote>
<h3 id="三-KMP算法"><a href="#三-KMP算法" class="headerlink" title="三.KMP算法"></a>三.KMP算法</h3><p>KMP算法是由三位大牛共同发现的，关于它的介绍网上已经很多了，在此不作赘述，主要分享我在学习该算法时的疑惑，最大的疑惑是为什么发生不匹配的情况时可以跳过已经匹配过的子串，该过程是通过next数组来实现的，其实next数组记录的前后缀字符串公共子串中首次出现的位置</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/kmp%E5%9B%BE%E8%A7%A3.png" style="zoom:67%;" />

<p><strong>下面上代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int KMPMatchString(String origin,String target)&#123;</span><br><span class="line">            int[] next = KMPNextArray(target);</span><br><span class="line">        for (int i = 0 , j = 0; i &lt; origin.length(); i++) &#123;</span><br><span class="line">            while (j&gt;0 &amp;&amp; origin.charAt(i)!=target.charAt(j))&#123;</span><br><span class="line">                j = next[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (origin.charAt(i)==target.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j==target.length())&#123;</span><br><span class="line">                return i-j+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    static int[] KMPNextArray(String target)&#123;</span><br><span class="line">        int[] next = new int[target.length()];</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1,j = 0; i &lt; target.length(); i++) &#123;</span><br><span class="line">            while (j&gt;0 &amp;&amp; target.charAt(i)!=target.charAt(j))&#123;</span><br><span class="line">                j = next[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (target.charAt(i)==target.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先求出next数组，在真正进行字符串匹配时，<code>j</code>的回溯和求next数组时操作一样，关键点也是<code>j</code>的回溯，结合上图进行理解</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>KMP算法通过next数组保存位置并且不会发生<code>i</code>的回溯大大提升了匹配效率，个人感觉KMP算法确实挺绕的，如果实在难以理解，可以通过具体的例子进行步步推衍以及假设分析，会发现<code>i</code>不进行回溯是有道理的并且不会出错</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>外观模式也叫门面模式，当完成一个业务需要复杂的流程调用时，对于使用者来说是有风险的，这个时候就可以考虑使用外观模式进行一层封装</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><p>前面通过桥接模式完成原料的组装、装饰模式完成加急等附加操作、组合模式完成订单地址选择，所以总体分三个大的流程，原始流程如下</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%A7%8B%E6%B5%81%E7%A8%8B.png"></p>
<p>使用外观模式将内部流程进行封装</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%B0%81%E8%A3%85.png" style="zoom:50%;" />

<p>结构图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class OrderFacade &#123;</span><br><span class="line">    private val pickService = PickService()</span><br><span class="line">    private val packService = PackService()</span><br><span class="line">    private val sendService = SendService()</span><br><span class="line">    </span><br><span class="line">    fun doOrder() &#123;</span><br><span class="line">        pickService.doPick()</span><br><span class="line">        packService.doPack()</span><br><span class="line">        sendService.doSend()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于使用者来说直接调用doOrder方法即可，不关心内部的具体调用以及流程</p>
<p>1、调用方只关注facade组件，不需要知道底层服务。</p>
<p>2、隐藏掉底层服务中，不相干的功能。</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>外观模式很简单，简单说就是对一系列流程进行封装，流程封闭成一个接口，供外部使用</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>堆排序是建立在二叉树顺序存储的基础上进行的，使用顺序存储的进行排序不存在递归，下面小编将介绍堆排序的原理</p>
</blockquote>
<h3 id="二-堆排序原理分析"><a href="#二-堆排序原理分析" class="headerlink" title="二.堆排序原理分析"></a>二.堆排序原理分析</h3><p>堆排序中涉及到一个比较重要的概念即<strong>大顶堆和小顶堆</strong>，解释大顶堆即可，小顶堆如法炮制，大顶堆说的是父节点比左右孩子都要大，注意它不关注左右孩子谁大谁小，只要父节点比左右孩子大即可，那么显然位于堆顶(即根)的值是最大的，通常升序排序使用大顶堆，降序使用小顶堆</p>
<img src="https://img0.baidu.com/it/u=3536165523,376891020&fm=26&fmt=auto&gp=0.jpg" style="zoom:67%;" />

<p>介绍完大顶堆后，下面通过一个动画大致领略一下堆排序的原理，小编再配上文字解说</p>
<p><img src="https://www.pianshen.com/images/696/d2f3f4bc776b7d45daa73cad9f9370a0.gif"></p>
<p>根据上图可以发现大致分为以下两个步骤完成排序：</p>
<ol>
<li>首先建立大顶堆，自下而上，自左向右进行构建</li>
<li>交换堆顶元素和未排好序部分的最后一个元素，交换之后，继续调整大顶堆</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void heapSort(int[] arr)&#123;</span><br><span class="line">       for (int i = arr.length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">           adjustHeap(arr,i,arr.length);</span><br><span class="line">       &#125;</span><br><span class="line">       for (int j = arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">           int temp = arr[0];</span><br><span class="line">           arr[0] = arr[j];</span><br><span class="line">           arr[j] = temp;</span><br><span class="line">           adjustHeap(arr,0,j);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   static void adjustHeap(int[] arr,int i,int length)&#123;</span><br><span class="line">       int temp = arr[i];</span><br><span class="line">       for (int k = 2*i+1;k&lt;length;k=k*2+1)&#123;</span><br><span class="line">           if (k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">           if (arr[k]&gt;temp)&#123;</span><br><span class="line">               arr[i] = arr[k];</span><br><span class="line">               i = k;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       arr[i] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>小编觉得堆排序中比较难理解的地方就是调整大顶堆，时间空间复杂度总结如下</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>完全使用位运算实现加法</title>
    <url>/%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p> <strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>小编在看到题目的时候首先想到的是<strong>二进制位运算</strong>，但由于不太熟悉位运算的使用，一直卡壳，下面介绍容易理解的解题思路</p>
</blockquote>
<p>基本思路来源是二进制数字的加法，如果没有进位，则将0、1相加，若要进位当前位为0，向上一位进1，那么这个过程怎么通过位运算来实现呢：</p>
<p>设两数字的二进制形式 a、b，其求和 s = a + b，a(i)代表a的二进制第i位，则分为以下四种情况：</p>
<table>
<thead>
<tr>
<th align="center">a(i)</th>
<th align="center">b(i)</th>
<th align="center">无进位和n(i)</th>
<th align="center">进位c(i+1)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>通过观察上表可以发现对应的两个二进制数字不同时没有进位，都为1时有进位，所以前者可以为两个数的异或运算，后者为两数的与运算并且<strong>要左移1位</strong>，即进位，然后先通过异或运算求两个数的和，如果进位为0则不需要进行，否则继续求和，直到不再进位，因为有连续进位的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int add(int a, int b) &#123;</span><br><span class="line">        while (b!=0)&#123;</span><br><span class="line">            int n = (a&amp;b)&lt;&lt;1;</span><br><span class="line">            a ^= b;</span><br><span class="line">            b = n;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>头一次遇到这种问题，有助于理解二进制运算，另外在计算机中数值统一使用补码的形式来表示和存储，所以加减法可以统一处理</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>学年设计1-桌面模拟App</title>
    <url>/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A11-%E6%A1%8C%E9%9D%A2%E6%A8%A1%E6%8B%9FApp.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在学安卓UI阶段，我带领队友进行了安卓小项目的设计，成果命名为<strong>桌面模拟App</strong></p>
<p>该项目的灵感来源：</p>
<p>我们每天经历着这样一个过程：手机滑动解锁-&gt;进入桌面-&gt;点击某个app的缩略图标-&gt;进入到对应界面并完成相关操作，这款小app模拟的便是整个过程，但我们平时看到桌面不够个性化，比如应用图标的展示，没有任何动画效果，比较呆板，我们对此进行了动画美化，此外我们还模拟了qq登录，同样主要是对界面进行美化</p>
</blockquote>
<h3 id="二-所用到的知识点"><a href="#二-所用到的知识点" class="headerlink" title="二.所用到的知识点"></a>二.所用到的知识点</h3><ol>
<li>Android动画：帧动画、补间动画、属性动画</li>
<li>Activity跳转：显示和隐式跳转，隐式跳转主要用于启动系统服务</li>
<li>SharedPreferences将数据写入文件，并对SharedPreferences进行封装</li>
<li>自定义控件-&gt;主要是onDraw()方法进行绘制</li>
<li>事件的回调-&gt;此处采用的是保存监听者对象，缺点是让Acitivity和控件耦合性太高，最好使用高阶函数回调</li>
<li>比目科技的短信验证服务(可以参考官方文档)以及虚化模式(github上开源)</li>
</ol>
<h3 id="三-难点和坑点分析"><a href="#三-难点和坑点分析" class="headerlink" title="三.难点和坑点分析"></a>三.难点和坑点分析</h3><ul>
<li>我在设计相册的图片播放功能时，由于想综合的运用补间动画和属性动画，但补间动画中设置了fillAfter=true，所以导致属性动画没有效果，当然最好的方式是全程都使用属性动画，其实在实际开发中，属性动画用的更多，不仅可以实现连续值变化，而且发生的变化都是真实的，相反，补间动画只是一种虚像，没有实际改变控件的属性</li>
<li>为了实现一个动画接一个动画的展示，不能使用循环语句进行控制，因为程序的执行速度非常快，根本看不到中间动画的效果，只能采取动画监听的方式</li>
<li>在自定义解锁控件时，得用一个类来管理九宫格里面的点，封装相应的属性，便于使用，除此之外还得设置一个监听者进行事件回调或者访问其他控件，虽然控件内部可以通过<code>context.startActivity(Intent(context,目的界面::class.java))</code>来实现界面跳转，但这种方式不是很好，另外如果我们需要访问其他控件是会报错的，暂时理解为控件之间是相互独立的，需要通过xml对应Activity进行管理、使用，总之事件回调的使用很有必要，并且推荐高阶函数实现事件回调，大大降低耦合性</li>
<li>猫头鹰的登录界面主要是文本框的监听事件，本项目还可进行优化，由于时间原因就省去了，账号注册时应该输入用户的手机号，这里直接写死了，这点很不好，测试之后忘记优化升级，猫头鹰手臂旋转的动画由于使用了属性动画，而属性动画是无法更改旋转中心的，所以需要使用两个属性动画才能达到效果</li>
<li>qq列表中listView、ExpandableListView中<strong>适配器</strong>的理解，另外实现qq列表的折叠功能使用ExpandableListView已经过时了，并且效果不好，后面会介绍另外一个控件进行实现</li>
</ul>
<h3 id="四-项目分工情况"><a href="#四-项目分工情况" class="headerlink" title="四.项目分工情况"></a>四.项目分工情况</h3><ul>
<li>我负责：桌面应用展示动画以及相册播放图片功能、系统服务的跳转</li>
<li>队友1：滑动解锁界面</li>
<li>队友2：猫头鹰登录界面以及账号注册界面</li>
</ul>
<h3 id="五-项目结构流程图"><a href="#五-项目结构流程图" class="headerlink" title="五.项目结构流程图"></a>五.项目结构流程图</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<h3 id="六-项目效果展示"><a href="#六-项目效果展示" class="headerlink" title="六.项目效果展示"></a>六.项目效果展示</h3><ol>
<li>解锁界面展示</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/%E8%A7%A3%E9%94%81%E5%B1%95%E7%A4%BA.gif"></p>
<ol start="2">
<li>桌面菜单展示</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/%E8%8F%9C%E5%8D%95%E5%B1%95%E7%A4%BA.gif"></p>
<ol start="3">
<li>模拟qq展示</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/qq%E5%B1%95%E7%A4%BA.gif"></p>
<ol start="4">
<li>相册播放图片展示</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AD%A6%E5%B9%B4%E8%AE%BE%E8%AE%A1/%E7%9B%B8%E5%86%8C%E5%B1%95%E7%A4%BA.gif"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>本次学年项目的设计总体很满意，初次体验了团队合作，队友之间的配合相当重要，以及在合并项目的过程中长了不少知识，收获很大，对所学Android知识点的巩固很有帮助！</p>
</blockquote>
<p><strong>代码链接</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/academic-year-design">学年设计1</a></p>
]]></content>
      <categories>
        <category>Android项目</category>
      </categories>
      <tags>
        <tag>学年设计</tag>
      </tags>
  </entry>
  <entry>
    <title>子模块之间的通信-路由</title>
    <url>/%E5%AD%90%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1-%E8%B7%AF%E7%94%B1.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍了组件化概念以及项目如何进行组件化管理，也提到子模块之间是独立的，不能相互依赖，而app模块仅仅是一个入口，所以业务之间的通信往来也就是子模块之间的通信就显得很重要，下面将对此详解</p>
</blockquote>
<h3 id="二-子模块之间通信基本方案"><a href="#二-子模块之间通信基本方案" class="headerlink" title="二.子模块之间通信基本方案"></a>二.子模块之间通信基本方案</h3><blockquote>
<p>子模块之间通信方式有广播、EventBus、类加载机制、全局Map等方式，这里只介绍类加载和全局Map的方式，前两种可以实现效果，但项目中基本不用</p>
</blockquote>
<ol>
<li><p>类加载方式</p>
<p>先说明一下为什么能够通过类加载的方式来实现子模块间的通信</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png" style="zoom:33%;" />

<p>可以看到dex文件中的类都是放在一起的，并不会受模块化的影响，所以就可以通过类加载的方式来通过Intent跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">               val targetClazz = Class.forName(&quot;com.bytedance.register.RegisterActivity&quot;)</span><br><span class="line">               startActivity(Intent(this,targetClazz))</span><br><span class="line">           &#125; catch (e: Exception) &#123;</span><br><span class="line">               e.printStackTrace()</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>这种方式简单可行，但缺点也很明显，难以维护，实际撸码的时候一定要确保类名没写错，否则直接崩了</p>
</li>
<li><p>全局Map</p>
<p>在公共的模块中通过一个仓库存储所有的Class对象，所有模块都会依赖这个公共模块，所以在A模块中可以通过相应的信息拿到B模块中Activity的Class</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%85%A8%E5%B1%80Map.png" style="zoom:33%;" />

<p>该方式不容易出错，但是一旦类变多了，则手动添加的次数也会变多，未免显得有些麻烦，这种方式是为后续的组件路由ARouter做铺垫</p>
<h3 id="三-Arouter路由"><a href="#三-Arouter路由" class="headerlink" title="三.Arouter路由"></a>三.Arouter路由</h3><blockquote>
<p>以上两种方式虽然都能实现子模块间的跳转，但在项目中不适用，下面介绍阿里开源的一个路由框架Arouter</p>
</blockquote>
<p>这里先介绍用法，以Kotlin为例(坑比java稍多)</p>
<ol>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &quot;com.alibaba:arouter-api:1.5.2&quot;</span><br><span class="line">kapt &quot;com.alibaba:arouter-compiler:1.5.2&quot;</span><br></pre></td></tr></table></figure>

<p>这里的版本号最好通过一个公共的配置文件进行管理，kotlin需要使用注解处理器插件<code>apply plugin: &#39;kotlin-kapt&#39;</code></p>
</li>
<li><p>Arouter根据组名的不同分类管理，所以需要从gradle配置中透传app模块名作为组名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">        kapt &#123;</span><br><span class="line">            arguments &#123;arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName())&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Application初始化时初始化ARouter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyApp: Application() &#123;</span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">        if (isDebug()) &#123;           // 这两行必须写在init之前，否则这些配置在init过程中将无效</span><br><span class="line">    		ARouter.openLog();     // 打印日志</span><br><span class="line">    		ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有					安全风险)</span><br><span class="line">			&#125;</span><br><span class="line">			ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>跳转原理</p>
<p>Arouter跳转的原理和上面介绍的全局Map保存所有Activity的Class对象很类似，只不过Arouter通过APT进行处理，根据path来跳转，所以每个Activity都需要对应一个自己的path，如”/app/MainActivity”，通过@Route(path)来标识一个Activity，这里的path最好通过一个常量类管理</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/path%E5%AD%98%E5%82%A8Class%E5%AF%B9%E8%B1%A1.png"></p>
<p>如上图，ARouter会在编译器扫描所有使用@Route标识path的Activity，并将模块名作为组名分组管理，每个模块都会生成类似的管理类，这个管理和全局Map方式的管理方式相似，简化一下就是说，<strong>path为key，Class对象为value</strong>，编译期存储，跳转的时候根据目的Activity的path取出目的Activity的Class对象，然后跳转，这也就是路由寻址，然后跳转</p>
</li>
<li><p>跳转传参</p>
<p>路由跳转的时候可以传递参数，以及序列化的对象，为了简化路由跳转，下面做了一层扩展</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun open(path: String, build: Postcard.() -&gt; Unit = &#123;&#125;) &#123;</span><br><span class="line">        val postcard = ARouter.getInstance().build(path)</span><br><span class="line">        postcard.build()</span><br><span class="line">        postcard.navigation()</span><br><span class="line">    &#125;</span><br><span class="line">fun openWithFinish(path: String, build: Postcard.() -&gt; Unit = &#123;&#125;) &#123;</span><br><span class="line">        open(path, build)</span><br><span class="line">        finish()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过函数扩展的方式让跳转时方便许多，还可做其他扩展，方便路由成功时做回调</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(RouterPathConstants.PERSONAL_ACTIVITY_PATH)&#123;</span><br><span class="line">                withString(&quot;name&quot;,&quot;fuck&quot;)</span><br><span class="line">                withInt(&quot;age&quot;,12)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>在目的页面通过@Autowired、@JvmField同时作用于字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired    //@Autowired(name = &quot;name&quot;)这样也是可以，下面的属性名就可以换用其他名</span><br><span class="line">  @JvmField</span><br><span class="line">   var name: String? = null</span><br><span class="line">      </span><br><span class="line">  @Autowired</span><br><span class="line">  @JvmField</span><br><span class="line">   var age: Int = 0</span><br></pre></td></tr></table></figure>

<p>在目的Activity中还需进行注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().inject(this)</span><br></pre></td></tr></table></figure></li>
<li><p>路由跳转成功的回调以及从上一个页面返回携带结果值的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().build(RouterPathConstants.PERSONAL_ACTIVITY_PATH).navigation(this,</span><br><span class="line">                    REQUEST_CODE,object: NavigationCallback&#123;</span><br><span class="line">                    override fun onFound(postcard: Postcard?) &#123;</span><br><span class="line">                        Log.e(&quot;cx&quot;,&quot;路由成功&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    override fun onLost(postcard: Postcard?) &#123;</span><br><span class="line">                        Log.e(&quot;cx&quot;,&quot;路由失败&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    override fun onArrival(postcard: Postcard?) &#123;</span><br><span class="line">                        Log.e(&quot;cx&quot;,&quot;跳转成功&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    override fun onInterrupt(postcard: Postcard?) &#123;</span><br><span class="line">                        Log.e(&quot;cx&quot;,&quot;被拦截&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>注：请求码一定要大于0，否则不会回到onActivityResult方法，其余步骤和startActivityForResult一样</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>本文只介绍了路由方式的基本使用，碍于时间问题，只能后续补一篇关于ARouter的详细流程分析，并用APT手撸ARouter，其实原理很简单，上面稍微介绍了一下，APT生成相关的组管理器后，在此基础上封装一层路由寻址就好，通过反射的方式，取出组管理器，然后根据组管理器拿到目的页面的Class对象，即可跳转</p>
</blockquote>
<p><a href="https://github.com/alibaba/ARouter/blob/master/README_CN.md">其余高级用法参考官网文档</a></p>
<p><a href="https://gitee.com/wiwiyiyi/modulize_router">代码链接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>组件化系列</category>
      </categories>
  </entry>
  <entry>
    <title>将数字翻译成字符串</title>
    <url>/%E5%B0%86%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt; 231</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><p>小编在拿到这道题后很自然的想到将数字转换字符串，进而得到字符数组，然后遍历数组，但最终也只考虑到了相邻两个元素，一种情况中可能存在多个两两成对的情况，普通的遍历不能解决问题，官网给出的解决方案是动态规划，首先建立状态转移方程</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.png"></p>
<p>首先用dp一维数组来保存每次遍历的总结果数，则<code>dp[i] = dp[i-1] + dp[i-2]</code>，该数组的起始值为1，有没有更多的情况取决于有没有相邻的两个数组合后可以翻译成一个字符，每次遍历之前都会先复制保存上一次遍历的结果，显然从第三位数开始才会有<strong>上图最后2位的部分翻译结果数</strong>，如果当前的最后两位不能翻译，那么就相当于上图的第一种情况，而当前的结果数显然就是上一次遍历后的结果数，有点绕，可以结合代码进行理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int translateNum(int num) &#123;</span><br><span class="line">        String sNum = String.valueOf(num);</span><br><span class="line">        int  length = sNum.length();</span><br><span class="line">        if(length&lt;2) return 1;</span><br><span class="line">        int[] dp = new int[length];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        char[] nums = sNum.toCharArray();</span><br><span class="line">        for(int i = 1;i&lt;length;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-1];</span><br><span class="line">            int curNum = (nums[i-1]-&#x27;0&#x27;)*10+(nums[i]-&#x27;0&#x27;);</span><br><span class="line">            if(curNum&gt;9&amp;&amp;curNum&lt;26)&#123;</span><br><span class="line">                if(i-2&lt;0)&#123;</span><br><span class="line">                    dp[i]++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i]+=dp[i-2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[length-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>个人感觉动态规划的关键点就是分析出递归方程即动态转移方程，通过一维数组来保存每次的结果，这比递归调用好很多，毕竟递归调用会计算重复的子状态，时间复杂度太高</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>对象序列化</title>
    <url>/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在实际开发中，我们会涉及到将一个对象数据存入数据库或者上传到服务器，而底层的数据传输只能以字节流的形式进行，所以本文将介绍如何将一个对象转换成字节流的形式进行数据传输，即对象的序列化</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96.png" style="zoom:33%;" />

<p>当然，有序列化也会有反序列化，从数据库或者云端加载得到的二进制数据通过<strong>反序列化转换成可操作的对象数据</strong></p>
<p>对象的序列化分以下三种方式：</p>
<ol>
<li><p>Serializable</p>
<p>Java自带的原生态接口，只需要让进行序列化的类实现接口即可，做一个标记，具体的实现是JDK帮我们完成，使用也简单，但缺点是效率太低</p>
</li>
<li><p>Parcelable</p>
<p>Android系统定制的，效率更高，适合进程间的通信</p>
</li>
<li><p>XML/JSON</p>
<p>基于文本的序列化，优点很明显，可读性高，对使用者友好</p>
</li>
</ol>
<p><strong>就目前来说，我用得最多的是XML/JSON的形式，后来Google推出了GSON工具类，让JSON数据的解析更加轻松</strong></p>
<h3 id="二-Serializable的基本使用"><a href="#二-Serializable的基本使用" class="headerlink" title="二.Serializable的基本使用"></a>二.Serializable的基本使用</h3><p>上面也提到了，只要让需要进行序列化的类实现Serializable接口即可，不需要实现任何方法，只是做一个标记，具体的实现是有JDK来完成，读写文件通过<strong>Object字节流</strong>进行即可，下面通过一个小例子来演示</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/Serializable%E5%B1%95%E7%A4%BA.gif" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data class Stuent(</span><br><span class="line">    val name:String,</span><br><span class="line">    val age:Int,</span><br><span class="line">    val score: Score</span><br><span class="line">):Serializable</span><br><span class="line">class Score(val Math:Int,val English:Int,val Chinese:Int):Serializable&#123;</span><br><span class="line">    var grade = &quot;&quot;</span><br><span class="line">    init &#123;</span><br><span class="line">        if (Math&gt;90&amp;&amp;English&gt;90&amp;&amp;Chinese&gt;90)&#123;</span><br><span class="line">            grade = &quot;A&quot;</span><br><span class="line">        &#125;else if (Math&gt;80&amp;&amp;English&gt;80&amp;&amp;Chinese&gt;80)&#123;</span><br><span class="line">            grade = &quot;B&quot;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            grade = &quot;C&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">fun saveData()&#123;</span><br><span class="line">        val math = inputMath.text.toString().toInt()</span><br><span class="line">        val english = inputEnglish.text.toString().toInt()</span><br><span class="line">        val chinese = inputChinese.text.toString().toInt()</span><br><span class="line">        val name = inputName.text.toString()</span><br><span class="line">        val age = inputAge.text.toString().toInt()</span><br><span class="line">        val score = Score(math,english,chinese)</span><br><span class="line">        val stuent = Stuent(name,age,score)</span><br><span class="line">        val objectOutputStream = ObjectOutputStream(openFileOutput(FILE_NAME, MODE_PRIVATE))</span><br><span class="line">        objectOutputStream.use &#123;</span><br><span class="line">            it.writeObject(stuent)</span><br><span class="line">            it.flush()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">fun loadData()&#123;</span><br><span class="line">        val objectInputStream = ·(openFileInput(FILE_NAME))</span><br><span class="line">        objectInputStream.use &#123;</span><br><span class="line">            val student = it.readObject() as Stuent</span><br><span class="line">            inputName.setText(student.name)</span><br><span class="line">            inputAge.setText(student.age.toString())</span><br><span class="line">            inputMath.setText(student.score.Math.toString())</span><br><span class="line">            inputEnglish.setText(student.score.English.toString())</span><br><span class="line">            inputChinese.setText(student.score.Chinese.toString())</span><br><span class="line">            showGrade.text = student.score.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>直接上代码，由于<code>Student</code>和<code>Score</code>类都需要存入文件即都需序列化，因此两个类都需实现<code>Serializable</code>接口，做标记，系统会自动识别，使用的时候只需要通过<code>ObjectOutputStream</code>写入对象即可，之后可以在data/data/包名/files目录下找到存储过后的文件，打开后全是16进制数据，可通过特殊工具查看，反序列化通过<code>ObjectInputStream</code>读取一个对象即可</p>
</blockquote>
<p> <strong>另外需要注意一点的是，需要手动添加一个long类型的静态seriaVersionUID，如果不添加，系统自动生成一个，但如果你增加了属性，那么又会生成一个新的UID，如此一来就会发生版本不兼容问题，所以最好我们自己写死一个UID</strong></p>
<h3 id="三-Parcelable"><a href="#三-Parcelable" class="headerlink" title="三.Parcelable"></a>三.Parcelable</h3><p>使用场景：在两个进程或者Activity/Fragment之间传递对象数据</p>
<p>具体使用：只需让类实现该接口，并添加相应的方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Activity1</span><br><span class="line">jump.setOnClickListener &#123;</span><br><span class="line">            val name = inputName.text.toString()</span><br><span class="line">            val age = inputAge.text.toString().toInt()</span><br><span class="line">            val math = inputMath.text.toString().toInt()</span><br><span class="line">            val english = inputEnglish.text.toString().toInt()</span><br><span class="line">            val student = Student(name,age, Score(math,english))</span><br><span class="line">            val bundle = Bundle().apply &#123;</span><br><span class="line">                putParcelable(&quot;student&quot;,student)</span><br><span class="line">            &#125;</span><br><span class="line">            Intent(this,MainActivity2::class.java).apply &#123;</span><br><span class="line">                putExtra(&quot;data&quot;,bundle)</span><br><span class="line">                startActivity(this)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//Activity2</span><br><span class="line">val bundle = intent.getBundleExtra(&quot;data&quot;)</span><br><span class="line">        val student = bundle?.getParcelable&lt;Student&gt;(&quot;student&quot;)</span><br><span class="line">        student?.let &#123;</span><br><span class="line">            showName.text = it.name</span><br><span class="line">            showAge.text = it.age.toString()</span><br><span class="line">            showMath.text = it.score?.math.toString()</span><br><span class="line">            showEnglish.text = it.score?.english.toString()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/Parcelable.gif" style="zoom:33%;" />

<p><strong>从上面的代码可以看出传递数据使用对象数据方便很多，否则需要一条一条的放进Bundle对象，太繁琐</strong></p>
<h3 id="四-XML-JSON"><a href="#四-XML-JSON" class="headerlink" title="四.XML/JSON"></a>四.XML/JSON</h3><p>网络操作常用格式，通过key-Value键值对的方式存储数据，用一对大括号表示一个单元，<strong>整个大括号</strong>对应的是一个对象，使用Google推出的Gson工具类可以轻松进行对象序列化和反序列化，下面通过代码进行演示</p>
<p>添加依赖<code> implementation &#39;com.google.code.gson:gson:2.8.6&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val student = Student(&quot;jack&quot;,18, Score(100,100))</span><br><span class="line">val gson = Gson()</span><br><span class="line">//序列化，转换成Json字符串</span><br><span class="line">val studentJson = gson.toJson(student)</span><br><span class="line">Log.v(&quot;cx&quot;,&quot;Json格式：$studentJson&quot;)</span><br><span class="line">//反序列化，将Json字符串转换成对象数据</span><br><span class="line">val jsonStr = &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:80,\&quot;Math\&quot;:80&#125;&#125;&quot;</span><br><span class="line">val student2 = gson.fromJson(jsonStr,Student::class.java)</span><br></pre></td></tr></table></figure>

<p><strong>将对象数据转换成字符串</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/jsonShow.png"></p>
<p><strong>将Json格式的字符串转换成对象数据</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/json%E8%A7%A3%E6%9E%90.png" style="zoom: 33%;" />

<p>所以只需创建一个Gson的对象，用它实现转换即可</p>
<p><strong>除此之外，Gson还可以转换对象数组，下面以一个小项目的部分代码进行展示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                   val result = response.body?.string()</span><br><span class="line">                   val students = gson.fromJson(result, Array&lt;Student&gt;::class.java)</span><br><span class="line">                   val msg = Message()</span><br><span class="line">                   msg.what = Repository.MSG_TYPE_STUDENTINFOR</span><br><span class="line">                   msg.obj = students</span><br><span class="line">                   handler.sendMessage(msg)</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p>当时使用的是Okhttp进行网络请求，从服务器端返回Json字符串，即<code>result</code>，然后通过Gson转换成Student的数组类型，最后通过Handler中的Message进行数据传递，将对象数组转换成Json字符串如法炮制</p>
<p><strong>可以通过<code>TypeToken</code>创建新的类型数据</strong></p>
<p>将<code>[&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;jack&quot;,&quot;score&quot;:&#123;&quot;English&quot;:100,&quot;Math&quot;:100&#125;&#125;,&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;rose&quot;,&quot;score&quot;:&#123;&quot;English&quot;:90,&quot;Math&quot;:90&#125;&#125;,&#123;&quot;age&quot;:18,&quot;name&quot;:&quot;xw&quot;,&quot;score&quot;:&#123;&quot;English&quot;:80,&quot;Math&quot;:80&#125;&#125;]</code>转换成<code>List类型</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val Jsonstr = &quot;[&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;jack\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:100,\&quot;Math\&quot;:100&#125;&#125;,&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;rose\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:90,\&quot;Math\&quot;:90&#125;&#125;,&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;xw\&quot;,\&quot;score\&quot;:&#123;\&quot;English\&quot;:80,\&quot;Math\&quot;:80&#125;&#125;]&quot;</span><br><span class="line">val typeStudents = object :TypeToken&lt;List&lt;Student&gt;&gt;()&#123;&#125;.type</span><br><span class="line">val studentLists = gson.fromJson&lt;List&lt;Student&gt;&gt;(Jsonstr,typeStudents)</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/%E8%A7%A3%E6%9E%90%E6%88%90List.png" style="zoom: 40%;" />

<p><strong>如果与你对接的人对变量的命名习惯不同，那么你可以通过增加注解，为变量增添一个名字，从而解析处理的Json字符串中的变量名就是注解添加的变量名</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BA%8F%E5%88%97%E5%8C%96/json%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3.png" style="zoom:75%;" />

<p>转换结果：[{“student_age”:18,”student_name”:”jack”,”score”:{“English”:100,”Math”:100}},{“student_age”:18,”student_name”:”rose”,”score”:{“English”:90,”Math”:90}},{“student_age”:18,”student_name”:”xw”,”score”:{“English”:80,”Math”:80}}]</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>对比三种反序列化的方式，XML/JSON格式最为简单，并且可读性很高，就目前而言，也是写项目常用</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍了简单工厂模式，并模拟了果园摘水果的场景，那么试想，如果果园的水果种类爆炸性增长，那么SimpleFruitFactory这个类会不断修改而且还不符合如下原则：</p>
</blockquote>
<ol>
<li>不符单一职责原则：一个类负责了各种各样水果的创建</li>
<li>不符开闭原则：扩展品类的时候，需要修改已有的代码</li>
</ol>
<p>下面介绍工厂方法模式</p>
<h3 id="二-工厂方法"><a href="#二-工厂方法" class="headerlink" title="二.工厂方法"></a>二.工厂方法</h3><p>有了如上思考，再结合实际生活，比如果园肯定会分门别类，专门种苹果的叫苹果园，以此类推香蕉园、橘子园等等，只要新增一个品种，我们就新增一个xx园</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9E%9C%E5%9B%AD%E5%9B%BE%E8%A7%A3.png"></p>
<p>结构图</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>如此一来，一个工厂生成一种水果，符合单一职责，新增水果种类，就新增对应的工厂类，符合开闭原则</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface FruitFactory &#123;</span><br><span class="line">    fun getFruit(): Fruit</span><br><span class="line">&#125;</span><br><span class="line">//具体实现</span><br><span class="line">class AppFactory: FruitFactory &#123;</span><br><span class="line">    override fun getFruit(): Fruit &#123;</span><br><span class="line">        return Apple()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BananaFactory: FruitFactory &#123;</span><br><span class="line">    override fun getFruit(): Fruit &#123;</span><br><span class="line">        return Banana(&quot;采摘员一号&quot;,100)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用者只需要寻找对应的工厂类产生对象即可，可以发现返回值都是Fruit，也就是面向接口编程，在实际开发中很常用</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>通过工厂方法模式解决了简单工厂模式中不符六大原则的弊端，重点在于分门别类，也就是单一职责以及开闭原则</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍希尔排序，希尔排序是改进后的插入排序，虽然效率提高了，但它是不稳定的，因此很少使用</p>
</blockquote>
<h3 id="二-希尔排序原理以及代码实现"><a href="#二-希尔排序原理以及代码实现" class="headerlink" title="二.希尔排序原理以及代码实现"></a>二.希尔排序原理以及代码实现</h3><p>先上动图</p>
<p><img src="http://p2.itc.cn/images03/20200526/1b76d0ccb5ba4179bee9e177f557a7eb.gif"></p>
<blockquote>
<p>希尔排序是根据<strong>间隔</strong>来取出对应的元素，并对它们进行插入排序，外层是依次挪动的，而内层是根据间隔跳跃往前进行插入排序，最外层是控制<strong>间隔的不断减少</strong>，直到减少为1，也就是说最后一次排序是完整的插入排序，经过前面几次跳跃式的插入排序，数组中的元素大致趋势是从小到大，所以最后一次完整的插入排序很快，移动元素的次数大大减少了，这也是为什么说希尔排序是插入排序的改进版本，但由于它是跳跃式的，如果存在相同元素，它们的相对位置可能发生改变，所以希尔排序是不稳定的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void shellSort(int[] dataArray)&#123;</span><br><span class="line">        for (int gap = 4; gap&gt;0; gap/=2) &#123;</span><br><span class="line">            for(int i=gap;i&lt; dataArray.length;i++)&#123;</span><br><span class="line">                for(int j= i;j&gt;gap-1;j-=gap)&#123;</span><br><span class="line">                    if (dataArray[j-gap]&gt;dataArray[j])&#123;</span><br><span class="line">                        int temp = dataArray[j];</span><br><span class="line">                        dataArray[j] = dataArray[j-gap];</span><br><span class="line">                        dataArray[j-gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上算法需要注意的是第二层for循环是<code>i++</code>，而不是<code>i+=gap</code>，只有进行插排时才是向前跳跃间隔比较查找</p>
</blockquote>
<h3 id="三-间隔数的设置"><a href="#三-间隔数的设置" class="headerlink" title="三.间隔数的设置"></a>三.间隔数的设置</h3><p>希尔排序间隔数的设置也是挺有讲究的，不同的间隔显然效率不同，间隔大时移动次数比较少，间隔小时移动距离比较短，而希尔排序的创始人想的是以数组大小的一半为起始间隔，然后依次折半，但这并不是效率最高的，下面介绍一种间隔序列：<strong>Knuth序列</strong></p>
<p>首先根据公式以及约束条件求出最大的间隔h</p>
<p>h = 1</p>
<p>h = h*3+1 -&gt; 1、4、13…..</p>
<p>约束条件是h小于数组的长度除以3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int h = 1;</span><br><span class="line">while (h&lt; dataArray.length/3)&#123;</span><br><span class="line">       h = 3*h + 1;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时，gap = (gap-1)/3，gap的初值是h</p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>1.3</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>希尔排序很少用，记住它的时间复杂度即可，以及它是不稳定的</p>
</blockquote>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>对Kotlin和Java中泛型的回顾</title>
    <url>/%E5%AF%B9Kotlin%E5%92%8CJava%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9B%9E%E9%A1%BE.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文旨在回顾Java中的泛型，同时也会补充之前遗漏的一些知识点</p>
</blockquote>
<p>参考之前写过的两篇文章</p>
<p><a href="https://www.jianshu.com/p/5986a7c94075">Java中泛型的基本使用</a></p>
<p><a href="https://www.jianshu.com/p/f0bc9171ac75">Kotlin中泛型的基本使用</a></p>
<h3 id="二-要点补充"><a href="#二-要点补充" class="headerlink" title="二.要点补充"></a>二.要点补充</h3><p><strong>对型变的理解</strong></p>
<h6 id="什么是型变"><a href="#什么是型变" class="headerlink" title="什么是型变"></a>什么是型变</h6><p>型变在Java中理解就是利用有限制通配符来提升 API 的灵活性，具体分为<strong>协变</strong>、<strong>逆变</strong>和<strong>不变</strong></p>
<h6 id="为什么需要型变，用来解决什么问题"><a href="#为什么需要型变，用来解决什么问题" class="headerlink" title="为什么需要型变，用来解决什么问题"></a>为什么需要型变，用来解决什么问题</h6><p>下面通过一个例子来说明，首先需要知道的是Java 中的泛型是<strong>不型变的</strong>，这意味着 <code>List&lt;String&gt;</code> 并<strong>不是</strong> <code>List&lt;Object&gt;</code> 的子类型，下面的例子来自官方文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Java</span><br><span class="line">List&lt;String&gt; strs = new ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Object&gt; objs = strs; // ！！！此处的编译器错误让我们避免了之后的运行时异常</span><br><span class="line">objs.add(1); // 这里我们把一个整数放入一个字符串列表</span><br><span class="line">String s = strs.get(0); // ！！！ ClassCastException：无法将整数转换为字符串</span><br></pre></td></tr></table></figure>

<p>因为Java本身不支持型变，所以上面的代码会报错，当然了，这样做是为了安全性，但是add元素的时候怎么做呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Java</span><br><span class="line">void copyAll(Collection&lt;Object&gt; to, Collection&lt;String&gt; from) &#123;</span><br><span class="line">  to.addAll(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然根据上面的叙述这样添加肯定会报错，改进如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Java</span><br><span class="line">interface Collection&lt;E&gt; …… &#123;</span><br><span class="line">  void addAll(Collection&lt;? extends E&gt; items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子就是<strong>协变</strong>，我理解<strong>协变和逆变</strong>就是用于解决这一类问题，不变就不需要额外考虑了，就是最普通的那种用法</p>
<p>Java中逆变的写法是<code>&lt;? super String&gt;</code></p>
<h6 id="协变的应用"><a href="#协变的应用" class="headerlink" title="协变的应用"></a>协变的应用</h6><p>这里先给出类之间的继承关系</p>
<p>Food</p>
<ul>
<li>Fruit<ul>
<li>Apple<ul>
<li>Hongfushi</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 常见的泛型应用类</span><br><span class="line">public class MyObj&lt;T&gt; &#123;</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyObj&lt;Food&gt; objFood = new MyObj&lt;&gt;();</span><br><span class="line">MyObj&lt;Fruit&gt; objFruit = new MyObj&lt;&gt;();</span><br><span class="line">MyObj&lt;Apple&gt; objApple = new MyObj&lt;&gt;();</span><br><span class="line">MyObj&lt;HongFuShi&gt; objHongfushi = new MyObj&lt;&gt;();</span><br><span class="line"></span><br><span class="line">MyObj&lt;? extends Fruit&gt; myObj;</span><br><span class="line">myObj = objFruit;</span><br><span class="line">myObj = objApple;</span><br><span class="line">myObj = objHongfushi;</span><br><span class="line">myObj = objFood; // 报错!!!，因为extends的限制，只支持Fruit的子类类型</span><br><span class="line"></span><br><span class="line">// 对泛型元素的操作</span><br><span class="line">myObj.setData(new Apple()); // 报错!!!，不允许 set元素，换成其他类型也一样</span><br><span class="line">Fruit data = myObj.getData(); // get的类型只能是限定的类型 Fruit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意的是协变中不允许修改元素也就是set，因为限定元素的子类有很多种，并不能知道是哪一种，所以为了安全性考虑，就不允许修改，而获取元素是可以的，因为知道上限</p>
</blockquote>
<h6 id="逆变的应用"><a href="#逆变的应用" class="headerlink" title="逆变的应用"></a>逆变的应用</h6><p>具体示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyObj&lt;Food&gt; objFood = new MyObj&lt;&gt;();</span><br><span class="line">MyObj&lt;Fruit&gt; objFruit = new MyObj&lt;&gt;();</span><br><span class="line">MyObj&lt;Apple&gt; objApple = new MyObj&lt;&gt;();</span><br><span class="line">MyObj&lt;HongFuShi&gt; objHongfushi = new MyObj&lt;&gt;();</span><br><span class="line"></span><br><span class="line">MyObj&lt;? super Apple&gt; myObj;</span><br><span class="line">myObj = objFruit;</span><br><span class="line">myObj = objFood;</span><br><span class="line">myObj = objHongfushi; // 报错!!!，只能接受限定类型的父类</span><br><span class="line"></span><br><span class="line">// 对泛型元素的操作</span><br><span class="line">myObj.setData(new Apple());</span><br><span class="line">myObj.setData(new HongFuShi());</span><br><span class="line">myObj.setData(new Fruit()); // 报错!!!，这里比较特殊，有点反常理</span><br><span class="line">Object data = myObj.getData();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>依然需要注意的是对泛型元素的操作，修改元素有点反常理，<strong>限定是super，但却只支持限定元素的本身以及子类</strong>，这个地方会比较坑，需要额外注意。获取的元素类型只能是Object类型，这个比较好理解，万物之父</p>
</blockquote>
<h6 id="对比Java和Kotlin中的型变"><a href="#对比Java和Kotlin中的型变" class="headerlink" title="对比Java和Kotlin中的型变"></a>对比Java和Kotlin中的型变</h6><p>有了上面Java型变的基础，理解Kotlin中的型变会更加轻松</p>
<p>Kotlin中通过out和in来规定协变还是逆变，对应关系如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out Apple -&gt;? super Apple</span><br><span class="line"></span><br><span class="line">in Apple -&gt; ? extends Apple</span><br></pre></td></tr></table></figure>

<p>有的时候硬背这个对应关系就行，但还是重在理解</p>
<p>这里需要额外注意的是，Kotlin支持声明类处增加型变，而Java不支持！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// out</span><br><span class="line">class MyClass &lt;out T&gt; (private val data: T)&#123;</span><br><span class="line">    fun produceT(): T &#123;</span><br><span class="line">        return data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// in</span><br><span class="line">class MyClass &lt;in T&gt; ()&#123;</span><br><span class="line">    fun consumeT(data: T)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以结合上面Java中的示例来理解</p>
<ul>
<li>out等价于 ? extends，所以不允许修改值，那么也就不能作为消费者，修改理解为消费，所以就只能作为生产者的角色</li>
<li>in等价于? super，根据上面Java的例子，通过get的方式获得的类型是Object，那其实这样的类型也没办法进行消费(除非强转，可能抛异常)，所以Kotlin中索性只能让它修改，也就是消费</li>
</ul>
<p>所以Kotlin官方将out称作生产者(只能用作返回值)，in称作消费者(只能用作入参)</p>
<h3 id="三-对泛型的一些应用以及总结"><a href="#三-对泛型的一些应用以及总结" class="headerlink" title="三.对泛型的一些应用以及总结"></a>三.对泛型的一些应用以及总结</h3><p>上面也罗列得比较详细了，Java中需要注意的就是逆变情况，对于泛型元素的操作有点反常，此外结合Kotiln中out和in一起记忆</p>
<ol>
<li><p>勿把泛型约束和泛型型变混淆</p>
<p>泛型中的约束是约束泛型类型的上限，Java中使用extends关键字，Kotlin中则是通过冒号**:**实现</p>
</li>
<li><p>平时用Kotlin用得比较多，因为泛型擦除的机制导致我们拿不到具体的泛型类型，而Kotlin为我们解决了这个问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline fun &lt;reified T&gt; saveType() &#123;</span><br><span class="line">        val type = T::class.java</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个在网络解析数据那里比较有用</p>
</li>
<li><p>泛型不能透传，最多传递一次！！！</p>
</li>
<li><p>泛型擦除</p>
<ul>
<li><p>Java中的泛型是伪泛型，编译之后会直接变成Object类型，然后会通过强转的形式来间接实现泛型</p>
</li>
<li><p>泛型约束可以添加多个类型，但是擦除后只会强转为第一个类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyObj&lt;T extends Comparable &amp; Serializable&gt; // 编译后只会留下Comparable类型</span><br></pre></td></tr></table></figure></li>
<li><p>因为擦除的原因在方法重载时也需注意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(List&lt;String&gt; list) &#123; &#125;</span><br><span class="line">void test(List&lt;Integer&gt; list) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>这种情况并非重载，最终类型都是List&lt;Object&gt;，所以会报错</p>
</li>
</ul>
<p>PS：对于泛型擦除这里再稍微补充一下背景，其实在<strong>JDK 1.0</strong>的时候是不支持泛型的，统一用Object类型来实现(1.5以前的版本都是这样)，所以后续的版本为了兼容这个有问题的版本就有了泛型擦除机制，真正的泛型信息是保存在Signature中</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍使用频率较高的快速排序，内部采用递归，同样是深度优先算法，个人感觉编写此算法时容易出bug</p>
</blockquote>
<h3 id="二-快速排序原理以及代码实现"><a href="#二-快速排序原理以及代码实现" class="headerlink" title="二.快速排序原理以及代码实现"></a>二.快速排序原理以及代码实现</h3><p><img src="https://img-blog.csdnimg.cn/2019060415201822.gif"></p>
<blockquote>
<p>快速排序基本思路是，首先确定一个**轴(pivot)**，通过一趟排序，实现比轴小的数都放在左边，比轴大的数都放在右边，因此我们需要定义两个指针，左指针从左往右依次查找比轴大的数，右指针从右往左查找比轴小的数，找到之后两者交换，一趟排序结束后，分成了左右两个区域，然后对左右两个区域进行递归继续排序，为了缕清思路，还是先从一趟排序开始，确定没有bug后再进行递归</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void sort(int[] arr,int leftBound,int rightBound)&#123;</span><br><span class="line">            if (leftBound &gt;= rightBound) return;</span><br><span class="line">           int mid = partition(arr,leftBound,rightBound);</span><br><span class="line">           sort(arr,leftBound,mid-1);</span><br><span class="line">           sort(arr,mid+1,rightBound);</span><br><span class="line">    &#125;</span><br><span class="line">    static int partition(int[] arr,int leftBound,int rightBound)&#123;</span><br><span class="line">        int pivot = arr[rightBound];</span><br><span class="line">        int leftPtr = leftBound;</span><br><span class="line">        int rightPtr = rightBound-1;</span><br><span class="line">        while (leftPtr &lt;= rightPtr)&#123;</span><br><span class="line">            while (leftPtr&lt;=rightPtr &amp;&amp; arr[leftPtr] &lt;= pivot) leftPtr++;</span><br><span class="line">            while (leftPtr&lt;=rightPtr &amp;&amp; arr[rightPtr] &gt; pivot) rightPtr--;</span><br><span class="line">            if (leftPtr&lt;rightPtr)  swap(arr,leftPtr,rightPtr);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,leftPtr,rightBound);</span><br><span class="line">        return leftPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    static void swap(int[] arr,int i,int j)&#123;</span><br><span class="line">        int temp = arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>坑点分析：</strong></p>
<ol>
<li><p>外层while循环一定是左指针的小于等于右指针，因为如果最后是两个数进行排序的话，左指针或者右指针必须发生移动，否则会出现逆序</p>
</li>
<li><p>从左往右查找比轴大的数时，一定要把等于轴的数跳过，否则会出现右侧有等于轴的数</p>
</li>
<li><p>内层的两个while循环都必须加上左指针小于等于右指针的条件，否则会出现左右指针越界问题，这个可以取极端情况，比如最右侧取为轴，并且轴是最大或者最小的数，此时就会报错</p>
</li>
<li><p>一趟排序完成后，需要返回轴的位置，因为发生了交换所以左指针就是轴，其余递归是在轴的左右剩余区域再进行排序，轴不会发生位置的改变</p>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>快速排序如果不自己动手写写，根本就不会清楚里面的坑点在哪儿，到底哪些地方需要注意边界值能不能取等</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">不稳</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>随着水果店的发展，会想着推出组合套餐的优惠活动，组合是关键点，如下图</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B0%B4%E6%9E%9C%E5%A5%97%E9%A4%90%E5%BB%BA%E9%80%A0%E6%B5%81%E7%A8%8B.png" style="zoom:40%;" />

<p>要实现上述流程，需要用到建造者模式</p>
<h3 id="二-建造者模式实践"><a href="#二-建造者模式实践" class="headerlink" title="二.建造者模式实践"></a>二.建造者模式实践</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BA%A7%E5%93%81%E5%9B%BE.png"></p>
<p>前言中提到的一个个流程就是挨个赋值的过程，这里有两种套餐，自然就有两种不同的组合，建造方式也不同，所以抽象成接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Builder &#123;</span><br><span class="line">    fun buildApple(price: Int):Builder</span><br><span class="line">    fun buildBanana(price: Int):Builder</span><br><span class="line">    fun buildOrange(price: Int):Builder</span><br><span class="line">    fun getFruitMeal():FruitMeal</span><br><span class="line">&#125;</span><br><span class="line">class FruitMeal &#123;</span><br><span class="line">    private var apple:Apple? = null</span><br><span class="line">    private var banana:Banana? = null</span><br><span class="line">    private var orange: Orange? = null</span><br><span class="line"></span><br><span class="line">    private var discount = 0</span><br><span class="line">    private var totalPrice = 0</span><br><span class="line"></span><br><span class="line">    fun init() &#123;</span><br><span class="line">        totalPrice+=apple?.getPrice()?:0</span><br><span class="line">        totalPrice+=banana?.getPrice()?:0</span><br><span class="line">        totalPrice+=orange?.getPrice()?:0</span><br><span class="line"></span><br><span class="line">        totalPrice = if (totalPrice &gt; 0)  totalPrice-discount else totalPrice</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cost() = totalPrice</span><br><span class="line"></span><br><span class="line">    fun setApple(apple: Apple) &#123;</span><br><span class="line">        this.apple = apple</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun setBanana(banana: Banana) &#123;</span><br><span class="line">        this.banana = banana</span><br><span class="line">    &#125;</span><br><span class="line">    fun setOrange(orange: Orange) &#123;</span><br><span class="line">        this.orange = orange</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun setDiscount(discount: Int) &#123;</span><br><span class="line">        this.discount = discount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class HolidayBuilder: Builder &#123;</span><br><span class="line">    private val fruitMeal = FruitMeal()</span><br><span class="line">    override fun buildApple(price: Int): Builder&#123;</span><br><span class="line">        fruitMeal.setApple(Apple(price))</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun buildBanana(price: Int): Builder&#123;</span><br><span class="line">        fruitMeal.setBanana(Banana(&quot;管理员一号&quot;,price))</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun buildOrange(price: Int): Builder &#123;</span><br><span class="line">        fruitMeal.setOrange(Orange(price))</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getFruitMeal(): FruitMeal &#123;</span><br><span class="line">        fruitMeal.setDiscount(15)</span><br><span class="line">        fruitMeal.init()</span><br><span class="line">        return fruitMeal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处为了模仿项目开发中的建造者模式采用了链式调用，其实对比一下，像android中的Dialog，是将Builder嵌套在Dialog内部，而这里是将Builder从FruitMeal中分离了出来，建造者目前看是处理多流程处理的</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E5%92%8C%E5%B7%A5%E5%8E%82%E5%AF%B9%E6%AF%94.png"></p>
<p>建造者本是工厂模式的一种，类比一下，很相似，Builder接口其实就是抽象工厂，具体的Builder就是Factory</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>建造者模式在项目中用的比较广泛，像很多开原框架都会用到，并且不难，最好将Builder嵌套在目标产物的内部</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍稍微复杂一点的排序算法——归并排序，里面采用了递归，所以它是深度优先算法，建议先复习一下递归算法，否则归并排序理解起来不是那么容易</p>
</blockquote>
<h3 id="二-归并排序原理以及代码实现"><a href="#二-归并排序原理以及代码实现" class="headerlink" title="二.归并排序原理以及代码实现"></a>二.归并排序原理以及代码实现</h3><p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif"></p>
<p>结合树形图理解</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326213950253-1393118004.png"></p>
<blockquote>
<p>归并排序主要分为两个过程，<strong>分组</strong>和**归并(Merge)**，所以在进行归并排序之前，可以先将归并算法写好，分组并不难，只需要注意分界点即可，可以使用左右已经排好序的一个数组进行归并测试，如{1,7,9,3,6,8}，分为左右两组，左右两组一次进行比较元素，小的先放进额外分配的数组中，因此归并排序的空间复杂度不再是O(1)，具体的归并算法如下：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void merge(int[] arr,int leftPtr,int rightPtr,int rightBound)&#123;</span><br><span class="line">       int[] testArray = new int[rightBound-leftPtr+1];</span><br><span class="line">       int i = leftPtr,j = rightPtr,k = 0;</span><br><span class="line">       while (i&lt;=rightPtr-1 &amp;&amp; j&lt;=rightBound)&#123;</span><br><span class="line">           testArray[k++] = arr[i]&lt;=arr[j] ? arr[i++]: arr[j++];</span><br><span class="line">       &#125;</span><br><span class="line">       while (i&lt;=rightPtr-1) testArray[k++] = arr[i++];</span><br><span class="line">       while (j&lt;=rightBound) testArray[k++] = arr[j++];</span><br><span class="line">       for(int m=0;m&lt; testArray.length;m++) arr[leftPtr+m] = testArray[m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>比较完毕后，肯定会有一组左边或者右边全都放进了额外数组空间中，那么还需通过一个循环将另外一个数组左边或者右边放进额外数组中，归并完毕后，需要根据已经排好序的额外数组改变原数组中元素的顺序，否则相当于没有排序</strong></p>
<h3 id="三-分组的理解以及完整代码"><a href="#三-分组的理解以及完整代码" class="headerlink" title="三.分组的理解以及完整代码"></a>三.分组的理解以及完整代码</h3><blockquote>
<p>如果是刚接触算法的朋友，可以像上面树形结构图一样画出每次的分组状态，标记出左边界、右边界、中间值的大小，画到最后是以<strong>一个元素为一组结束分组</strong>，并且第一次归并是一个元素或者两个元素进行的，值得注意的是，左边一组的右边界是<code>mid</code>，右边一组的左边界是<code>mid+1</code>，第一次分组的右边一组的右边界可以是<strong>数组长度-1</strong>，也可以是<strong>数组长度</strong>，随之改变的是<code>Merge</code>方法中右边界能不能取等于，小编使用的是<strong>数组长度-1</strong>，因此取等于，完整算法如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void sort(int[] arr,int left,int right)&#123;</span><br><span class="line">        if (left==right) return;</span><br><span class="line">        int mid = left + (right-left)/2;</span><br><span class="line">        sort(arr,left,mid);</span><br><span class="line">        sort(arr,mid+1,right);</span><br><span class="line">        merge(arr,left,mid+1,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>其中mid的算法需要注意，虽然上面的写法的结果和left+right除以2相同，但是如果数组长度很大时，容易超出整数范围，所以这是一个小细节</strong></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(nlog<sub>2</sub>n)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/qq_32534441/article/details/95098059">关于归并排序的时间复杂度计算可以参考此篇文章</a></p>
<blockquote>
<p>由于归并排序是稳定的，应用于java对象排序中，但目前使用的是改进后的归并排序<code>TimSort</code></p>
</blockquote>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化-数据结构优化</title>
    <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>本篇是性能优化的开章，下面先简单聊聊性能优化的目的：</p>
<ol>
<li><p>更快</p>
<p>流畅性：</p>
<ul>
<li><p>启动速度</p>
</li>
<li><p>页面显示速度(显示和切换)</p>
</li>
<li><p>响应速度</p>
</li>
</ul>
</li>
<li><p>更稳定</p>
<p>稳定性：</p>
<ul>
<li>避免出现应用崩溃(Crash) </li>
<li>避免出现应用无响应(ANR)</li>
</ul>
</li>
<li><p>更省</p>
<p>资源节省性：</p>
<ul>
<li>内存大小</li>
<li>安装包大小</li>
<li>耗电量</li>
<li>网络流量</li>
</ul>
</li>
</ol>
<p>那么选择合适的数据结构既可以避免空间换时间的资源浪费，同时还可以提高流畅度，下面递进介绍</p>
<h3 id="二-合适的数据结构演化"><a href="#二-合适的数据结构演化" class="headerlink" title="二.合适的数据结构演化"></a>二.合适的数据结构演化</h3><p><strong>线性表：</strong>在存储数据时首先想到的就是线性结构-列表，分两种</p>
<ol>
<li><p>连续内存的ArrayList</p>
<p>内部就是保存了一个数组</p>
<ul>
<li>优点：查询和修改效率高(通过下表Index访问元素，因为连续，所以通过首地址+index*一个元素所占内存空间直接访问到地址)</li>
<li>缺点：增加和删除效率低，因为涉及到元素移动，具体操作是<code>System.arraycopy</code></li>
</ul>
</li>
<li><p>离散存储的LinkedList(链式结构)</p>
<ul>
<li>优点：增加和删除效率高，直接通过改变指针指向即可</li>
<li>缺点：查询和修改效率低，因为是离散只能通过指针来轮询，有点像顺藤摸瓜</li>
</ul>
</li>
</ol>
<p>经过以上对比，在实际开发中，比如RecyclerView，请求下来的数据通常只是展示作用，也可能对某个元素的状态标志位做修改，很少有增加和删除操作，这种情况显然使用ArrayList效率更高。还记得之前模仿着写Okhttp的一个网络访问框架，内部需要维护一个承载Runnable任务的这么一个队列，显然只关心take和offer，所以使用链式结构更好(阻塞式)</p>
<p><strong>哈希表：</strong>哈希表采用了数组+链表的形式将二者的优势结合起来，效率提高很明显，但是有点浪费空间</p>
<p>JDK1.8以前使用数组+链表，1.8以后使用数组+链表+红黑树，因为如果链表太长会影响查找效率</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/hashmap%E7%BB%93%E6%9E%84.png" style="zoom: 25%;" />

<p>HashMap的基本结构如上，table是一个数组，存储的元素类型是Node结点，一个结点包括hash值，key，value和next指针</p>
<ol>
<li><p>如何快速定位node在一维数组中的位置</p>
<p>基本思想就是求模运算，每一个Key都有一个hashCode，用这个hashCode模上数组的长度就能确定索引位置，由于计算机最终都是二进制的运算，所以位运算比普通的求模运算%效率更高，因此<code>index = (length - 1) &amp; hash</code></p>
</li>
<li><p>哈希冲突的解决</p>
<p>根据求模运算不同的hashCode得到的index值可能会相同，就产生了冲突，HashMap采用了链地址法，所以就有数组+链表一说，如果有冲突，则将新加入的节点插入到冲突index位置链表的末尾，即尾插法</p>
</li>
<li><p>扩容问题</p>
<p>HashMap也会有“装满”，只不过并没有满就会扩容</p>
<p>加载因子：0.75</p>
<p>阈值：HashMap默认大小是16(table大小)，并且源码中规定必须是2的次幂，那么阈值就等于 <strong>加载因子*HashMap大小</strong>，默认是12，当前所有元素的数量超过阈值就会扩容</p>
</li>
<li><p>及最大努力避免哈希冲突</p>
<p>在没有引入红黑树前，肯定要尽量避免哈希冲突，最坏的情况就是所有元素都冲突在一起，也就是一条单链表，显然就失去了HashMap的优势，所以需要避免冲突，明显，如果table的长度越大发生冲突的可能性就越小，源码中进行扩容时将table的<strong>length*2</strong>，所以尽可能扩大阈值，你传入真时的size最好是 size/0.75+1，虽然不一定是2的次幂，但系统会进行一层处理，让它靠向2的次幂，即向上扩大</p>
</li>
<li><p>为什么size尽量是2的次幂</p>
<p>前面提到index的计算方式<code>(length - 1) &amp; hash</code>，如果size是2的次幂，那么length-1转换成2进制一定是全1，如(32-1)=&gt;11111，下面具体感受一下全1的好处</p>
<p>length：14  (14-1) =&gt;1101                  length：16  (16-1) =&gt;1111</p>
<p>hash值1：110        =&gt;0100                                                  =&gt;0110</p>
<p>hash值2：101        =&gt;0100                                                  =&gt;0101</p>
<p>同一个hash值分别按位与，明显感觉到长度为14的方式只有三位起作用，所以无论是110还是101都是相同的结果，而长度为16的结果没有冲突，所以这也就是为什么要使用2的次幂的长度</p>
</li>
<li><p>内存浪费</p>
<p>因为有阈值的存在，所以必定会浪费25%的内存空间，空间换时间的代价有点大，另外就是数组扩容时直接翻倍，这也会浪费空间</p>
</li>
</ol>
<p><strong>SparseArray：</strong>稀疏数组，采用的是双数组的方式，一个数组存Key，一个数组存Value，一一对应</p>
<ul>
<li><p>优势：</p>
<ol>
<li>查找效率高：二分查找，key是Int类型，所以采用二分只能说超快</li>
<li>越用越快：如果要删除值，并非要通过<code>System.arraycopy</code>移动元素，只需要置一个标志位即可，这样的好处是下次如果要在次插入值直接就可以覆盖之前的值</li>
<li>相对于HashMap来说极大地节省了内存</li>
</ol>
</li>
<li><p>不足：</p>
<p>因为Key只能是Int型，所以限制太大</p>
</li>
</ul>
<p><strong>ArrayMap：</strong>Android针对SparseArray创造了ArrayMap，补足了SparseArray只能存储Int型key的缺陷，但由于Android开发中的数据量并不是很大，所以很少见到使用，比较经典的是Bundle，内部就是通过ArrayMap存储键值对</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>确实在实际开发中很少考虑到数据结构的优化，因为数据量不大，差距不明显，个人感觉还是针对特定的场景吧，比如增删和改查这种对立的场景</p>
</blockquote>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面介绍了工厂方法模式，分门别类生产水果，现在有这样一个需求，为了更好的收益，需要将水果进行打包，那么根据工厂方法的思路，每一种水果对应一个bag，并且对应一个bagFactory，那么就有了一下代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Bag &#123;</span><br><span class="line">    fun packageFruit(fruit: Fruit)</span><br><span class="line">&#125;</span><br><span class="line">class AppleBag: Bag &#123;</span><br><span class="line">    override fun packageFruit(fruit: Fruit) &#123;</span><br><span class="line">        println(&quot;苹果使用老百姓口袋&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">interface BagFactory &#123;</span><br><span class="line">    fun getBag(): Bag</span><br><span class="line">&#125;</span><br><span class="line">class AppFactory: FruitFactory &#123;</span><br><span class="line">    override fun getFruit(): Fruit &#123;</span><br><span class="line">        return Apple()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现简单，那么问题来了，Bag也是面向接口编程，传入水果进行打包时，无论是什么水果都可以进行打包，也就是发生了错乱</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E4%BA%A7%E5%93%81%E7%BB%93%E6%9E%84.png" style="zoom:50%;" />

<p>下面介绍抽象工厂模式解决此问题</p>
<h3 id="二-抽象工厂模式"><a href="#二-抽象工厂模式" class="headerlink" title="二.抽象工厂模式"></a>二.抽象工厂模式</h3><blockquote>
<p>产生上述错乱问题的原因就是生成水果和包装的工厂分开管理，所以可以将一种水果的生成和bag的生成聚合在一起，也就抽象出了一个抽象工厂</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E4%BA%A7%E5%93%81%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface AbstractFactory &#123;</span><br><span class="line">    fun getFruit(): Fruit</span><br><span class="line">    fun getBag(): Bag</span><br><span class="line">&#125;</span><br><span class="line">class AppleFactoryImpl: AbstractFactory &#123;</span><br><span class="line">    override fun getFruit(): Fruit &#123;</span><br><span class="line">        return Apple()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getBag(): Bag &#123;</span><br><span class="line">        return AppleBag()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一来获取Fruit时，同时获取Bag，就不会导致混乱，这也提醒我们，如果是有关联的两个Factory，一定要将它们抽象成一个共有的Factory，避免混乱</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>抽象工厂的关键点在于聚合两个有关联的Factory，后续如果还需要生成同一个产品的附件品时，直接在抽象工厂中扩展即可</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>数组的最大子序和</title>
    <url>/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><p>力扣官网通过贪心算法来解决此题，只需要一次遍历，大致思路如下：</p>
<ol>
<li>通过<code>curSum</code>记录上一次的序列和</li>
<li>如果上次序列和加上当前数字不如当前数字大，则舍弃之前的序列和，<code>curSum</code>等于当前数字</li>
<li>比较之前记录的<code>maxSum</code>和<code>curSum</code>，取最大值赋值给<code>maxSum</code></li>
</ol>
<blockquote>
<p>贪心算法的核心就是每次循环都取最好的结果，具体体现在上述的第二步</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int curSum =nums[0], maxSum = nums[0];</span><br><span class="line">        for(int i = 1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            curSum = Math.max(nums[i],curSum+nums[i]);</span><br><span class="line">            maxSum = Math.max(curSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>思路二：动态规划</p>
<blockquote>
<p>如果使用一维数组来存储每次的结果，你会发现代码和贪心算法很像，状态转移方程：<code>dp[i] = Math.max(dp[i-1]+nums[i]，nums[i])</code>，并且空间复杂度变成了O(n)，所以下面不使用一维数组，只是理解起来没有那么容易，但原理是一样的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int curSum = nums[0],maxSum = nums[0];</span><br><span class="line">        for(int i = 1;i &lt; nums.length;i++)&#123;</span><br><span class="line">            if(curSum&lt;0)&#123;</span><br><span class="line">                curSum = nums[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                curSum+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = Math.max(curSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果之前的和为负数，那么它加上一个数，结果肯定会小于这个数本身，所以就舍弃之前的和</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>分享一下小编看到这道题时的想法，考虑的是暴力求解，但却不知每次子序列求和结束的条件是什么，束手无策，看了这贪心算法，确实很妙，所以不用在乎子序列，只需要挨个求和即可</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍插入排序，也是简单排序中的一种，它是稳定的</p>
</blockquote>
<h3 id="二-插入排序原理"><a href="#二-插入排序原理" class="headerlink" title="二.插入排序原理"></a>二.插入排序原理</h3><p>首先先配上一种动图演示插入排序的基本原理</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325144034879-1237555952.gif"></p>
<blockquote>
<p>原理也很简单，有点类似往前的冒泡排序，取出一个数，将它与前面的数进行比较，如果比它小则前面的数往后挪一个位置，然后将它插入，动图也很形象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void insertSort(int[] dataArray)&#123;</span><br><span class="line">        for(int i=0;i&lt; dataArray.length-1;i++)&#123;</span><br><span class="line">            for(int j= i+1;j&gt;0;j--)&#123;</span><br><span class="line">                if (dataArray[j]&lt;dataArray[j-1])&#123;</span><br><span class="line">                    int temp;</span><br><span class="line">                    temp = dataArray[j-1];</span><br><span class="line">                    dataArray[j-1] = dataArray[j];</span><br><span class="line">                    dataArray[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此算法还可以优化，为了减少交换次数，我们可以先将前面所有比它大的元素往后挪动，最后才插入进去，改进如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void insertSort(int[] dataArray)&#123;</span><br><span class="line">        for(int i=0;i&lt; dataArray.length-1;i++)&#123;</span><br><span class="line">            int j = i+1;</span><br><span class="line">            int temp = dataArray[j];</span><br><span class="line">            for(;j&gt;0;j--)&#123;</span><br><span class="line">                if (temp&lt;dataArray[j-1])&#123;</span><br><span class="line">                   dataArray[j] = dataArray[j-1];</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dataArray[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><strong>总结一下三种简单排序算法</strong></p>
<ol>
<li>冒泡：基本不用，太慢</li>
<li>选择：基本不用，不稳</li>
<li>插入：样本小且基本有序的情况效率高</li>
</ol>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><ol>
<li><p>暴力求解</p>
<p>看到这类题目首先暴力求解一波，使用两层for循环进行遍历字符串，外层记录子串左边界，内层记录子串右边界，通过一个函数进行判断该子串是否是回文，判断方式是从两边界向中间夹逼，只要左边不等于右边便返回false，退出循环返回true，即便当前子串是回文，还需要进行长度的判断，将当前长度和之前记录的长度进行比较，只有比之前的长才重新记录新的左边界以及长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">       int begin = 0;</span><br><span class="line">       int maxLen = 1;</span><br><span class="line">       for(int i = 0;i&lt;s.length()-1;i++)&#123;</span><br><span class="line">           for(int j = i+1;j&lt;s.length();j++)&#123;</span><br><span class="line">               if(isValidString(s,i,j)&amp;&amp;(j-i+1)&gt;maxLen)&#123;</span><br><span class="line">                   begin = i;</span><br><span class="line">                   maxLen = j-i+1;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if(maxLen==s.length()) return s;</span><br><span class="line">       &#125;</span><br><span class="line">       return s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isValidString(String s,int left,int right)&#123;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            if(s.charAt(left)!=s.charAt(right))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>暴力求解的时间复杂度太高，所以想到通过空间换时间，使用动态规划算法，那么状态转移方程是什么呢，仔细思考，如果当前子串是回文的话，那么去掉首和尾肯定也是回文，据此建立了前后两步的依赖关系，通过一个二维数组的表进行状态记录，行是左边界，列是右边界，先按照列来填表，因为dp[i][j]会参考dp[i+1][j-1]即左下角的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">        if(s.length()&lt;2) return s;</span><br><span class="line">       int begin = 0;</span><br><span class="line">       int maxLen = 1;</span><br><span class="line">       boolean[][] dp = new boolean[s.length()][s.length()];</span><br><span class="line">        for(int i = 0;i&lt;s.length();i++)&#123;</span><br><span class="line">            dp[i][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 1;j&lt;s.length();j++)&#123;</span><br><span class="line">            for(int i = 0;i&lt;j;i++)&#123;</span><br><span class="line">                if(s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(j-i&lt;3)&#123;</span><br><span class="line">                    //如果当前子串的长度小于3，肯定就是回文</span><br><span class="line">                        dp[i][j]=true;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        dp[i][j] = dp[i+1][j-1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               if(dp[i][j]&amp;&amp;(j-i+1)&gt;maxLen)&#123;</span><br><span class="line">                   begin = i;</span><br><span class="line">                   maxLen = j-i+1;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substring(begin,begin+maxLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>这道题使用动态规划的话，关键点在于想到去掉首尾剩余的还是回文，然后就是填表，通过左边界和右边界确定二维表的行和列</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>机器人深度优先可到格子数</title>
    <url>/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%8F%AF%E5%88%B0%E6%A0%BC%E5%AD%90%E6%95%B0.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>地上有一个m行n列的方格，从坐标<code> [0,0]</code> 到坐标<code> [m-1,n-1]</code> 。一个机器人从坐标<code> [0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><p>在看到这道题目时，首先想到的是深度优先遍历，使用栈来保存路径，走到末端便回退栈，有点类似迷宫问题，但让我头疼的是迷宫问题的边界是标识的，并且在此你还需要进行判断下一步能不能走通，如果不行还需改变方向，四个方向都不通只能回退栈，感觉将问题变得复杂了，下面参考力扣官网解答，使用递归实现深度优先遍历，弄清楚子问题是什么，从当前点出发，可以划出4个方向的路径，那么下一个点同样可以划出4个方向，显然是递归的，对四个方向进行递归，当然得控制好递归结束的条件，同时遍历过的点需要标记不能再遍历，下面上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int getSum(int num)&#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(num!=0)&#123;</span><br><span class="line">            sum+=num%10;</span><br><span class="line">            num/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;    </span><br><span class="line">    public int movingCount(int m, int n, int k) &#123;</span><br><span class="line">       boolean[][] visited = new boolean[m][n];</span><br><span class="line">       return dfsSolver(0,0,m,n,visited,k);</span><br><span class="line">    &#125;</span><br><span class="line">    int dfsSolver(int i,int j,int m,int n,boolean[][] visited,int k)&#123;</span><br><span class="line">            if(i&lt;0||j&lt;0||i&gt;=m||j&gt;=n||visited[i][j]||getSum(i)+getSum(j)&gt;k) return 0;</span><br><span class="line">            visited[i][j] = true;</span><br><span class="line">            return 1+dfsSolver(i+1,j,m,n,visited,k)+dfsSolver(i,j-1,m,n,visited,k)+dfsSolver(i-1,j,m,n,visited,k)+dfsSolver(i,j+1,m,n,visited,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于dfsSolver方法的返回值上，肯定至少返回1，剩下的便是子问题是否能走通</p>
</blockquote>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>对于深度优先搜索首先应当考虑递归算法，想清楚子问题是什么，如何进行递归调用，以及递归结束的条件</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>服务的基本使用</title>
    <url>/%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天了解了Android四大组件之一的Service-服务，它可以在后台长时间运行操作，处理网络事物以及耗时的IO任务等，包括前台和后台两种，前台主要创建通知提示用户，当你打开允许应用后台运行的权限后，清理掉应用仍然可以执行后台任务，下面分别进行介绍</p>
</blockquote>
<h3 id="二-后台服务"><a href="#二-后台服务" class="headerlink" title="二.后台服务"></a>二.后台服务</h3><ol>
<li><p>首先创建服务</p>
<p>推荐直接创建一个服务类，而不要创建一个类继承自Service，前者可以在Manifests中进行注册</p>
</li>
<li><p>重写生命周期方法</p>
<p>Service和Activity有相似的生命周期</p>
<p>onCreate：首次被创建时触发</p>
<p>onStartCommand：启动服务时触发(内部包含onStart方法)</p>
<p>onDestroy：销毁时触发</p>
<p>onBind：绑定服务时触发</p>
<p>onUnbind：解除绑定</p>
<p>onRebind：重新绑定</p>
<blockquote>
<p>以上必须重写的是<code>onBind()</code>方法，多个Activity可以同时绑定同一个服务，达到共享资源，实现服务器-客户端模式</p>
</blockquote>
</li>
</ol>
<p><strong>通过Intent来启动一个服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent(this,MyService::class.java).also &#123;</span><br><span class="line">            startService(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务的取消也需要通过Intent</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent(this,MyService::class.java).also &#123;</span><br><span class="line">             stopService(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们没有手动停止服务，退出应用进入后台时，服务仍然可以进行，交给系统来管理，当内存比较吃紧的时候会终止服务</p>
</blockquote>
<ol start="3">
<li><p> 为了能够使用LiveData观察以及搭配使用Coroutine，可以使用<code>LifecycleService</code></p>
</li>
<li><p>绑定服务：用于在Activity中反向取出Service中的数据</p>
<p>通过<code>bindService()</code>来绑定服务，需要传入三个参数</p>
<p>Intent、ServiceConnection(接口)、Int</p>
<p>为了能够返回Service的引用，需要创建一个内部类保存当前Service的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyService : LifecycleService() &#123;</span><br><span class="line">    val numBerLiveData = MutableLiveData(0)</span><br><span class="line">    override fun onCreate() &#123;</span><br><span class="line">        super.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line">    inner class MyBinder:Binder()&#123;</span><br><span class="line">        val service = this@MyService</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onBind(intent: Intent): IBinder &#123;</span><br><span class="line">        super.onBind(intent)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                delay(1000)</span><br><span class="line">                numBerLiveData.value = numBerLiveData.value?.plus(1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return MyBinder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">val bindServiceIntent = Intent(this,MyService::class.java)</span><br><span class="line">val serviceConn = object :ServiceConnection&#123;</span><br><span class="line">            override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123;</span><br><span class="line">                //绑定成功之后，通过第二个参数可以获取到Service的一个引用</span><br><span class="line">                (p1 as MyService.MyBinder).service.numBerLiveData.observe(this@MainActivity)&#123;</span><br><span class="line">                    showText.text = it.toString()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onServiceDisconnected(p0: ComponentName?) &#123;</span><br><span class="line">                //取消绑定时</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">bindService(bindServiceIntent,serviceConn,Context.BIND_AUTO_CREATE)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在MainActivity可以观察MyService内部的LiveData，并刷新界面，如果另一个Activity也绑定该服务，则他们共享数据</p>
</blockquote>
</li>
</ol>
<h3 id="三-前台服务"><a href="#三-前台服务" class="headerlink" title="三.前台服务"></a>三.前台服务</h3><p>上面提到的后台服务对于用户来说是没有任何提示的，并且很容易被系统杀死，前台服务主要使用通过创建通知与用户交互，在Android 8.0以后创建通知需要一下三个步骤</p>
<ol>
<li><p>创建通知渠道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private fun createNotificationChannel() &#123;</span><br><span class="line">       if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">           val name = &quot;前台通知Test&quot;</span><br><span class="line">           val importance = NotificationManager.IMPORTANCE_HIGH</span><br><span class="line">           val channel = NotificationChannel(CHANNEL_ID, name, importance)</span><br><span class="line">           val notificationManager: NotificationManager =</span><br><span class="line">               getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">           notificationManager.createNotificationChannel(channel)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建通知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val notification = NotificationCompat.Builder(this, CHANNEL_ID)</span><br><span class="line">           .setContentTitle(&quot;Hello&quot;)</span><br><span class="line">           .setContentText(&quot;今日第一次测试&quot;)</span><br><span class="line">           .setSmallIcon(R.drawable.ic_launcher_foreground)</span><br><span class="line">           .build()</span><br></pre></td></tr></table></figure></li>
<li><p>启动前台服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startForeground(1,notification)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意启动前台服务函数的第一个参数不能是0，否则不会弹出通知，另外一个问题是，在模拟器上运行即使是清理了App，前台服务依旧存在，但在真机上不行，因为Android厂商不允许这些应用在后台运行以及自启动，除非手动打开权限或者将app加入白名单</p>
</blockquote>
</li>
</ol>
<p><strong>按照常理来说，当我们点击通知后可以跳转到app内，只需要在创建通知的时候设置Intent</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val pendingIntent = PendingIntent.getActivity(</span><br><span class="line">            this,</span><br><span class="line">            0,</span><br><span class="line">            Intent(this,MainActivity::class.java),</span><br><span class="line">            0</span><br><span class="line">        )</span><br><span class="line">setContentIntent(pendingIntent)        </span><br></pre></td></tr></table></figure>

<p><strong>整体效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E6%9D%82%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%9C%8D%E5%8A%A1show.gif" style="zoom:40%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>服务作为四大组件之一，但不是每个项目都必须的，因为耗时任务可以放在Coroutine中执行，目前了解怎么使用即可</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>Android常用琐碎知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>如果一个事物有多个维度的属性时，多重继承是一种实现思路，但是代价很大，比如两个维度，一个维度有三种选择，那么继承的方式就有9种，本文即将介绍的桥接模式是从分离的角度来解决这种困境，想让该事物同时拥有上述的两个维度，只需要组合这两个维度即可，下面通过具体的场景来展示</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>采摘水果时会根据水果的不同而选择不同的采摘带，从容量上来分有大中小三类，从材质上来分有纸质、塑料、麻袋三种，根据面向接口编程的思想，会将容量和材质各抽象成一个接口，那具体的实现就有9种，图示如下</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%B4%E5%BA%A6.png" style="zoom:50%;" />

<p>使用桥接模式将二者进行组合达到分离的效果</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class BagAbstraction &#123;</span><br><span class="line">    protected var mMaterial: Material? = null</span><br><span class="line">    </span><br><span class="line">    fun setMaterial(material: Material) &#123;</span><br><span class="line">        this.mMaterial = material</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract fun pick()</span><br><span class="line">&#125;</span><br><span class="line">interface Material &#123;</span><br><span class="line">    fun draw()</span><br><span class="line">&#125;</span><br><span class="line">class BigBag: BagAbstraction() &#123;</span><br><span class="line">    override fun pick() &#123;</span><br><span class="line">        mMaterial?.draw()</span><br><span class="line">        print(&quot;采摘了一大袋&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Paper:Material &#123;</span><br><span class="line">    override fun draw() &#123;</span><br><span class="line">        print(&quot;用纸袋&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">val bag = BigBag()</span><br><span class="line">bag.setMaterial(Paper())</span><br><span class="line">bag.pick()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>对比一下适配器模式，同样是组合，但区别很大，适配器的目的是转换，也就是先有两端再有组合(适配器)，而桥接模式先组合，后有两端，进行赋值。桥接的目的是分离，适配的目的是组合</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>求解多个字符串的最长公共前缀</title>
    <url>/%E6%B1%82%E8%A7%A3%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><p>看到这道题时，小编没有什么好的思路，最容易想到的就是暴力求解，此前你得熟悉什么是前缀，利用这一特性才能进行求解，显然暴力求解不现实，多个字符串，不确定数量，时间复杂度太高，代码也繁琐，下面介绍一位大佬提供的思路</p>
<blockquote>
<p>我们首先应该思考最终的解是怎样的，如果有公共最长前缀，那么肯定是最短的，随便取出一个字符串作为比较标准，通过增强for循环进行遍历字符串数组，内层通过一个while循环进行控制，只要这个标准字符串不是当前字符串的前缀，那么标准字符串的长度-1，直到满足前缀，那么如果不存在公共前缀，标准字符串最终肯定会变成空串，这时就要return，仔细想想，确实是这个道理，只要存在公共最长前缀，那么它肯定经过所有字符串削减后最短的那个公共前缀，满足了当前字符串，但它可能不是最长的，所以还得继续遍历削减</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if(strs==null||strs.length==0) return &quot;&quot;;</span><br><span class="line">       String s = strs[0];</span><br><span class="line">       for(String str:strs)&#123;</span><br><span class="line">           if(s==&quot;&quot;) return &quot;&quot;;</span><br><span class="line">           while(!str.startsWith(s))&#123;</span><br><span class="line">               s = s.substring(0,s.length()-1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>这道题的思路确实之前没遇到过，没见过的，第一想法就是暴力，很多时候想想解的情况，说不定可以巧解</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/%E6%A1%B6%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面介绍了桶思想中使用较多的计数和基数排序，下面本文介绍桶排序，其实桶排序用的很少，在特定情况下用的最多的还是计数和基数排序，因此桶排序仅做了解即可</p>
</blockquote>
<h3 id="二-桶排序原理以及代码实现"><a href="#二-桶排序原理以及代码实现" class="headerlink" title="二.桶排序原理以及代码实现"></a>二.桶排序原理以及代码实现</h3><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181130/9095a2947d144f4b960369dbc1d259d7.gif"></p>
<blockquote>
<p>原理分析：首先确定找出数组中的最大值和最小值，然后确定桶的大小即间距，通过最大最小值的差值除以间距的结果+1便是桶的数量，由于结果是整数，所以至少保证有一个桶，然后依次对每个桶进行排序即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void bucketSort(int[] arr)&#123;</span><br><span class="line">        int min=arr[0],max=arr[0];</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            min = Math.min(arr[i],min);</span><br><span class="line">            max = Math.max(arr[i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        int bucketNum = (max-min)/arr.length + 1;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        for(int i= 0;i&lt; bucketNum;i++)&#123;</span><br><span class="line">            bucket.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int elem:arr)&#123;</span><br><span class="line">            int index = (elem-min)/arr.length;</span><br><span class="line">            bucket.get(index).add(elem);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            Collections.sort(bucket.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        int k=0;</span><br><span class="line">        for (ArrayList&lt;Integer&gt; tempList:bucket) &#123;</span><br><span class="line">            for (int elem:tempList) &#123;</span><br><span class="line">                arr[k++] = elem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n+k)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口求解无重复字符的最长子串</title>
    <url>/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E8%A7%A3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>看到这道题目时，小编的想法是通过一个<code>LinkedHashMap</code>来存储不重复的字符，注：<code>LinkedHashMap</code>会按照添加元素的顺序进行存储，经过一次遍历后便将所有不重复的字符添加到<code>Map</code>中，key是字符，value是其对应的下标，然后通过遍历<code>Map</code>对前后两个<code>value</code>值的差值为1进行计数，如果发生断链，就重新计数，多次断链便取最大值，该想法可以满足部分例子，但如果中间出现连续的重复字符便没有用了，因为对于连续重复的字符不知该记录最前面还是最后面的下标，下面介绍力扣官方解题思路：<strong>滑动窗口</strong></p>
</blockquote>
<p>滑动窗口的意思是通过一个左指针进行记录每次不重复子串的第一个字符的位置，此处通过<code>HashMap</code>进行存储字符以及其对应的下标，无论重复与否，每次都会将本次的字符及其下标添加到<code>HashMap</code>中，key相同的话即覆盖，如果发生key值重复，就改变左指针，由于可能之前出现过一个新的左指针，所以需要通过一个<code>max</code>函数进行取最大值，每轮遍历都需保存当前子串的最大长度，下面上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">       if(s.length()==0) return 0;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = new HashMap();</span><br><span class="line">        int max = 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        for(int i = 0; i&lt; s.length();i++)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i))+1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>显然时间复杂度比暴力求解低太多，至于left指针的取法可以结合具体例子进行理解，该算法只能说很巧妙，通过一个left指针移动到下一个子串，所以称为滑动窗口</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>策略模式的基本思想就是依赖注入，依赖接口，注入具体的实现类，通过选择具体的策略类，来执行不同算法分支，核心是通过注入对象，改变行为</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><p>在购物车结算页面会有相应的优惠活动供选择，不同的优惠方式就是不同的策略</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Discount &#123;</span><br><span class="line">    public int calculate(int money);</span><br><span class="line">&#125;</span><br><span class="line">public class FullDiscount implements Discount &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int calculate(int money) &#123;</span><br><span class="line">        if (money &gt; 200)&#123;</span><br><span class="line">            System.out.println(&quot;优惠减免20元&quot;);</span><br><span class="line">            return money - 20;</span><br><span class="line">        &#125;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CartShopping extends ShoppingCart&#123;</span><br><span class="line">    </span><br><span class="line">    private Discount discount;</span><br><span class="line">    </span><br><span class="line">    public void setDiscount(Discount discount) &#123;</span><br><span class="line">        this.discount = discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用处</span><br><span class="line">ShoppingCart cart = new OtherPayShopping(products);</span><br><span class="line">cart.setDiscount(new NewerDiscount());</span><br></pre></td></tr></table></figure>

<p>简单小结：</p>
<ol>
<li>将每一种优惠策略，单独成一个组件对象，独立出来</li>
<li>使用方通过选择不同的组件，达到不同的行为</li>
</ol>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>系统高级UI之RecyclerView</title>
    <url>/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI%E4%B9%8BRecyclerView.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>当我们需要需要一个滚动列表来显示内容时，首选<strong>RecyclerView</strong>，是目前滚动列表中功能最强大的，下面以一个Demo的效果来进行展示</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/recyclershow.gif" style="zoom: 50%;" />

<h3 id="二-使用RecyclerView的具体步骤"><a href="#二-使用RecyclerView的具体步骤" class="headerlink" title="二.使用RecyclerView的具体步骤"></a>二.使用RecyclerView的具体步骤</h3><blockquote>
<p>系统已经对RecyclerView进行了解耦，即将其分为几大板块(组成部分)</p>
</blockquote>
<ul>
<li>adapter：完成数据的显示 RecyclerView.Adapter</li>
<li>layoutManager:：布局样式(线性 网格 瀑布流 滚动方向)</li>
<li>itemDecoration：每一个item的装饰器(通常用来设置间距)</li>
<li>xxx_layout.xml：每一个item显示的样子模板(即每一个子View)</li>
<li>给每个item中的一部分设置监听事件</li>
</ul>
<blockquote>
<p>创建一个RecyclerView只是搭建了一个框架，内容还需填充以上所列，此处强调一下<strong>adapter</strong>适配器，这就好比电源适配器，将220v的电源转换成手机或者电脑可以使用的电压，类似的，一个<strong>RecyclerView</strong>在不同的场景下可以显示不同的视图，全显示文本，或者全是图片，亦或是图片加文本，将这些内容传给<strong>RecyclerView</strong>便是<strong>adapter</strong>适配器的功能</p>
</blockquote>
<p><strong>下面是具体使用步骤：</strong></p>
<ol>
<li><p>创建RecyclerView-&gt;xml里面配置</p>
</li>
<li><p>代码中配置属性</p>
<p>① 确定布局样式-&gt;layoutManager</p>
<p>② 确定数据源，此处会在Demo中强调</p>
</li>
<li><p>定义一个类实现RecyclerView.Adapter接口</p>
<p>RecyclerView就是通过接口里面的方法来访问数据的</p>
<p>① 创建一个类继承于RecyclerView.ViewHolder，以便重复利用，提高运行效率</p>
<p>② 重写adapter里面的抽象方法</p>
<p>​     <code>getItemCount()</code>：确定元素个数</p>
<p>​     <code>onCreateViewHolder()</code>：确定每⼀个item的视图(xml中配置，并通过LayoutInflater解析得到View)</p>
<p>​     <code>onBindViewHolder()</code>：将数据与View进行绑定</p>
<p>③ 接收外部传递过来的数据源 -&gt;构造函数(属性)</p>
</li>
<li><p>设置item装饰器-&gt;<code>addItemDecoration()</code></p>
<p>① 使用系统提供的实现类，如<code>DividerItemDecoration</code>添加分割线</p>
<p>② ⾃⼰创建⼀个类继承于<code>ItemDecoration</code> 重写onDraw或者 onDrawOver、getItemOffset</p>
</li>
<li><p>如果想让每个Item分屏显示，需要<code>LinearSnapHelper</code>类通过<code>attachToRecyclerView()</code>关联<strong>RecyclerView</strong></p>
</li>
<li><p>CardView可以用来设置圆角，感觉效果还不错，它是一个容器</p>
</li>
</ol>
<blockquote>
<p>特别想强调一下<code>ViewHolder</code>的使用，<strong>adapter</strong>管理的数据就是<code>ViewHolder</code>，<strong>RecyclerView</strong>将<code>ViewHolder</code>封装在内部，就是为了，不用每次都去加载视图，使用过的<code>ViewHolder</code>会被存储起来，下一次使用只需更改View里面的数据即可，大大提高了效率</p>
</blockquote>
<h3 id="三-浏览图片Demo"><a href="#三-浏览图片Demo" class="headerlink" title="三.浏览图片Demo"></a>三.浏览图片Demo</h3><blockquote>
<p>下面通过一个浏览图片的小Demo来巩固对<strong>RecyclerView</strong>的使用，效果展示已在最顶部展示，很多app都采取了这样的浏览模式，还是蛮有意义的</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7UI/RecyclerView%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<blockquote>
<p>值得一提的是该Demo获取数据的方式进行了架构，<code>Factory</code>接口作为中转站(生成数据)，但具体获取数据的方式是不确定的，只有通过它的实现类来确定，此处是<code>LocalUtil</code>即本地加载数据，<code>Repository</code>使用两个变量保存数据是为了进行数据的同步，一个<strong>私有</strong>，一个<strong>公开</strong>，私有的会根据需求进行数据的删除和增加，公有的便提供给每个界面使用</p>
</blockquote>
<blockquote>
<p>给Item添加监听事件，由于每个视图都有子控件，所以我们通常会给具体的子控件设置点击事件，<strong>RecyclerView</strong>没有单独给每个Item设置监听事件的方法</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>要想熟练使用<strong>RecyclerView</strong>就必须熟悉它由几大部分组成，当必需的几个部分添加完毕后，便可正常显示，另外需要注意的是，数据源从何而来，采取合理的架构方式，提高复用性，以及数据的封装</p>
</blockquote>
<p><strong>代码链接</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/recycler-view-demo/">RecyclerView的小Demo</a></p>
]]></content>
      <categories>
        <category>系统控件</category>
      </categories>
      <tags>
        <tag>系统高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>简单工厂模式不属于23中设计模式，比较基础，是为了后续做扩展方才引入</p>
</blockquote>
<h3 id="二-简单工厂模式场景模拟"><a href="#二-简单工厂模式场景模拟" class="headerlink" title="二.简单工厂模式场景模拟"></a>二.简单工厂模式场景模拟</h3><blockquote>
<p>这里通过一个小例子来说明简单工厂模式，果园摘水果问题</p>
</blockquote>
<ol>
<li><p>原始方式</p>
<p>自己想吃水果，直接去果园亲自摘，简单说就是自己new一个水果实例</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%95%A3%E5%85%BB%E6%96%B9%E5%BC%8F.png"></p>
<p>这种方式有明显的弊端：</p>
<ol>
<li>使用者需要自己new一个实例</li>
<li>使用者需要自己维护new出来的实例</li>
<li>使用者需要了解参数的具体意义，比如这里的采摘员，如果采摘员是常量，我们还得去了解有哪些，还有价格</li>
</ol>
<p>综上，原始方式对于使用者来说不友好</p>
</li>
<li><p>简单工厂生产方式</p>
<p>通过一个工厂类统一管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object SimpleFruitFactory &#123;</span><br><span class="line">    const val APPLE = 1</span><br><span class="line">    const val BANANA = 2</span><br><span class="line">    const val ORANGE = 3</span><br><span class="line"></span><br><span class="line">    fun getFruit(fruitType: Int) = when (fruitType) &#123;</span><br><span class="line">        APPLE -&gt; Apple()</span><br><span class="line">        BANANA -&gt; Banana(&quot;采摘员一号&quot;, 100)</span><br><span class="line">        ORANGE -&gt; Orange(50)</span><br><span class="line">        else -&gt; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun getApple() = Apple()</span><br><span class="line"></span><br><span class="line">    fun getBanana() = Banana(&quot;采摘员一号&quot;, 100)</span><br><span class="line"></span><br><span class="line">    fun getOrange() = Orange(50)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E7%94%9F%E4%BA%A7.png"></p>
<p>通过工厂的方式生产水果，这里提供了两种方式，一是根据type来获取，二是直接获取</p>
<p>优势：</p>
<ol>
<li>将对象的创建和使用分开</li>
<li>将生产过程集中后，易于管理(增删改)</li>
<li>当水果类有变动时，用户不需要手动修改代码</li>
</ol>
</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>简单工厂模式作为工厂模式的入门，理解这么做的好处即可，说白了就是将对象的产生集中管理</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>组合模式是把一组相似的对象当做一个单一的对象，目的是减少数据类型</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>水果店在寄出水果时，发现地址的层级很深，并且变化很多，如下图</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98.png" style="zoom:50%;" />

<p>为了解决这个问题，逐级分析每级之间的相似性</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E5%9C%BA%E6%99%AF%E6%A8%A1%E5%9E%8B%E5%8C%96.png" style="zoom:50%;" />

<p>每一级就是一个Node节点，该节点还可以包括多个Node，即下一级</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" style="zoom:50%;" />

<p>这里的ComponentNode指代具体的子类实现，里面除了add方法，还可以扩展其他方法，这里其实用不到LeafNode类型，因为叶子结点也就是最后一级没有什么特殊的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class Node(open val name: String) &#123;</span><br><span class="line">     abstract fun getChildren(): List&lt;Node&gt;</span><br><span class="line">&#125;</span><br><span class="line">class DistrictNode(override val name: String): Node(name) &#123;</span><br><span class="line">    private val children = mutableListOf&lt;Node&gt;()</span><br><span class="line"></span><br><span class="line">    override fun getChildren(): List&lt;Node&gt; &#123;</span><br><span class="line">        return children</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun add(node: Node) &#123;</span><br><span class="line">        children.add(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LeafNode(override val name: String): Node(name) &#123;</span><br><span class="line">    override fun getChildren(): List&lt;Node&gt; &#123;</span><br><span class="line">        return listOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> 		val root = DistrictNode(&quot;根&quot;)</span><br><span class="line">    //一级节点</span><br><span class="line">    root.add(DistrictNode(&quot;上海&quot;))</span><br><span class="line">    root.add(DistrictNode(&quot;天津&quot;))</span><br><span class="line">    val districtNode = DistrictNode(&quot;北京&quot;).also &#123; root.add(it) &#125;</span><br><span class="line"></span><br><span class="line">    //二级节点</span><br><span class="line">    val districtNode2 = DistrictNode(&quot;海淀区&quot;).also &#123; districtNode.add(it) &#125;</span><br><span class="line">    districtNode.add(DistrictNode(&quot;朝阳区&quot;))</span><br><span class="line">    districtNode.add(DistrictNode(&quot;本城区&quot;))</span><br><span class="line">    //三级节点</span><br><span class="line">    districtNode2.add(DistrictNode(&quot;三里屯&quot;))</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>组合模式的运用场景还挺像二叉树的，对于这种树状结构，如果每一层有相似性，即可使用组合模式</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>网络开源库-Glide</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Glide.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天将介绍一个用于加载图片的网络开源库Glide，如果你还在使用请求网络，将返回的IO流通过BitmapFactory合成Bitmap的方式加载图片的话，小编强烈建议使用Glide，一行代码解决问题，相当简洁好用</p>
</blockquote>
<p><strong>下面详细列出Glide的优势</strong></p>
<ol>
<li>使用简单，上手特别快</li>
<li>可配置度高，自适应程度高</li>
<li>支持常见的图片格式 jpg png gif webp</li>
<li>支持多种数据源：网络、本地、资源、Assets等</li>
<li>高效率缓存策略：支持Memory和Disk图片缓存，默认Bitmap格式采用RGB_565内存使用至少减少一半</li>
<li>生命周期集成：根据Activity/Fragment生命周期自动管理请求</li>
<li>高效处理Bitmap：使用Bitmap Pool让Bitmap复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力</li>
</ol>
<p>添加好依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com.github.bumptech.glide:glide:4.11.0&#x27;</span><br></pre></td></tr></table></figure>

<p>由于下面涉及到手机内存文件的读取，在Android 6.0以后需要动态申请权限，所以在加载内存图片之前需要调用一下方法申请权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun applyForFileReadJurisdction()&#123;</span><br><span class="line">      if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">          val REQUEST_CODE_CONTACT = 101</span><br><span class="line">          val permissions = arrayOf&lt;String&gt;(</span><br><span class="line">              Manifest.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">          )</span><br><span class="line">          //验证是否许可权限</span><br><span class="line">          for (str in permissions) &#123;</span><br><span class="line">              if (this.checkSelfPermission(str) !== PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                  //申请权限</span><br><span class="line">                  this.requestPermissions(permissions, REQUEST_CODE_CONTACT)</span><br><span class="line">                  return</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次运行可能看不到图片加载，因为代码在你申请成功之前已经执行完毕了，所以第二次进入就可以看到图片被加载出来，此外还需要在清单文件中添加权限，在Okhttp篇已经提及</p>
</blockquote>
<h3 id="二-Glide的具体使用加载图片"><a href="#二-Glide的具体使用加载图片" class="headerlink" title="二.Glide的具体使用加载图片"></a>二.Glide的具体使用加载图片</h3><ol>
<li><p>加载网络图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://192.168.0.103/iamge4.jpg&quot;)</span><br><span class="line">     .into(glide_image1)</span><br></pre></td></tr></table></figure></li>
<li><p>加载Drawable资源图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">    .load(R.drawable.image1)</span><br><span class="line">    .into(glide_image2)</span><br></pre></td></tr></table></figure></li>
<li><p>加载手机SD卡图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val imgPath = Environment.getExternalStorageDirectory().path+&quot;/a/retrofitDownload.jpg&quot;</span><br><span class="line">val file = File(imgPath)</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(Uri.fromFile(file))</span><br><span class="line">     .into(glide_image3)</span><br></pre></td></tr></table></figure></li>
<li><p>加载网络gif</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://192.168.0.103/internet.gif&quot;)</span><br><span class="line">     .placeholder(R.drawable.ic_launcher_foreground)</span><br><span class="line">     .into(glide_image4)</span><br></pre></td></tr></table></figure></li>
<li><p>加载Drawable资源gif图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(R.drawable.drawable)</span><br><span class="line">     .into(glide_image5)</span><br></pre></td></tr></table></figure></li>
<li><p>加载手机SD卡gif图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val gifPath = Environment.getExternalStorageDirectory().path+&quot;/a/SD卡.gif&quot;</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(gifPath)</span><br><span class="line">     .into(glide_image6)</span><br></pre></td></tr></table></figure></li>
<li><p>加载本地视频</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val videoPath = Environment.getExternalStorageDirectory().path+&quot;/a/Test.mp4&quot;</span><br><span class="line">val videoFile = File(videoPath)</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(videoFile)</span><br><span class="line">     .into(glide_image7)</span><br></pre></td></tr></table></figure>

<p><strong>加载本地视频只能加载首页</strong></p>
</li>
<li><p>设置缩略图比例，然后先加载，再加载原图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val localThumbnail = Environment.getExternalStorageDirectory().path+&quot;/a/本地缩略图.png&quot;</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(localThumbnail)</span><br><span class="line">     .thumbnail(0.1f)</span><br><span class="line">     .centerCrop()</span><br><span class="line">     .into(glide_image8)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>thumbnail设置缩略图占原图的比例，centerCrop从中心对齐</p>
</blockquote>
</li>
<li><p>先创建一个缩略图对象，然后，先加载缩略图，再加载原图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val thumbnailRequest = Glide.with(this).load(&quot;http://192.168.0.103/girl1.jpg&quot;)</span><br><span class="line">Glide.with(this)</span><br><span class="line">     .load(&quot;http://192.168.0.103/girl3.jpg&quot;)</span><br><span class="line">     .thumbnail(thumbnailRequest)</span><br><span class="line">     .centerCrop()</span><br><span class="line">     .into(glide_image9)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先创建显示的缩略图不一定是最终显示的图片，也是通过thumbnail来设置添加</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>观察以上代码，发现Glide使用是实在简洁，通过一行链式代码解决，并且load方法传入的参数也多种多样</p>
</blockquote>
<h3 id="三-添加图形变换"><a href="#三-添加图形变换" class="headerlink" title="三.添加图形变换"></a>三.添加图形变换</h3><p>如果你要对图片做一些效果，比如模糊、截取部分等等，需要使用下面的图片转换库搭配Glide加载图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;jp.wasabeef:glide-transformations:4.3.0&#x27;</span><br></pre></td></tr></table></figure>

<p>在此小编简单演示几个</p>
<ol>
<li><p>使用圆角</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">            .load(&quot;http://192.168.0.103/iamge4.jpg&quot;)</span><br><span class="line">            .apply(RequestOptions.bitmapTransform(RoundedCornersTransformation(500, 0, RoundedCornersTransformation.CornerType.ALL)))</span><br><span class="line">            .into(glide_image1)</span><br></pre></td></tr></table></figure>

<p>通过apply方法，RequestOptions.bitmapTransform()是不变的，变的是里面的参数，参数一是设置半径，参数二设置与四周的间距，参数三是设置具体的样式</p>
</li>
<li><p>使用模糊</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apply(RequestOptions.bitmapTransform(BlurTransformation(25, 3)))</span><br></pre></td></tr></table></figure>

<p>两个参数共同调控模糊度，都是值越大越模糊</p>
</li>
<li><p>同时使用多个效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val multi = MultiTransformation(</span><br><span class="line">           BlurTransformation(25),</span><br><span class="line">           RoundedCornersTransformation(500, 0, RoundedCornersTransformation.CornerType.ALL)</span><br><span class="line">       )</span><br><span class="line">apply(RequestOptions.bitmapTransform(multi))       </span><br></pre></td></tr></table></figure>

<p>如果比较感兴趣的话可以去百度其他博客，小编在此仅做引入</p>
<p><a href="https://github.com/wasabeef/glide-transformations">官网链接</a></p>
<p><strong>集体效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Glide%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif" style="zoom:45%;" /></li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>经过上面的过程，相信Glide上手真的很快，使用方便，是项目中加载图片的不二之选</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/glide_">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>网络开源库-Okhttp</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Okhttp.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><p>当Android进入网络阶段时，我们首选考虑的是使用什么工具去请求网络以及实现数据回调，记得在Java网络阶段时使用的是<code>HttpURLConnection</code>，但使用它的步骤特别多，繁琐在于使用流包装发送数据以及接收数据，使用起来很不愉悦，今天便开始了学习Android中常用的网络开源库系列，更加高效地进行网络请求，本文先从<code>Okhttp</code>入手</p>
<h3 id="二-Okhttp简介"><a href="#二-Okhttp简介" class="headerlink" title="二.Okhttp简介"></a>二.Okhttp简介</h3><p>Okhttp是一个高效的HTTP客户端，具有一下特性：</p>
<ol>
<li>支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接</li>
<li>连接池减少请求延时</li>
<li>透明的GZIP压缩减少响应数据的大小</li>
<li>缓存响应内容，避免一些完全重复的请求</li>
</ol>
<p>话不多说，下面通过具体例子来展示Okhttp的实际应用</p>
<h3 id="三-准备工作"><a href="#三-准备工作" class="headerlink" title="三.准备工作"></a>三.准备工作</h3><p>本篇文章是建立在app与本地服务器之间的交互上进行阐述的，我搭建的是<strong>Apache</strong>服务器，后台应用使用的是<strong>php</strong>语言进行处理网络请求，由于初次接触Android端请求网络，所以想强调一下<strong>下载文件只需要知道文件链接即可，而上传文件是一定要通过php等后端程序来进行处理的，当然Tomcat是通过具体的方法来处理</strong></p>
<p>当本地服务器(Apache/Tomcat)搭建好了后，最关心的问题便是如何使用手机通过链接访问电脑上的文件，需经历以下步骤：</p>
<ol>
<li><p>通过<strong>win+R、输入cmd</strong>打开终端，再输入<code>ipconfig</code>查看本地服务器的IP地址</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E6%9F%A5%E6%89%BEIP%E5%9C%B0%E5%9D%80.png" style="zoom: 65%;" />

<p>IPv4对应的便是本机的IP，注意：同一台电脑在<strong>手机热点、家庭路由器、校园网</strong>等不同的局域网中，IP地址是不同的，这点很关键，另外记住手机开热点也算一个局域网</p>
</li>
<li><p>查到IP地址后便是提供一个<strong>局域网环境</strong>，可以理解为手机、电脑连上同一个WIFI，很多时候会选择手机开热点</p>
</li>
<li><p>将你电脑的防火墙关掉，否则会访问失败</p>
</li>
<li><p>具体的访问便通过IP地址加上文件路径即可，如<code>http://192.168.0.103/1.jpg</code></p>
</li>
<li><p>Android应用程序还需添加联网的权限，在<code>manifests</code>清单文件中添加<code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></p>
<p>除此之外，由于访问本地服务器都是http，所以还需在application标签中添加<code>android:usesCleartextTraffic=&quot;true&quot;</code></p>
</li>
</ol>
<p>以上工作做好后，便开始真正的网络操作</p>
<h3 id="四-Okhttp使用GET方式实现简单的网络请求"><a href="#四-Okhttp使用GET方式实现简单的网络请求" class="headerlink" title="四.Okhttp使用GET方式实现简单的网络请求"></a>四.Okhttp使用GET方式实现简单的网络请求</h3><blockquote>
<p>Okhttp的网络请求分为同步和异步，使用同步的话需要在子线程中执行请求任务，异步是通过将任务添加到队列中在后台执行，执行完毕后通过回调处理结果</p>
</blockquote>
<ol>
<li><p>同步请求</p>
<p>使用php后端程序返回一个字符串，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;小王&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E5%90%8C%E6%AD%A5Get%E6%96%B9%E5%BC%8F.png" style="zoom:40%;" /></li>
<li><p>异步请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun getAsynchronous()&#123;</span><br><span class="line">        val client = OkHttpClient()</span><br><span class="line">        val request = Request.Builder()</span><br><span class="line">            .url(&quot;http://192.168.0.103/a.php&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        client.newCall(request).enqueue(object :Callback&#123;</span><br><span class="line">            override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">                //请求失败的处理</span><br><span class="line">                Log.v(&quot;cx&quot;,&quot;网络异常，请换5G网！&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                val result = response.body?.string()</span><br><span class="line">                Log.v(&quot;cx&quot;,&quot;结果为：$result&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>此处为了方便就用了线程，实际开发还是得用协程，推荐使用异步请求的方式</p>
</blockquote>
<p>用法总结：</p>
<ol>
<li><p>首先创建一个client用于发起请求</p>
</li>
<li><p>创建一个请求用于设置<strong>url</strong>访问链接</p>
</li>
<li><p>通过<code>newCall()</code>方法发起请求，可选择<code>excute()</code>同步和<code>enqueue(回调的接口)</code>两种方式</p>
</li>
<li><p>使用POST方式还需另外创建一个请求体用于传递参数</p>
</li>
</ol>
<h3 id="五-Okhttp使用POST方式普通请求"><a href="#五-Okhttp使用POST方式普通请求" class="headerlink" title="五.Okhttp使用POST方式普通请求"></a>五.Okhttp使用POST方式普通请求</h3><p>下面使用异步请求的方式展示POST请求，首先上php后端程序代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	//获取用户使用get方式提交的数据</span><br><span class="line">	$name=$_POST[&quot;user_name&quot;];</span><br><span class="line">	$password=$_POST[&quot;user_pwd&quot;];</span><br><span class="line">	//数据库中查询是否有这个用户</span><br><span class="line">	if ($name==&quot;jack&quot;&amp;&amp;$password==&quot;123&quot;) &#123;</span><br><span class="line">		echo &quot;登录成功&quot;;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		echo &quot;用户名或者密码出错&quot;.$name.&quot;&amp;&quot;.$password;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的登录判断的网络请求，Android端提交数据时需要和<strong>字段</strong>一一对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun postData()&#123;</span><br><span class="line">        val client = OkHttpClient()</span><br><span class="line">        val requestBody = FormBody.Builder()</span><br><span class="line">            .add(&quot;user_name&quot;, &quot;jack&quot;)</span><br><span class="line">            .add(&quot;user_pwd&quot;, &quot;123&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        val request = Request.Builder()</span><br><span class="line">                .url(&quot;http://192.168.0.103//login/login.php&quot;)</span><br><span class="line">                .post(requestBody)</span><br><span class="line">                .build()</span><br><span class="line">        client.newCall(request).enqueue(object :Callback&#123;</span><br><span class="line">            override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">                Log.v(&quot;cx&quot;,&quot;网络异常，请稍后再试！&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                val result = response.body?.string()</span><br><span class="line">                Log.v(&quot;cx&quot;, &quot;结果为：$result&quot;)</span><br><span class="line">                //Log-&gt;结果为：登录成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建请求体时通过<code>add()</code>方法添加字段及其对应的值，创建请求体时，默认使用的是<strong>GET</strong>方式，使用post直接传入请求体即可</p>
</blockquote>
<h3 id="六-使用Okhttp实现文件上传和下载准备工作"><a href="#六-使用Okhttp实现文件上传和下载准备工作" class="headerlink" title="六.使用Okhttp实现文件上传和下载准备工作"></a>六.使用Okhttp实现文件上传和下载准备工作</h3><p>以上的网络请求都是较为基础简单的，下面介绍一个APP必不可少的操作：文件上传和下载，涉及两个过程，一是网络请求，二是文件操作，在学习时，个人觉得文件操作稍微难一点，花了好一会儿功夫才弄明白Andriod系统中SD卡的目录如何获取</p>
<p><strong>要对手机内存进行读写操作需要添加以下权限</strong></p>
<ol>
<li>&lt;uses-permission android:name=”android.permission.READ_EXTERNAL_STORAGE” /&gt;<br>&lt;uses-permission android:name=”android.permission.WRITE_EXTERNAL_STORAGE” /&gt;</li>
<li>application标签中添加<br>android:requestLegacyExternalStorage=”true”</li>
</ol>
<p><strong>如何获取到手机内存的目录</strong></p>
<ol>
<li><p>手机内存在Android Studio中称为SD卡，通过下面这行代码获取到手机内存的根目录</p>
<p><code>Environment.getExternalStorageDirectory().absolutePath</code></p>
</li>
<li><p>再在后面拼接上文件所在目录以及文件名即可找到文件</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E6%89%8B%E6%9C%BA%E5%86%85%E5%AD%98%E5%9B%BE.png" style="zoom:33%;" />

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6.png"></p>
</li>
</ol>
<blockquote>
<p>由上图可以知道手机内存的根目录通过代码获取得到是**/storage/emulated/0**</p>
</blockquote>
<p>如果仅仅是读取文件的话还比较麻烦，因为在Android版本6.0以上需要动态申请权限，下面上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">               val REQUEST_CODE_CONTACT = 101</span><br><span class="line">               val permissions = arrayOf&lt;String&gt;(</span><br><span class="line">                   Manifest.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">               )</span><br><span class="line">               //验证是否许可权限</span><br><span class="line">               for (str in permissions) &#123;</span><br><span class="line">                   if (this.checkSelfPermission(str) !== PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                       //申请权限</span><br><span class="line">                       this.requestPermissions(permissions, REQUEST_CODE_CONTACT)</span><br><span class="line">                       return</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       //申请好权限后需要做的事情</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>上面的情况自然是上传文件需要用到，而下载文件只需要指定下载的位置，然后通过<code>createNewFile()</code>创建文件即可</p>
<blockquote>
<p>以上是目前网络操作需要用到的知识点，日后会在写项目的同时不断补充</p>
</blockquote>
<h3 id="七-使用Okhttp上传文件"><a href="#七-使用Okhttp上传文件" class="headerlink" title="七.使用Okhttp上传文件"></a>七.使用Okhttp上传文件</h3><p>依旧先上服务器后端程序php代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  $file=$_FILES[&quot;file&quot;];</span><br><span class="line">  $name=$file[&quot;name&quot;];</span><br><span class="line">  $type=$file[&quot;type&quot;];</span><br><span class="line">  $size=$file[&quot;size&quot;];</span><br><span class="line">  $temp=$file[&quot;tmp_name&quot;];</span><br><span class="line">  //拼接路径</span><br><span class="line">  $path;</span><br><span class="line">  if ($type==&quot;application/pdf&quot;) &#123;</span><br><span class="line">  	$path=&quot;upload/pdf/&quot;;</span><br><span class="line">  &#125;else if ($type==&quot;image/jpg&quot;||$type==&quot;image/jpeg&quot;||$type==&quot;image/png&quot;) &#123;</span><br><span class="line">  	$path=&quot;upload/image/&quot;;</span><br><span class="line">  &#125;else if ($type==&quot;video/mp4&quot;) &#123;</span><br><span class="line">  	$path=&quot;upload/video/&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  //拼接完整路径</span><br><span class="line">  $filePath=$path.$name;</span><br><span class="line">  //判断是否存在</span><br><span class="line">  if (file_exists($filePath)) &#123;</span><br><span class="line">  	echo &quot;文件已存在&quot;;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">  	move_uploaded_file($temp, $filePath);</span><br><span class="line">    echo $filePath;</span><br><span class="line">  	echo &quot;保存文件成功&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>接着上Okhttp操作代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun realUpload()&#123;</span><br><span class="line">        val filePath = Environment.getExternalStorageDirectory().absolutePath+&quot;/a/a.mp4&quot;</span><br><span class="line">        val file = File(filePath)</span><br><span class="line">        Thread&#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">                val REQUEST_CODE_CONTACT = 101</span><br><span class="line">                val permissions = arrayOf&lt;String&gt;(</span><br><span class="line">                    Manifest.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">                )</span><br><span class="line">                //验证是否许可权限</span><br><span class="line">                for (str in permissions) &#123;</span><br><span class="line">                    if (this.checkSelfPermission(str) !== PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                        //申请权限</span><br><span class="line">                        this.requestPermissions(permissions, REQUEST_CODE_CONTACT)</span><br><span class="line">                        return@Thread</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        upLoadFile(file)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">private fun upLoadFile(file: File)&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/upload.php&quot;</span><br><span class="line">        val client = OkHttpClient()</span><br><span class="line">        val requestBody = MultipartBody.Builder()</span><br><span class="line">            .setType(MultipartBody.FORM)</span><br><span class="line">            .addFormDataPart(&quot;file&quot;, &quot;这就是Okhttp吗！.mp4&quot;,file.asRequestBody(&quot;video/mp4&quot;.toMediaTypeOrNull()))</span><br><span class="line">            .build()</span><br><span class="line">        val request = Request.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .post(requestBody)</span><br><span class="line">            .build()</span><br><span class="line">        client.newCall(request).execute()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果展示</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%9F%A5%E7%9C%8B.gif" style="zoom:40%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%A5%E7%9C%8B.gif" style="zoom: 80%;" />

<blockquote>
<p>使用POST方式上传文件唯一不同的是请求体，需要通过<code>setType()</code>标识上传的是媒体类型，另外还需设置媒体类型以及媒体在传输过程中的名字，这个变量名必须和服务器后端程序中的变量名一一对应，否则后端会无法接收，媒体类型是通过<code>MediaType</code>来设置，具体类型有<strong>video/mp4、image/png、image/jpg、image/jpeg、application/pdf</strong>等</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java风格</span><br><span class="line">addFormDataPart(&quot;file&quot;, fileName, RequestBody.create(MediaType.parse(&quot;video/mp4&quot;), file)</span><br><span class="line">Kotlin风格</span><br><span class="line">addFormDataPart(&quot;file&quot;, fileName,file.asRequestBody(&quot;video/mp4&quot;.toMediaTypeOrNull()))</span><br></pre></td></tr></table></figure>

<p><strong>fileName</strong>指的是上传到本地服务器后文件的名字，如果将类型设置为**”application/octet-stream”**，它会上传到本地服务器的根目录</p>
<h3 id="八-使用Okhttp下载文件"><a href="#八-使用Okhttp下载文件" class="headerlink" title="八.使用Okhttp下载文件"></a>八.使用Okhttp下载文件</h3><blockquote>
<p>对于下载文件轻松多了，虽然网络请求变得简单了，但IO流方面在Kotlin中让我有点头疼，既有它方便的地方也有效率低的地方，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private fun downLoadFile()&#123;</span><br><span class="line">      val url = &quot;http://192.168.0.103/这就是Okhttp吗！.mp4&quot;</span><br><span class="line">      val client = OkHttpClient()</span><br><span class="line">      val request = Request.Builder()</span><br><span class="line">          .url(url)</span><br><span class="line">          .build()</span><br><span class="line">      client.newCall(request).enqueue(object :Callback&#123;</span><br><span class="line">          override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">              Log.v(&quot;cx&quot;,&quot;下载失败！&quot;)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">              val content = response.body?.byteStream().use &#123;</span><br><span class="line">                  it?.readBytes()</span><br><span class="line">              &#125;</span><br><span class="line">              val filePath = Environment.getExternalStorageDirectory().absolutePath+&quot;/a/这就是Okhttp吗！.mp4&quot;</span><br><span class="line">              val file = File(filePath)</span><br><span class="line">              if (!file.exists())&#123;</span><br><span class="line">                  file.createNewFile()</span><br><span class="line">              &#125;</span><br><span class="line">              file.outputStream().use &#123;</span><br><span class="line">                  it.write(content)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以发现发起网络请求后，通过<code>response</code>可以带回输入流，本地服务器中的文件写入到内存中，再通过输出流写入到手机内存指定的文件夹，Kotlin是真的太简洁了，通过<code>byteStream()</code>可以直接获取到输入流，然后直接通过它获取到<code>BufferdReader</code>，但是缓冲流无法将流中的数据写入到字节数组中，这就让我很头疼，如果写入到字符串中的话，会导致文件损坏，因此我就使用的是普通的输入输出流，中间层通过字节数组缓存，毫无疑问如果是大文件的话，这种效率不太高，至于IO流的包装还有待研究</p>
</blockquote>
<h3 id="九-总结"><a href="#九-总结" class="headerlink" title="九.总结"></a>九.总结</h3><blockquote>
<p>经历过上面的过程总算知道怎样使用Okhttp发起常见的网络请求了，并且操作手机内存中的文件，如果你写过<code>HttpURLConnection</code>请求网络以及相关的文件操作，你会发现Okhttp是真的简洁好用，下面将从源码层面细说Okhttp框架</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/okhttp-learning">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>网络开源库-Retrofit</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Retrofit.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>小编花了两天时间了解了Retrofit，认识了Retrofit是什么，以及如何使用它，讲真，我在第一次接触Retrofit时，觉得它实在是有点抽象，可能因为<strong>注解</strong>使用太多了的吧，以及请求网络方法的编写有点特别，习惯了使用Okhttp还真觉得Retrofit有点难以理解，甚至使用都很困难，不过折磨了两天，会使用它请求网络之后，发现Retrofit是真的简洁，特别是对于一个公司的项目开发来说确实太好用了，请求网络的不二之选，下面谈谈我对学习网络请求的心得吧。</p>
</blockquote>
<ol>
<li>在使用Okhttp之前我还在使用HttpURLConnection，实在麻烦，除了需要写具体连接，还要使用<strong>IO流</strong>来接收返回的数据，显然笨拙，并且臃肿</li>
<li>在认识Retrofit之前，使用过Okhttp和Volley，只能说各有优缺点，Okhttp使用起来流程容易理解，但还是需要做具体的网络连接(创建client、request、call、response等等)并且还需要自己解析返回的Json字符串等数据，Volley呢，使用很简洁，这点体现在使用流程，不需要像Okhttp那样创建过多的对象，缺点是大文件上传下载效率不太行</li>
<li>今天算是真正认识了Retrofit，它不算是一个独立的网络开源库，因为它仅仅是将Okhttp做了一层封装，本质还是Okhttp，但正是由于这层封装为开发者省去了不少麻烦，小编在这里竖起了大拇指，下面小编将介绍Retrofit的基本使用，于我而言已经够目前程度的开发了</li>
</ol>
<h3 id="二-剖析Retrofit"><a href="#二-剖析Retrofit" class="headerlink" title="二.剖析Retrofit"></a>二.剖析Retrofit</h3><p>上面也说到了，我刚开始之所以觉得Retrofit难以理解，就是因为它大量使用注解，并且网络请求的方法具体是由系统帮我们实现，还好提前接触过<strong>Room</strong>的使用，我感觉他俩挺类似的，都大量使用注解来构建方法，所以显得有些抽象，对初学者来说不太友好，其实注解就是一个标记，别想得太复杂，作为新手只需要知道怎么去添加注解并使用，当使用熟练后可以去看下Retrofit的源码，看它是如何处理注解的</p>
<p><strong>Retrofit共22个注解，这里只列出本次学习用到过的注解，并且是相当常用的，如需进一步了解，请看本文末尾推荐的博客</strong></p>
<ol>
<li><p>请求方法类</p>
<p>GET</p>
<p>POST</p>
<p>HTTP</p>
<p>这些其实对应的是具体有哪些网络请求的方式，不需要记</p>
</li>
<li><p>标记类</p>
<p>FormUrlEncoded</p>
<p>Multipart</p>
</li>
<li><p>参数类</p>
<p>Query</p>
<p>Field</p>
<p>FieldMap</p>
<p>QueryMap</p>
<p>Path</p>
<p>URL</p>
<p>Part</p>
</li>
</ol>
<p>以上注解都是重中之重，普遍使用，下面开始撸码分批次详解</p>
<h3 id="三-Retrofit的使用步骤"><a href="#三-Retrofit的使用步骤" class="headerlink" title="三.Retrofit的使用步骤"></a>三.Retrofit的使用步骤</h3><p>上面提到进行网络请求的方法都是通过注解来构建的，并且具体实现是由系统实现，因此它是抽象的，自然使用一个接口来封装所有的网络请求方法</p>
<ol>
<li>创建一个接口用于封装所有的网络请求方法</li>
<li>通过Retrofit提供的Builder建造者模式创建一个Retrofit对象，具体内容包括服务器基址，本次案例使用的是本地服务器，以及解析Json数据的转换器和适配器等等</li>
<li>在接口中通过注解构建方法，在请求类标记中拼接URL路径以及方法中定义参数和返回值，在例子中会具体演示</li>
<li>使用Retrofit的对象提供的代理模式创建一个<strong>接口的实例</strong></li>
<li>通过接口实例调用网络请求方法获取到Call对象</li>
<li>最后通过Call对象发起请求，具体有同步(execute)和异步(enquue)，这点和Okhttp里的一样</li>
</ol>
<p>看上去步骤多，其实使用超简单</p>
<p>下面提供需要添加的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com.squareup.retrofit2:retrofit:2.4.0&#x27;</span><br><span class="line">    //使用Gson进行Json数据的解析</span><br><span class="line">implementation &#x27;com.squareup.retrofit2:converter-gson:2.4.0&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="四-不带参数的GET请求"><a href="#四-不带参数的GET请求" class="headerlink" title="四.不带参数的GET请求"></a>四.不带参数的GET请求</h3><p>由于大部分测试都是使用的是本地服务器上的后台程序，所以基址都是电脑IP，之前在Okhttp篇以及提到过了，在此就不做赘述，第一个网络请求是不带参数的，通过php编写的后端程序返回一个字符串“小王”</p>
<p>由于基址都一样，所以都可以使用同一个Retrofit对象以及接口实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private val retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(&quot;http://192.168.0.103/&quot;)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">private val api = retrofit.create(NetWorkAPI::class.java)</span><br></pre></td></tr></table></figure>

<p><strong>注意：基址的末尾一定要加上/，然手添加解析工具Gson，接口对象通过Retrofit提供的create方法创建</strong></p>
<p>下面重点关注接口中的网络请求方法怎么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GET(&quot;a.php&quot;)</span><br><span class="line">fun getJsonTestString(): Call&lt;ResponseBody&gt;</span><br></pre></td></tr></table></figure>

<p>由于不带参数所以很简洁，可以看到先使用网络请求的注解进行表示，括号内拼接路径，因此完整路径为：</p>
<p><a href="http://192.168.0.103/a.php">http://192.168.0.103/a.php</a></p>
<p><strong>如法炮制，其他方式的网络请求注解都可按此方式，还有另外一种动态的URL，下面会提</strong></p>
<p>返回一个Call对象，由于这里不需要解析Json数据，所以是ResponseBody类型，如需解析这填入具体的解析类型</p>
<p>然后是通过接口的实例对象调用网络请求方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val call = api.getJsonTestString()</span><br><span class="line">call.enqueue(object :Callback&lt;ResponseBody&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;ResponseBody&gt;, response: Response&lt;ResponseBody&gt;) &#123;</span><br><span class="line">                showText.text = response.body()?.string()</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onFailure(call: Call&lt;ResponseBody&gt;, t: Throwable) &#123;</span><br><span class="line">                Log.v(&quot;cx&quot;,&quot;失败&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>可以发现调用方法并处理结果是真的简单，这里使用的是异步，同步的话需要搭配协程</p>
<h3 id="五-带参数的GET请求"><a href="#五-带参数的GET请求" class="headerlink" title="五.带参数的GET请求"></a>五.带参数的GET请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val retrofit = Retrofit.Builder()</span><br><span class="line">            .baseUrl(&quot;http://apis.juhe.cn/simpleWeather/&quot;)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">val api = retrofit.create(NetWorkAPI::class.java)</span><br><span class="line">val call = api.getWeather(&quot;北京&quot;)</span><br><span class="line">call.enqueue(object :Callback&lt;Weather&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;Weather&gt;, response: Response&lt;Weather&gt;) &#123;</span><br><span class="line">                val cityName = response.body()?.result?.city</span><br><span class="line">                showText.text = &quot;当前城市：$cityName&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;Weather&gt;, t: Throwable) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">------------------------------------------------------------------------------------------------------------ @GET(&quot;query&quot;)</span><br><span class="line">fun getWeather(@Query(&quot;city&quot;) City:String,@Query(&quot;key&quot;) key:String = API_KEY):Call&lt;Weather&gt; </span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">data class Weather(val error_code:Int,val result: Result)</span><br><span class="line">data class Result(val city:String,val realtime: RealTime)</span><br><span class="line">data class RealTime(</span><br><span class="line">    val temperature:String,</span><br><span class="line">    val info:String,</span><br><span class="line">    val direct:String,</span><br><span class="line">    val power:String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拼接路径和上一个例子相似，如果要拼接参数的话，需要在函数参数中使用注解，GET方式使用@Query(链接中的字段名)，参数也可直接赋值常量写死，经过上述拼接，最终的访问链接为：<a href="http://apis.juhe.cn/simpleWeather/query?city=%E5%9F%8E%E5%B8%82%E5%90%8D&amp;key=%E5%BA%94%E7%94%A8key">http://apis.juhe.cn/simpleWeather/query?city=城市名&amp;key=应用key</a></p>
</blockquote>
<p>使用的是聚合数据提供的天气查询的API，因此返回的是Weather类对象，故Call对象泛型中填入Weather，程序会自动进行json解析，进过以上两个例子可以总结出如果不需要对返回的数据进行类转换，则Call的泛型类型为ResponseBody，反之则为具体的转换类的类型</p>
<p><strong>进行一个补充，由于此处的链接基址不再是本地服务器，所以我创建了一个新的Retrofit对象，但是在实际开发中最好只用一个Retrofit实例，即提供单例模式，下面推荐使用动态链接</strong></p>
<p>如果你需要定义一个链接和基址不同的网络请求方法，那么你只需要使用@Url标注参数，参数即为你的链接地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val url = &quot;http://apis.juhe.cn/simpleWeather/query?city=北京&amp;key=应用key&quot;</span><br><span class="line">val call = api.dynamicGetWeather(url)</span><br><span class="line">call.enqueue(object:Callback&lt;Weather&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;Weather&gt;, response: Response&lt;Weather&gt;) &#123;</span><br><span class="line">                val cityName = response.body()?.result?.city</span><br><span class="line">                showText.text = &quot;当前城市：$cityName&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;Weather&gt;, t: Throwable) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">@GET</span><br><span class="line">fun dynamicGetWeather(@Url url:String):Call&lt;Weather&gt;        </span><br></pre></td></tr></table></figure>

<p>此处我们使用的时以本地服务器IP为基址的Retrofit对象，因为使用了@Url标注，当系统检测到你传入的url基址和之前的不一样，那么它就会以使用注解标注的url为真正的链接，其实动态url还有另一种用法，达到和静态一样的效果</p>
<p>使用注解标注后可以在参数中拼接链接，也就是说GET等请求注解括号内不需要内容，下面改装第一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GET</span><br><span class="line">fun getJsonTestString2(@Url url:String): Call&lt;ResponseBody&gt;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">val call = api.getJsonTestString(&quot;a.php&quot;)</span><br></pre></td></tr></table></figure>

<p>使用时传入url链接的剩余部分即可，系统会自动拼接之前设置的基址</p>
<h3 id="六-使用Map一次传入多个参数发起GET请求"><a href="#六-使用Map一次传入多个参数发起GET请求" class="headerlink" title="六.使用Map一次传入多个参数发起GET请求"></a>六.使用Map一次传入多个参数发起GET请求</h3><p>如果你的链接中需要传入多个参数，而且又想使用GET请求，下面推荐使用Map包装键值对一次性传入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GET(&quot;login/login.php&quot;)</span><br><span class="line">fun getMultyParamsLogin(@QueryMap params:Map&lt;String,String&gt;):Call&lt;ResponseBody&gt;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">val paramsMap = HashMap&lt;String,String&gt;().apply &#123;</span><br><span class="line">            put(&quot;user_name&quot;,&quot;jack&quot;)</span><br><span class="line">            put(&quot;user_pwd&quot;,&quot;123&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">val call = api.getMultyParamsLogin(paramsMap)</span><br><span class="line">call.enqueue(object :Callback&lt;ResponseBody&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;ResponseBody&gt;, response: Response&lt;ResponseBody&gt;) &#123;</span><br><span class="line">                showText.text = response.body()?.string()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;ResponseBody&gt;, t: Throwable) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用@QueryMap注解表示你需要传入一个Map键值对的包装，系统会自动根据字段去填充值以及拼接链接</p>
</blockquote>
<h3 id="七-使用POST方式登录提交表单"><a href="#七-使用POST方式登录提交表单" class="headerlink" title="七.使用POST方式登录提交表单"></a>七.使用POST方式登录提交表单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FormUrlEncoded</span><br><span class="line">@POST(&quot;login/login.php&quot;)</span><br><span class="line">fun getPostFormLogin(@Field(&quot;user_name&quot;) name:String,@Field(&quot;user_pwd&quot;) pwd:String):Call&lt;ResponseBody&gt;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">val call = api.getPostFormLogin(&quot;jack&quot;,&quot;123&quot;)</span><br><span class="line">call.enqueue(object :Callback&lt;ResponseBody&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;ResponseBody&gt;, response: Response&lt;ResponseBody&gt;) &#123;</span><br><span class="line">                Toast.makeText(this@MainActivity,&quot;登录成功！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;ResponseBody&gt;, t: Throwable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>POST方式首先需要使用@FormUrlEncoded表明你提交的是表单</li>
<li>拼接路径和GET方式一样，此处不做赘述</li>
<li>传入的参数使用@Field(字段名称)注解标注，注意这和GET请求标注参数是不同的</li>
</ol>
<h3 id="八-使用POST方式上传文件"><a href="#八-使用POST方式上传文件" class="headerlink" title="八.使用POST方式上传文件"></a>八.使用POST方式上传文件</h3><p>首先配置访问文件的权限，详情请看Okhttp篇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Multipart</span><br><span class="line">@POST(&quot;upload.php&quot;)</span><br><span class="line">fun getPostFile(@Part file:MultipartBody.Part):Call&lt;ResponseBody&gt;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">val requestBodyFile = RequestBody.create(MediaType.parse(&quot;image/png&quot;),file)</span><br><span class="line">val multyBody = MultipartBody.Part.createFormData(&quot;file&quot;,&quot;retrofit上传的文件.png&quot;,requestBodyFile )</span><br><span class="line">val call = api.getPostFile(multyBody)</span><br><span class="line">call.enqueue(object :Callback&lt;ResponseBody&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;ResponseBody&gt;, response: Response&lt;ResponseBody&gt;) &#123;</span><br><span class="line">                showText.text = response.body()?.string()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onFailure(call: Call&lt;ResponseBody&gt;, t: Throwable) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>首先使用@Multipart表示提交的媒体类型</li>
<li>函数的参数使用@Part标注，参数类型是MultipartBody.Part</li>
<li>在代码中给文件对象设置媒体类型并且封装成<code>RequestBody</code>类型</li>
<li>接着创建传入的参数<code>MultipartBody.Part</code>类型，参数一是你后台程序中文件的字段名，Okhttp篇中有介绍，参数二是上传到服务器端后的名称，参数三是步骤3中创建的对象</li>
</ol>
<blockquote>
<p>上传文件稍微繁琐一点，多两个步骤</p>
</blockquote>
<h3 id="九-文件下载"><a href="#九-文件下载" class="headerlink" title="九.文件下载"></a>九.文件下载</h3><p>文件下载较为简单，使用普通的GET请求即可，拼接好路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GET(&quot;girl1.jpg&quot;)</span><br><span class="line">fun getDownLoadPic():Call&lt;ResponseBody&gt;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">val call = api.getDownLoadPic()</span><br><span class="line">call.enqueue(object :Callback&lt;ResponseBody&gt;&#123;</span><br><span class="line">            override fun onResponse(call: Call&lt;ResponseBody&gt;, response: Response&lt;ResponseBody&gt;) &#123;</span><br><span class="line">                val filePath = Environment.getExternalStorageDirectory().absolutePath+&quot;/a/retrofitDownload.png&quot;</span><br><span class="line">                val diskFile = File(filePath)</span><br><span class="line">                if (!diskFile.exists())&#123;</span><br><span class="line">                    diskFile.createNewFile()</span><br><span class="line">                &#125;</span><br><span class="line">                response.body()?.byteStream().use &#123;input-&gt;</span><br><span class="line">                    val buffer = input?.readBytes()</span><br><span class="line">                    diskFile.outputStream().use &#123;output-&gt;</span><br><span class="line">                        output.write(buffer)</span><br><span class="line">                    &#125;</span><br><span class="line">                   BitmapFactory.decodeFile(filePath).also &#123; imageView.setImageBitmap(it) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            override fun onFailure(call: Call&lt;ResponseBody&gt;, t: Throwable) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问链接成功后，文件流会包裹在ResponseBody中带回，后续的便是文件操作，一笔略过</p>
</blockquote>
<h3 id="十-总结"><a href="#十-总结" class="headerlink" title="十.总结"></a>十.总结</h3><blockquote>
<p>其实在开头就已经有总结Retrofit的好处了，相信跟着小编的步伐，已经会使用Retrofit了，在实际开发中使用Retrofit简直方便，将所有的网络请求封装到一个接口中，将Retrofit对象封装成单例，只能说竖起大拇指！下面配上整体效果图以及代码链接</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/retrofit%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.gif" style="zoom:33%;" />

<p><a href="https://blog.csdn.net/cmyperson/article/details/86521735">推荐博客1</a></p>
<p><a href="https://blog.csdn.net/duncan891101/article/details/107890269">推荐博客2</a></p>
<p><a href="https://gitee.com/wiwiyiyi/retrofit-test">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>网络开源库-Volley</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E5%BA%93-Volley.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>今天了解网络开源库<code>Volley</code>，主要以<code>Volley</code>的日常使用为主，下面是<code>Volley</code>的优势和劣势</p>
</blockquote>
<p>优点：</p>
<ol>
<li><p>网络请求的排序(scheduling)</p>
</li>
<li><p>网络请求的优先级处理</p>
</li>
<li><p>缓存</p>
</li>
<li><p>多级别取消请求</p>
</li>
<li><p>和Activity的生命周期联动(Activity结束时同时取消所有网络请求)</p>
</li>
<li><p>非常适合进行数据量不大，但通信频繁的网络操作</p>
</li>
<li><p>可自定义扩展</p>
</li>
</ol>
<p>缺点：对于大数据量的网络操作，如下载文件，Volley不太行   </p>
<p><code>Volley</code>的使用大致分为三个步骤：</p>
<ol>
<li> 创建一个请求队列</li>
<li>创建一个请求</li>
<li>将请求添加到队列中</li>
</ol>
<p>有以下几种请求API：</p>
<ol>
<li>请求String类型数据：StringRequest</li>
<li>请求JSON数据：JsonObjectRequest/JsonArrayRequest</li>
<li>请求图片数据：ImageRequest</li>
</ol>
<h3 id="二-简单的GET请求"><a href="#二-简单的GET请求" class="headerlink" title="二.简单的GET请求"></a>二.简单的GET请求</h3><p><strong>由于创建请求队列特别好资源所以我们将它进行封装成单例，全局只有一个请求队列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class VolleySingleton private constructor(context: Context)&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        var instance:VolleySingleton?=null</span><br><span class="line">        fun getInstance(context: Context) = instance?: synchronized(this)&#123;</span><br><span class="line">            instance?:VolleySingleton(context).also &#123; instance = it &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val requestQueue:RequestQueue by lazy &#123;</span><br><span class="line">            Volley.newRequestQueue(context.applicationContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：在网络请求中我们多数使用的是String类型数据的请求，返回给我们的是Json字符串，然后通过相应的Json解析得到实体类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun VolleyGet()&#123;</span><br><span class="line">        val request = StringRequest(url1,&#123;</span><br><span class="line">            val weather = gson.fromJson(it,Weather::class.java)</span><br><span class="line">            Toast.makeText(this,&quot;请求成功！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">            if (weather.error_code == 0)&#123;</span><br><span class="line">                city.text = weather.result.city</span><br><span class="line">                weatherInfo.text = weather.result.realtime.info</span><br><span class="line">                temperature.text = weather.result.realtime.temperature</span><br><span class="line">                wind.text = weather.result.realtime.direct</span><br><span class="line">                power.text = weather.result.realtime.power</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            Toast.makeText(this,&quot;请求失败&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;)</span><br><span class="line">        VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>StringRequest(url地址，请求成功的处理(参数是Json字符串)，请求失败的处理)</code></p>
</li>
<li><p>此处使用的API是聚合数据提供的天气查询，返回的Json字符串通过Gson解析成对应的实体类，当然这种对应可以不是一一对应，如果你只需要其中的部分值，那么构建实体类时添加部分属性即可，下面上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data class Weather(val error_code:Int,val result: Result)</span><br><span class="line">data class Result(val city:String,val realtime: RealTime)</span><br><span class="line">data class RealTime(</span><br><span class="line">    val temperature:String,</span><br><span class="line">    val info:String,</span><br><span class="line">    val direct:String,</span><br><span class="line">    val power:String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面通过查看工具可以看到返回的Json字符串的结构</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%B8%80%E5%B1%82.png" style="zoom:70%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Json%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%AC%E4%BA%8C%E5%B1%82.png" style="zoom:50%;" /></li>
</ol>
<h3 id="三-POST请求添加参数"><a href="#三-POST请求添加参数" class="headerlink" title="三.POST请求添加参数"></a>三.POST请求添加参数</h3><p>同样使用<code>StringRequest()</code>演示使用POST请求并添加参数进行登录验证</p>
<p><strong>添加参数需要使用匿名内部类的方式重写StringRequest中的一个getParams()方法，并通过Map添加键值对的方式来设置参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun VolleyPostTest()&#123;</span><br><span class="line">		val url2 = &quot;http://192.168.0.103/login/login.php&quot;</span><br><span class="line">       val request = object :StringRequest(Method.POST,url2,&#123;</span><br><span class="line">        Toast.makeText(this,it,Toast.LENGTH_SHORT).show()</span><br><span class="line">       &#125;,&#123;</span><br><span class="line">           Toast.makeText(this,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">       &#125;)&#123;</span><br><span class="line">           override fun getParams(): MutableMap&lt;String, String&gt; &#123;</span><br><span class="line">               return HashMap&lt;String,String&gt;().apply &#123;</span><br><span class="line">                   put(&quot;user_name&quot;, &quot;jack&quot;)</span><br><span class="line">                   put(&quot;user_pwd&quot;, &quot;123&quot;)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>和GET方式一样，使用简单</p>
<h3 id="四-请求Json数据"><a href="#四-请求Json数据" class="headerlink" title="四.请求Json数据"></a>四.请求Json数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun VolleyJson()&#123;</span><br><span class="line">        val request = JsonObjectRequest(url1,null,&#123;</span><br><span class="line">            Toast.makeText(this,it.toString(),Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            Toast.makeText(this,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;)</span><br><span class="line">        VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到几乎没什么变化，只是多了一个jsonRequest的参数，通常是null</p>
<p>请求回来的JsonObject数据目前咱不知道如何使用，所以就将它转换成字符串打印出来，看网上的博客说可以搭配Ajax和jsp实现页面刷新</p>
<h3 id="五-加载图片"><a href="#五-加载图片" class="headerlink" title="五.加载图片"></a>五.加载图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun VolleyImage()&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/girl1.jpg&quot;</span><br><span class="line">        val request = ImageRequest(url,&#123;bitmap-&gt;</span><br><span class="line">			imageView.setImageBitmap(bitmap)</span><br><span class="line">        &#125;,0,0,ImageView.ScaleType.FIT_CENTER,Bitmap.Config.RGB_565,&#123;</span><br><span class="line">            Toast.makeText(this,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;)</span><br><span class="line">        VolleySingleton.getInstance(applicationContext).requestQueue.add(request)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>步骤和前面的那些请求基本一致，除了参数变多</p>
<p>参数一：url地址</p>
<p>参数二：请求成功的操作，参数为Bitmap类型</p>
<p>参数三：最大宽度，设置为0是默认</p>
<p>参数四：最大高度，同理</p>
<p>参数五：图片的拉伸方式</p>
<p>参数六：图片的透明度以及红绿蓝使用哪种模式，示例代码使用的是缓存最小的模式</p>
<h3 id="六-使用Volley中的ImageLoader加载图片"><a href="#六-使用Volley中的ImageLoader加载图片" class="headerlink" title="六.使用Volley中的ImageLoader加载图片"></a>六.使用Volley中的ImageLoader加载图片</h3><ol>
<li>创建ImageLoader，由于使用的单例所以省去创建RequestQueue这一步骤</li>
<li>通过ImageLoader提供的get方法传入url地址和实现监听的匿名内部类加载图片</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun NoCacheImagLoader()&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/girl2.jpg&quot;</span><br><span class="line">        val imageLoader = ImageLoader(</span><br><span class="line">            VolleySingleton.getInstance(applicationContext).requestQueue,</span><br><span class="line">            object :ImageLoader.ImageCache&#123;</span><br><span class="line">                override fun getBitmap(url: String?): Bitmap? &#123;</span><br><span class="line">                    return null</span><br><span class="line">                &#125;</span><br><span class="line">                override fun putBitmap(url: String?, bitmap: Bitmap?) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        //加载图片</span><br><span class="line">        imageLoader.get(url,object :ImageLoader.ImageListener&#123;</span><br><span class="line">            override fun onErrorResponse(error: VolleyError?) &#123;</span><br><span class="line">                Toast.makeText(this@MainActivity,&quot;网络连接超时！&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onResponse(response: ImageLoader.ImageContainer?, isImmediate: Boolean) &#123;</span><br><span class="line">                imageView.setImageBitmap(response?.bitmap)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方式是没有缓存的，下面展示有缓存的用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val imageLoader = ImageLoader(</span><br><span class="line">            VolleySingleton.getInstance(applicationContext).requestQueue,</span><br><span class="line">            object :ImageLoader.ImageCache&#123;</span><br><span class="line">                var mCache:LruCache&lt;String,Bitmap&gt;</span><br><span class="line">                init &#123;</span><br><span class="line">                    val maxSize = 10*1024*1024</span><br><span class="line">                    mCache = object :LruCache&lt;String,Bitmap&gt;(maxSize)&#123;</span><br><span class="line">                        override fun sizeOf(key: String?, value: Bitmap?): Int &#123;</span><br><span class="line">                            return if (value?.height==null)&#123;</span><br><span class="line">                                super.sizeOf(key, value)</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                value.rowBytes*value.height</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                override fun getBitmap(url: String?): Bitmap? &#123;</span><br><span class="line">                    return mCache.get(url)</span><br><span class="line">                &#125;</span><br><span class="line">                override fun putBitmap(url: String?, bitmap: Bitmap?) &#123;</span><br><span class="line">                    mCache.put(url,bitmap)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<h3 id="七-使用NetworkImageView加载图片"><a href="#七-使用NetworkImageView加载图片" class="headerlink" title="七.使用NetworkImageView加载图片"></a>七.使用NetworkImageView加载图片</h3><p>关键步骤：</p>
<ol>
<li>设置ImageLoader</li>
<li>设置Url</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun NetworkLoadImage()&#123;</span><br><span class="line">        val url = &quot;http://192.168.0.103/girl3.jpg&quot;</span><br><span class="line">        val imageLoader = ImageLoader(</span><br><span class="line">            VolleySingleton.getInstance(applicationContext).requestQueue,</span><br><span class="line">            object :ImageLoader.ImageCache&#123;</span><br><span class="line">                var mCache:LruCache&lt;String,Bitmap&gt;</span><br><span class="line">                init &#123;</span><br><span class="line">                    val maxSize = 10*1024*1024</span><br><span class="line">                    mCache = object :LruCache&lt;String,Bitmap&gt;(maxSize)&#123;</span><br><span class="line">                        override fun sizeOf(key: String?, value: Bitmap?): Int &#123;</span><br><span class="line">                            return if (value?.height==null)&#123;</span><br><span class="line">                                super.sizeOf(key, value)</span><br><span class="line">                            &#125;else&#123;</span><br><span class="line">                                value.rowBytes*value.height</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                override fun getBitmap(url: String?): Bitmap? &#123;</span><br><span class="line">                    return mCache.get(url)</span><br><span class="line">                &#125;</span><br><span class="line">                override fun putBitmap(url: String?, bitmap: Bitmap?) &#123;</span><br><span class="line">                    mCache.put(url,bitmap)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        networkImageView.setImageUrl(url,imageLoader)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外还可以设置默认图片以及加载失败后的图片</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">networkImageView.setDefaultImageResId()</span><br><span class="line">networkImageView.setErrorImageResId()</span><br></pre></td></tr></table></figure>

<h3 id="八-集体效果展示"><a href="#八-集体效果展示" class="headerlink" title="八.集体效果展示"></a>八.集体效果展示</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/Volley%E8%AF%B7%E6%B1%82%E5%A4%A7%E5%90%88%E9%9B%86.gif" style="zoom: 40%;" />

<h3 id="九-总结"><a href="#九-总结" class="headerlink" title="九.总结"></a>九.总结</h3><blockquote>
<p>Volley是网络开源库第二站，与之前的Okhttp相比确实简洁很多，尤其是普通的GET和POST请求，上述的所有请求方式大致都分为三大步骤，这种异步的请求处理确实方便很多</p>
</blockquote>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>网络阶段小Demo-简易画廊</title>
    <url>/%E7%BD%91%E7%BB%9C%E9%98%B6%E6%AE%B5%E5%B0%8FDemo-%E7%AE%80%E6%98%93%E7%94%BB%E5%BB%8A.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>近段时间对使用流行的几大网络开源框架进行了学习，为了巩固和复习之前的知识，熟悉MVVM设计模式，试做一个简易图片画廊的小Demo，不断从网络中加载图片并展示</p>
</blockquote>
<h3 id="二-知识点分析"><a href="#二-知识点分析" class="headerlink" title="二.知识点分析"></a>二.知识点分析</h3><ol>
<li>MVVM设计模式</li>
<li>单例设计模式</li>
<li>Navigation-Fragment导航</li>
<li>RecyclerView展示图片</li>
<li>网络请求框架Volley、Glide的使用</li>
<li>使用Gson解析Json数据</li>
</ol>
<blockquote>
<p>另外使用到了下拉刷新<code>swiperefreshlayout</code>、图片闪烁装饰<code>shimmerlayout</code>，界面跳转时数据传递使用了<code>Parcelable</code>对象序列化，此实例本应该使用Repository作一层封装，简化ViewModel层，但为了简单就省略了</p>
</blockquote>
<h3 id="三-设计思路分析"><a href="#三-设计思路分析" class="headerlink" title="三.设计思路分析"></a>三.设计思路分析</h3><p>RecyclerView的适配器Adapter使用的是ListAdapter，通过submitList()方法提交数据，不至于想notifyDataSetChanged()那样消耗内存，通过数据驱动加载图片，只有两个页面，逻辑也较为简单，首先通过Volley去加载数据，获取到每张图片具体的url后，将数据提交给Adapter，在Adapter内部绑定视图时，取出url通过Glide去加载图片，并在创建视图时设置点击事件，跳转到具体界面，传递一个带有大图url的对象，在目的界面通过传递的数据取出大图url，通过Glide加载图片，具体细节可以查看代码</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E7%AE%80%E6%98%93%E7%94%BB%E5%BB%8A%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:50%;" />

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E7%BD%91%E7%BB%9C/%E7%AE%80%E6%98%93%E7%94%BB%E5%BB%8A%E6%95%88%E6%9E%9C%E5%9B%BE.gif"></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>算是对网络阶段的一个收尾，Demo不难，但效果还不错</p>
</blockquote>
<p><a href="https://gitee.com/wiwiyiyi/gallery-test">代码链接</a></p>
]]></content>
      <categories>
        <category>Android开发基础集</category>
      </categories>
      <tags>
        <tag>网络开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Dialog详解</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89Dialog%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>在实际写项目时，我们会有弹出一个对话框的需求，对话框比较轻量，可以升级用户体验，并且使用也不是很难，但系统提供的Dialog无法满足我们多样化的需求，尤其是界面布局以及响应事件，下面小编将按步骤详解如何自定义Dialog</p>
</blockquote>
<h3 id="二-Dialog基本介绍"><a href="#二-Dialog基本介绍" class="headerlink" title="二.Dialog基本介绍"></a>二.Dialog基本介绍</h3><p>Dialog也有自己的生命周期，这里不做详细介绍，因为通常我们使用只会涉及到一级Dialog，而不会像选择地区时会涉及到省/市/县三级Dialog，这种情况会涉及到Dialog的保存即生命周期，本文主要自定义Dialog的流程以及使用中需要注意的基本设置，能够满足个性化使用即可</p>
<h3 id="三-自定义Dialog基本流程"><a href="#三-自定义Dialog基本流程" class="headerlink" title="三.自定义Dialog基本流程"></a>三.自定义Dialog基本流程</h3><ol>
<li><p>创建Dialog的布局文件</p>
<p>①值得注意的是布局大小不要使用<code>match_parent</code>，因为实际弹出的对话框肯定不会填满整个屏幕的，并且如果没有在代码中设置Dialog的大小的话，会默认使用<code>wrap_content</code>，所以原本的布局都会被打乱，很难看，所以建议布局大小采用固定值，并且后面在代码中也会使用布局的固定值设定Dialog的大小</p>
<p>②当然Dialog的背景可以设置为某张图片，如果担心图片填不满或者拉伸失真，建议图片的宽高比和Dialog的宽高比相近，这样按比例填充的效果还不错，下面上图</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Room/dialog%E5%A1%AB%E5%85%85%E5%9B%BE%E7%89%87.png" style="zoom:40%;" /></li>
<li><p>在res/values/styles.xml文件中新建Dialog的样式，不添加则会使用系统的默认样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;自定义Dialog的类名&quot; parent=&quot;android:Theme.Dialog&quot;&gt;</span><br><span class="line">        //背景颜色及透明程度</span><br><span class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;</span><br><span class="line">        //Dialog是否半透明</span><br><span class="line">        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt;</span><br><span class="line">        //是否去除标题</span><br><span class="line">        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">        //Dailog是否浮动/移动</span><br><span class="line">        &lt;item name=&quot;android:windowIsFloating&quot;&gt;false&lt;/item&gt;</span><br><span class="line">        //弹出Dialog时，是否变暗背景</span><br><span class="line">        &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;true&lt;/item&gt;</span><br><span class="line">        //是否需要在Dialog中自动弹出键盘</span><br><span class="line">        &lt;item name=&quot;android:windowSoftInputMode&quot;&gt;stateVisible&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>①由于本次做的Demo需要在弹出Dialog的同时弹出键盘，所以需要添加最后一句话，不添加是不会弹出键盘的</p>
<p>②在弹出键盘时发现Dialog会被键盘顶上去，所以我们需要在style中设置Dialog不可浮动，这点很关键，至于Dialog会被挡住的问题需要在代码中设置Dialog的位置</p>
<p>③以上是常用属性，可以自行百度了解其他属性</p>
</li>
<li><p>创建类继承自Dialog</p>
<p>自定义的Dialog类需要传入<code>context</code>上下文，即该Dialog附属于哪个Activity，样式可以不用传递，直接在父类的构造方法中传入即可，所有的代码逻辑类似于Activity在<code>onCreate</code>方法中填写，下面上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class WordsDialog(private val mContext: Context, private val viewModel: MyViewModel):Dialog(mContext,R.style.WordsDialog) &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        val view = LayoutInflater.from(mContext).inflate(R.layout.words_add_dialog_layout,null,false)</span><br><span class="line">        setContentView(view)</span><br><span class="line">        setCancelable(false)</span><br><span class="line">        val lp = window?.attributes</span><br><span class="line">        lp?.width = dpTopx(300)</span><br><span class="line">        lp?.height = dpTopx(400)</span><br><span class="line">        lp?.x = dpTopx(0)</span><br><span class="line">        lp?.y = dpTopx(-50)</span><br><span class="line">        window?.attributes = lp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        val cancelBtn = view.findViewById&lt;Button&gt;(R.id.cancelBtn)</span><br><span class="line">        val addBtn = view.findViewById&lt;Button&gt;(R.id.addBtn)</span><br><span class="line">        val inputWords = view.findViewById&lt;EditText&gt;(R.id.inputWords)</span><br><span class="line">        val inputMeanings = view.findViewById&lt;EditText&gt;(R.id.inputMeanings)</span><br><span class="line"></span><br><span class="line">        val wordsTextWatcher = object :TextWatcher&#123;</span><br><span class="line">            override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) &#123;</span><br><span class="line">                val english = inputWords.text.toString().trim()</span><br><span class="line">                val chinese = inputMeanings.text.toString().trim()</span><br><span class="line">                addBtn.isEnabled  = english.isNotEmpty() &amp;&amp; chinese.isNotEmpty()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun afterTextChanged(p0: Editable?) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        showKeyBoard(inputWords)</span><br><span class="line">        cancelBtn.setOnClickListener &#123;</span><br><span class="line">            dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">        addBtn.setOnClickListener &#123;</span><br><span class="line">            val english = inputWords.text.toString().trim()</span><br><span class="line">            val chinese = inputMeanings.text.toString().trim()</span><br><span class="line">            viewModel.insert(Word(english,chinese))</span><br><span class="line">            hideKeyBoard(it)</span><br><span class="line">            Toast.makeText(context,&quot;添加成功!&quot;,Toast.LENGTH_SHORT).show()</span><br><span class="line">            dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">        inputWords.addTextChangedListener(wordsTextWatcher)</span><br><span class="line">        inputMeanings.addTextChangedListener(wordsTextWatcher)</span><br><span class="line">    &#125;</span><br><span class="line">    private fun dpTopx(dp:Int) = (context.resources.displayMetrics.density*dp).toInt()</span><br><span class="line">    private fun showKeyBoard(editText: EditText)&#123;</span><br><span class="line">        editText.requestFocus()</span><br><span class="line">        val inputMethodManager = mContext.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager</span><br><span class="line">        inputMethodManager.showSoftInput(editText,0)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private fun hideKeyBoard(view: View)&#123;</span><br><span class="line">        val inputMethodManager = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager</span><br><span class="line">        inputMethodManager.hideSoftInputFromWindow(view.windowToken,0)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>①首先我们需要通过<code>LayoutInflater</code>解析布局，由于没有父容器，所以参数中传入null，然后通过<code>setContentView</code>关联Dialog和布局，通过解析得到view布局对象可以得到布局文件中的控件，并添加监听事件，这点很自然，直接码代码即可</p>
<p>②处理好界面中的控件后，关键一步是设置Dialog的大小以及显示位置，如果不设置，则会采用默认的中心位置以及包裹内容，这样会显得很奇怪，所以我们可以通过<code>window</code>获取到布局参数<code>attributes</code>，添加好布局参数后，又将其赋值给<code>attributes</code></p>
<p>③具体设置窗体大小时需要进行dp值和px值的转换，因为布局文件中的固定值是dp，而不同设备的屏幕密度是不相同的，代码中的默认单位是px，所以我们需要进行一层转换，之前也用过很多次了，不再叙述</p>
<p>④设置窗体的位置时注意坐标原点在哪儿，由于默认是从屏幕的中心弹出对话框，经过测试，发现默认位置的中心应该就是坐标原点，据此来设置偏移量，经过不断调试找到合适位置</p>
</li>
</ol>
<h3 id="四-自定义Dialog小结"><a href="#四-自定义Dialog小结" class="headerlink" title="四.自定义Dialog小结"></a>四.自定义Dialog小结</h3><p>在使用时，只需创建对象并调用<code>show</code>方法即可，经过以上流程发现自定义Dialog以及使用其实不难，只是要运用得很灵活的话需要注意一些小细节，另外趁着闲暇之时去看了一下系统提供的Dialog的Builder类，即通过建造者模式创建一个Dialog，我感觉静态内部类Builder只是将以上代码创建Dialog的关键步骤进行了封装，并提供接口给使用者，使用起来更加简洁，这里就不做这层封装了，因为在写小项目中很多东西是可以内部写死的，就不再多此一举进行封装了</p>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义PhotoView处理手势</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E5%A4%84%E7%90%86%E6%89%8B%E5%8A%BF.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>前面比较完善的介绍了触摸事件的分发流程，也简单进行了实战，本文也是进行一个补充，在复杂的UI中会用到手势处理以及多点滑动，下面会重点介绍用到的API</p>
</blockquote>
<h3 id="二-手势处理API"><a href="#二-手势处理API" class="headerlink" title="二.手势处理API"></a>二.手势处理API</h3><blockquote>
<p>下面通过自定义PhotoView来使用手势处理的相关API，代码就不贴了，对于缩放是有一些逻辑的，这里就不详解了，重点在于介绍手势处理API</p>
</blockquote>
<p>Android中有一个类专门管理和处理手势：<code>GestureDetector</code>，需要传入一个<code>OnGestureListener</code>对象，其实具体手势的处理就是交给这个<code>OnGestureListener</code>去处理的，通常选择传入<code>SimpleOnGestureListener</code>的一个实例，因为<code>SimpleOnGestureListener</code>实现了几个接口，功能比较齐全，而且我们可以有选择性的重写想要的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inner class PhotoGestureDetector : GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">				// 在ACTION_DOWN时触发，必定触发</span><br><span class="line">        override fun onDown(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">				// 延时100ms，处理点击效果</span><br><span class="line">        override fun onShowPress(e: MotionEvent) &#123;</span><br><span class="line">            super.onShowPress(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// up时触发，单击或双击的第一次，不是双击和长按</span><br><span class="line">        override fun onSingleTapUp(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onSingleTapUp(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 滚动，后面会详解参数</span><br><span class="line">        override fun onScroll(e1: MotionEvent, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean &#123;</span><br><span class="line">            return super.onScroll(e1, e2, distanceX, distanceY)</span><br><span class="line">        &#125;</span><br><span class="line">				// 长按触发，默认达到300ms就会触发</span><br><span class="line">        override fun onLongPress(e: MotionEvent) &#123;</span><br><span class="line">            super.onLongPress(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 手指松开后，惯性滑动，大于50dp/s</span><br><span class="line">        override fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean &#123;</span><br><span class="line">            return super.onFling(e1, e2, velocityX, velocityY)</span><br><span class="line">        &#125;</span><br><span class="line">				// 单击按下时触发，双击不触发，up和down都有可能触发</span><br><span class="line">				// 延时300ms触发TAP事件</span><br><span class="line">				// 300ms以内抬手才会触发TAP</span><br><span class="line">				// 300ms以后抬手，不是双击，不是长按就触发</span><br><span class="line">        override fun onSingleTapConfirmed(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onSingleTapConfirmed(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 双击，在ACTION_DWON中处理，触发时间 40-300ms</span><br><span class="line">        override fun onDoubleTap(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onDoubleTap(e)</span><br><span class="line">        &#125;</span><br><span class="line">				// 双击的第二次Down、move、up都会触发这个</span><br><span class="line">        override fun onDoubleTapEvent(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onDoubleTapEvent(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onContextClick(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return super.onContextClick(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注：上述方法必须重写的是<code>onDown</code>，如果决定处理就必须返回true，其他的按需重写，返回值可以不用重写</p>
<p>上述代码中粗略的补齐了每个方法大致的调用时机，其实继承<code>SimpleOnGestureListener</code>有很多好处，这个类还帮我们实现类其他几个接口，并且很常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class SimpleOnGestureListener implements OnGestureListener, OnDoubleTapListener,</span><br><span class="line">            OnContextClickListener</span><br></pre></td></tr></table></figure>

<p>然后再回到<code>GestureDetector</code>的构造函数中来，看这样继承的好处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public GestureDetector(Context context, OnGestureListener listener, Handler handler) &#123;</span><br><span class="line">        if (handler != null) &#123;</span><br><span class="line">            mHandler = new GestureHandler(handler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mHandler = new GestureHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        mListener = listener;</span><br><span class="line">        if (listener instanceof OnDoubleTapListener) &#123;</span><br><span class="line">            setOnDoubleTapListener((OnDoubleTapListener) listener);</span><br><span class="line">        &#125;</span><br><span class="line">        if (listener instanceof OnContextClickListener) &#123;</span><br><span class="line">            setContextClickListener((OnContextClickListener) listener);</span><br><span class="line">        &#125;</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现系统会自动识别当前是否实现了OnDoubleTapListener和OnContextClickListener，就不用我们自己后续在进行注入了</p>
<p>另外需要注意的一个点是，如果<code>GestureDetector</code>是在子线程中创建的，还必须得调用<code>Looper.prepare()</code>，因为如果我们不手动传入一个handler实例，系统就会帮我们new一个，而Handler是会和所在线程进行一个绑定，必须进行prepare，而这个handler就是来处理触摸事件的，下面通过一张图来进行描述它们之间的关系</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" style="zoom: 33%;" />

<p>剩下的事情就是实际撸码来完成回调函数的逻辑了，比如双击放大，双击缩小</p>
<h3 id="三-展示双击放大-缩小-的回调逻辑处理"><a href="#三-展示双击放大-缩小-的回调逻辑处理" class="headerlink" title="三.展示双击放大(缩小)的回调逻辑处理"></a>三.展示双击放大(缩小)的回调逻辑处理</h3><p>基本思路：</p>
<p>通过一个变量来标识当前是放大还是缩小状态，每次取反即可</p>
<p>此前还有一些准备工作，譬如在<code>onSizedChange</code>中定义缩小状态和放大状态，这是由图片的尺寸比和承载它的View的尺寸比来决定的，具体逻辑不深究，有点烧脑吧，详情看代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private var isEnlarge = false</span><br><span class="line">var currentScale = 0f</span><br><span class="line">         set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">val scaleAnimator: ObjectAnimator by lazy &#123;</span><br><span class="line">        ObjectAnimator.ofFloat(this, &quot;currentScale&quot;, smallScale,bigScale)</span><br><span class="line">    &#125;</span><br><span class="line">inner class PhotoGestureDetector : GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">        override fun onDown(e: MotionEvent): Boolean &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        override fun onDoubleTap(e: MotionEvent): Boolean &#123;</span><br><span class="line">            isEnlarge = !isEnlarge</span><br><span class="line">            if (isEnlarge) &#123;</span><br><span class="line">                offsetX = e.x - width / 2f - (e.x - width / 2f) * bigScale / smallScale</span><br><span class="line">                offsetY = e.y - height / 2f - (e.y - height / 2f) * bigScale / smallScale</span><br><span class="line">                fixOffsets()</span><br><span class="line">                scaleAnimator.start()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scaleAnimator.reverse()</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onDoubleTap(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面就展示关键代码即可，为了让缩放更顺滑，通过一个属性动画来管理，所以思维不要局限，要知道属性动画就是<strong>针对属性</strong>的，并不是说一定要View自带的系统属性才能做属性动画，只需要在set值的时候做一个invalidate刷新即可，其他的处理，譬如偏移值，就不介绍了，因为我们总不能以图片或者View的中心点做为缩放的中心，应该以触摸点做缩放才合理，所以需要偏移</p>
<blockquote>
<p>这种所谓的缩放平移处理，就是让画布进行缩放平移，并且提供有相应的API，我们无需考虑</p>
</blockquote>
<p>值得注意的几点：</p>
<ol>
<li><p>滚动</p>
<p>滚动其实使用<code>onScroll</code>函数提供的distance参数即可，因为distance和画布translate的方向相反，所以需要取负数，不断的invalidate刷新即可，然后控制一下滚动的边界</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">offsetX = Math.min(offsetX, (bitmap.width * bigScale - width) / 2)</span><br><span class="line">    offsetX = Math.max(offsetX, -(bitmap.width * bigScale - width) / 2)</span><br><span class="line">    offsetY = Math.min(offsetY, (bitmap.height * bigScale - height) / 2)</span><br><span class="line">    offsetY = Math.max(offsetY, -(bitmap.height * bigScale - height) / 2)</span><br></pre></td></tr></table></figure>

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%BB%91%E5%8A%A8%E8%8C%83%E5%9B%B4%E7%BA%A6%E6%9D%9F.png" style="zoom:33%;" /></li>
<li><p>惯性滑动Fling</p>
<p>需要借助OverScroller，不过Scroller也可以，但是OverScroller还可以额外滚动，添加over值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean &#123;</span><br><span class="line">            // overX overY就是为什么使用overScroller的原因</span><br><span class="line">            if (isEnlarge) &#123;</span><br><span class="line">                overScroller.fling(offsetX.toInt(), offsetY.toInt(), velocityX.toInt(), velocityY.toInt(),</span><br><span class="line">                    -((bitmap.width * bigScale - width) / 2).toInt(), ((bitmap.width * bigScale - width) / 2).toInt(),</span><br><span class="line">                    -((bitmap.height * bigScale - height) / 2).toInt(), ((bitmap.height * bigScale - height) / 2).toInt()</span><br><span class="line">                ,300, 300)</span><br><span class="line">                //下一帧的动画的时候执行</span><br><span class="line">                postOnAnimation(FlingRunnable())</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return super.onFling(e1, e2, velocityX, velocityY)</span><br><span class="line">        &#125;</span><br><span class="line">inner class FlingRunnable : Runnable &#123;</span><br><span class="line">        override fun run() &#123;</span><br><span class="line">            if (overScroller.computeScrollOffset()) &#123;</span><br><span class="line">                offsetX = overScroller.currX.toFloat()</span><br><span class="line">                offsetY = overScroller.currY.toFloat()</span><br><span class="line">                invalidate()</span><br><span class="line">                postOnAnimation(this)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此外还需提供一个惯性滚动的刷新任务，不断调用自己，每时每刻进行刷新偏移值</p>
</li>
<li><p>双指缩放</p>
<p>这里的双指缩放并没有使用多点触摸处理，系统为我们提供了相应的API做处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inner class PhotoScaleGesture : ScaleGestureDetector.OnScaleGestureListener &#123;</span><br><span class="line">        private var initScale = 0f</span><br><span class="line">        override fun onScale(detector: ScaleGestureDetector): Boolean &#123;</span><br><span class="line">            if ((currentScale &gt; smallScale &amp;&amp; !isEnlarge) || (currentScale == smallScale &amp;&amp; !isEnlarge)) &#123;</span><br><span class="line">                isEnlarge = !isEnlarge</span><br><span class="line">            &#125;</span><br><span class="line">            // 缩放因子</span><br><span class="line">            currentScale = initScale * detector.scaleFactor</span><br><span class="line">            invalidate()</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        override fun onScaleBegin(detector: ScaleGestureDetector?): Boolean &#123;</span><br><span class="line">            initScale = currentScale</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        override fun onScaleEnd(detector: ScaleGestureDetector?) &#123; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只不过这里和普通的手势处理由冲突，只能满足一个，所以在onTouchEvent里面需要判断使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        // 响应事件优先考虑双指缩放</span><br><span class="line">        var result = scaleGestureDetector.onTouchEvent(event)</span><br><span class="line">        if (!scaleGestureDetector.isInProgress) &#123;</span><br><span class="line">            result = gestureDetector.onTouchEvent(event)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四-多点触摸事件处理"><a href="#四-多点触摸事件处理" class="headerlink" title="四.多点触摸事件处理"></a>四.多点触摸事件处理</h3><p>上述都是系统为我们提供了常用手势处理的API，而之前梳理的事件分发都是单点触摸，下面对多点触摸进行一个补充</p>
<ul>
<li><p>单点触摸在onTouchEvent中使用的是action作为分支判断，而多点触摸使用的是<code>actionMasked</code></p>
</li>
<li><p>系统会为每一根手指分配一个index和id</p>
</li>
<li><p>一根手指抬起，后续的index会往前移动，id值必须是连续的，如果id为0的手指抬起了，后面的手指的index往前移，现在又按下一根手指，那么就补齐id为0的位置进行插入</p>
</li>
<li><p>这里补充说明一下offset累积的原因，当一个手指按下时，经历过dwon事件后，会立即经历move事件，所以如果不累积上次move的距离，那么offset就会从0开始计算，重绘的时候就会出现跳动情况，这里面稍微有点绕，需要慢慢理</p>
</li>
<li><p>ACTION_DWON永远只会触发一次，而ACTION_POINTER_DOWN有多次，所以每次down事件都需要更新触摸点的位置以及offset的值，否则跳动</p>
</li>
<li><p>剩余的事情就是如何管理多指触摸，如果我们需要实现让最后一根按下的手指可以响应滑动，那么就得通过id来进行标识，每按下一根手指都更新<strong>currentId</strong>，然后在move事件中通过<strong>currentId</strong>来拿取index的值，获取x/y坐标时通过index来获取，那么此时就是根据最后一根按下的手指来进行滑动处理了</p>
</li>
<li><p>实现了按下处理的逻辑，抬起手指又该作何处理，经过实验证明抬起没有生效的手指是不会发生数组越界的异常的，比如你按下3根，那么生效的一定是最后一个手指，此时你抬起1和2是不会有影响的，因为<strong>currentId</strong>没有改变，改变的只是index，那么不是抬起1和2，而是抬起生效的手指也就是第三根手指，就会崩溃，因为我们没有更新<strong>currentId</strong>的值，此时的<strong>currentId</strong>为2(从0开始计算)，所以我们只需要处理抬起生效手指的逻辑即可</p>
</li>
<li><p>有了上面的分析，这里就简单贴一下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override fun onTouchEvent(event: MotionEvent): Boolean &#123;</span><br><span class="line">        when(event.actionMasked) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                downX = event.x</span><br><span class="line">                downY = event.y</span><br><span class="line">                lastOffsetX = offsetX</span><br><span class="line">                lastOffsetY = offsetY</span><br><span class="line">                currentId = 0</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                val index = event.findPointerIndex(currentId)</span><br><span class="line">                offsetX = lastOffsetX + event.getX(index) - downX</span><br><span class="line">                offsetY = lastOffsetY + event.getY(index) - downY</span><br><span class="line">                invalidate()</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_POINTER_DOWN -&gt; &#123;</span><br><span class="line">                val pointerIndex = event.actionIndex</span><br><span class="line">                currentId = event.getPointerId(pointerIndex)</span><br><span class="line">                downX = event.getX(pointerIndex)</span><br><span class="line">                downY = event.getY(pointerIndex)</span><br><span class="line">                lastOffsetX = offsetX</span><br><span class="line">                lastOffsetY = offsetY</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_POINTER_UP -&gt; &#123;</span><br><span class="line">                var upIndex = event.actionIndex</span><br><span class="line">                val id = event.getPointerId(upIndex)</span><br><span class="line">                if (id == currentId) &#123;</span><br><span class="line">                    if (upIndex == event.pointerCount - 1) &#123;</span><br><span class="line">                        upIndex = event.pointerCount - 2</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        upIndex++</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentId = event.getPointerId(upIndex)</span><br><span class="line">                    downX = event.getX(upIndex)</span><br><span class="line">                    downY = event.getY(upIndex)</span><br><span class="line">                    lastOffsetX = offsetX</span><br><span class="line">                    lastOffsetY = offsetY</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单说一下抬起的处理思路，如果当前抬起的id为currentId才会做处理，然后再根据当前生效手指在手指数组中的位置做处理，如果是数组末尾也就是最后一根按下的手指，那么就交给它前面的一根手指做处理，否则交给它后面的手指做处理，明白index的插入原理后，就可以随意做处理了。</p>
<p><a href="https://gitee.com/wiwiyiyi/improving-repository/commit/aaefbd048bcba786b6797addc23a66b5bc9be364">完整代码见链接</a></p>
</li>
</ul>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>多点触控很少用到吧，手势处理用的多一点，可以实现一些比较炫酷的效果。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义属性和绘制文本</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><p>我们自定义的控件，很多时候会设置图片资源、文本内容以及背景色等，显然我们不能把这些都写死，为了能够让使用者根据自己的需求以及爱好来设置这些属性，我们需要给外部提供一个可设置的接口接收用户设置的数据，然后在代码中将它们都解析取出来，并展示到界面中去，提供接口即自定义属性</p>
<h3 id="二-自定义属性的步骤"><a href="#二-自定义属性的步骤" class="headerlink" title="二.自定义属性的步骤"></a>二.自定义属性的步骤</h3><ol>
<li>在<code>values</code>文件夹下新建一个<code>Values Resource File</code>资源文件</li>
<li>通过<code>&lt;declare-styleable name=&quot;类名&quot;&gt;添加的属性&lt;/declare-styleable&gt;</code>的标签形式声明为哪个类添加属性</li>
<li>使用<code>&lt;attr name=&quot;属性名&quot; format=&quot;类型|reference&quot;/&gt;</code>来添加一个属性</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E6%AD%A5%E9%AA%A4.png"></p>
<p>以上步骤仅仅是给用户提供一个接口设置控件的属性，也就意味着这些属性仅仅在xml中，只是一些值，为了能够让他们显示到界面上去，我们还需将这些值传递到代码中，通过代码真真实实的设置控件的属性，传值这个过程称为解析属性</p>
<ol start="4">
<li>在<code>constructor(context: Context,attrs: AttributeSet):super(context,attrs)&#123;&#125;</code>在此构造函数中进行解析，因为xml中控件的所有属性都保存在<code>attrs</code>中，这也就是为什么要提供一个这样的构造函数的原因</li>
<li>通过<code>context</code>提供的<code>obtainStyledAttributes(attrs,R.styleable.类名)</code>获取到存储指定<strong>类名控件</strong>的属性数组并存储在容器中，返回类型为<code>TypedArray</code></li>
<li>将返回的对象进行保存，命名为<code>typedArray</code>，我们通过<code>typedArray</code>可以获取到自定义的属性的<strong>值</strong>，下表为<code>TypedArray</code>提供的方法，获取不同类型的属性值</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getResourceId(R.styleable.类名_属性名,提供一个默认值)</td>
<td align="center">获取一张图片的id值</td>
</tr>
<tr>
<td align="center">getDrawable(R.styleable.类名_属性名)</td>
<td align="center">获取到一张图片的drawable资源</td>
</tr>
<tr>
<td align="center">getBoolean(R.styleable.类名_属性名,提供一个默认值)</td>
<td align="center">获取一个布尔值</td>
</tr>
<tr>
<td align="center">getInt(R.styleable.类名_属性名,提供一个默认值)</td>
<td align="center">获取一个整型值</td>
</tr>
<tr>
<td align="center">getFloat(R.styleable.类名_属性名,提供一个默认值)</td>
<td align="center">获取一个浮点型</td>
</tr>
<tr>
<td align="center">getString(R.styleable.类名_属性名)</td>
<td align="center">获取一个字符串</td>
</tr>
<tr>
<td align="center">getColor(R.styleable.类名_属性名,提供一个默认值)</td>
<td align="center">获取一个颜色值</td>
</tr>
</tbody></table>
<blockquote>
<p>以上为几种常用的方法，获取一张图片最好采用<code>getResourceId</code>，因为它仅仅是一个整数值，而<code>getDrawable</code>获取的是一张图片的资源即字节，相对占用更多的空间，解析除想要的属性的值后，再把它们通过对应的<code>set方法</code>赋值给对应的控件即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private fun parseAttr(attrs: AttributeSet)&#123;</span><br><span class="line">        val typedArray:TypedArray = context.obtainStyledAttributes(attrs,R.styleable.BottomBar)</span><br><span class="line">        bgPic = typedArray.getResourceId(R.styleable.BottomBar_normalIcon,R.drawable.circle)</span><br><span class="line">        selectIcon = typedArray.getResourceId(R.styleable.BottomBar_selectIcon,R.drawable.circle_selected)</span><br><span class="line">        selectColor  = typedArray.getColor(R.styleable.BottomBar_selectColor,Color.RED)</span><br><span class="line">        Bottomtext = typedArray.getString(R.styleable.BottomBar_text)</span><br><span class="line">        normalColor = typedArray.getColor(R.styleable.BottomBar_normalColor,Color.BLACK)</span><br><span class="line">        mSelected = typedArray.getBoolean(R.styleable.BottomBar_selected,false)</span><br><span class="line">        typedArray.recycle()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>typedArray</code>使用完毕后，最好调用<code>recycle()</code>进行资源释放</p>
</blockquote>
<h3 id="三-自定义属性实战应用"><a href="#三-自定义属性实战应用" class="headerlink" title="三.自定义属性实战应用"></a>三.自定义属性实战应用</h3><p><strong>效果预览</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1.gif" style="zoom:50%;" />

<ol>
<li><p>该动画属于自定义动画，动画因子为<strong>外层圆弧的弧度</strong>，由于该动画表示的是下载比例，所以动画因子的变动范围选择<strong>0-1.0</strong>，乘以360即可。</p>
</li>
<li><p>该动画的圆环背景和前景色都可以由用户来设置，以及文字颜色等，即自定义属性。</p>
</li>
<li><p>除自定义属性外，还用到了绘制文本，绘制文本最难的点在于控制文本的位置，当画笔一旦确立，我们就可以通过画笔对象获取到字体矩阵<code>fontMetrics</code>，此矩阵包含了几个位置信息，字体底/顶部、行底/顶部、水平基准线，画笔内部可以设置文字水平居中，但垂直居中只能手动更改y坐标来实现</p>
</li>
</ol>
<p><strong>字体矩阵的位置图示</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E5%AD%97%E4%BD%93%E7%9F%A9%E9%98%B5%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<p>字体大小一旦确定，<code>ascent和descent</code>也就确定了，即字体的高度，所以y坐标加上space就能让文本垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val mtrics = textPaint.fontMetrics</span><br><span class="line">        val space = (mtrics.descent-mtrics.ascent)/2f-mtrics.descent</span><br><span class="line">        val text=&quot;$&#123;(progress*100).toInt()&#125;%&quot;</span><br><span class="line">        canvas?.drawText(text,cx,cy+space,textPaint)</span><br></pre></td></tr></table></figure>

<p><strong>小思考</strong></p>
<blockquote>
<p>前面提到过，外部提供的值，传给控件需要重写<code>set()</code>方法，并且调用<code>invalidate()</code>进行界面的刷新，那么传递属性的值需不需要进行刷新呢，答案是不需要，在<code>onCreate()</code>方法中解析xml中的控件时，还没有进行绘制，解析控件时就会将控件对应的属性全部加载出来，所以不需要进行界面的刷新，界面的刷新通常在<code>onDraw()</code>中绘制好后才会调用<code>invalidate()</code>，下面通过执行顺序的打印证实</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F.png"></p>
<p>可以看到<code>onDraw()</code>确实是在<code>setContentView(R.layout.activity_main)</code>解析完控件后才被调用的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>自定属性是自定义控件和动画中相当重要的部分，也是高级UI板块中必须掌握的，没有自定义属性，自定义的控件就失去了灵魂</p>
</blockquote>
<p><strong>代码链接</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/androidUI-circleLoad/tree/master/app/src/main/java/swu/cx/flowgroup">圆形加载进度动画</a></p>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
  </entry>
  <entry>
    <title>自定义ViewGroup引入</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E5%BC%95%E5%85%A5.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>自定义控件阶段主要是使用<code>onDraw()</code>方法进行绘制，常与自定义动画相结合，而自定义ViewGroup关键在于<strong>定规则</strong>-&gt;子控件的摆放规则，比如系统的<strong>LinearLayout</strong>，一行一行摆放或者一列一列摆放，在定义复杂规则之前，我们先改写LinearLayout找找感觉，完成<strong>底部导航栏小Demo</strong></p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F.gif" style="zoom:50%;" />

<h3 id="二-实现思路分析"><a href="#二-实现思路分析" class="headerlink" title="二.实现思路分析"></a>二.实现思路分析</h3><ol>
<li><p>结构上很直观的可以看出，该导航栏是两层LinearLayout，外层是横向布局，内层是纵向布局，本Demo中自定义了两个ViewGroup，都继承自LinearLayout，你可能会觉得外层没必要自己写，直接使用系统的，答案是不行，因为当某个标签被点击时，它本身不仅需要改变，在它之前的那个标签同样需要改变，所以我们一定需要<strong>第三者</strong>来管理所有标签，而使用系统的无法实现，另外当然还有一种思路，让<strong>MainActivity</strong>来管理所有标签，这时外层使用系统的没有问题，缺点是失去了封装的优势，并且会让MainActivity中的逻辑变得混乱，仅仅为了一个控件，不值得，所以定义两个ViewGroup是最佳的选择，而且还可以<strong>自定义属性</strong>让用户设置标签的样式，由于数量太多，本Demo中省去了</p>
</li>
<li><p>另外一个难点是外层如何传递数据给内层？一个标签不仅有图片、文字还有显示的状态，同时传递这么多不同类型的数据，我们很容易想到封装，将<strong>所有属性封装到一个数据类中进行管理</strong>，Kotlin中专门提供了一种数据类，只用于存储数据-&gt;data class，简单易操作</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data class itemModel(</span><br><span class="line">    var normalIcon:Int,</span><br><span class="line">    var selectIcon:Int,</span><br><span class="line">    var text:String,</span><br><span class="line">    var normalColor:Int,</span><br><span class="line">    var selectColor:Int,</span><br><span class="line">    var selected:Boolean</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将构造函数的参数设置为属性，便能保存下来，这就是数据模型，封装思想</p>
</blockquote>
<ol start="3">
<li><p>在什么时候将这些数据传递到内层每个标签？内层标签的初始化创建肯定在外层容器的构造方法中进行，所以当外层容器被解析完成后所有的标签实例就已经创建完毕，即当调用<code>setContentView(R.layout.activity_main)</code>后，我们才能传递数据，即有了实例对象才能设置图片和文字等资源，由于实例化标签和设置资源不是同时进行的，所以在外层容器中需要数组进行保存数据，当这个数组被赋值时，就可以设置资源，为了简便以及体现思路，重写数组变量的<code>set()</code>方法</p>
</li>
<li><p>高阶函数回调，当一个标签被点击时，首先更改上一个标签的状态，由于记录标签状态的变量<code>mSelected</code>重写了<code>set()</code>方法，而在<code>set()</code>方法中进行了更新UI，所以只需再记录当前是第几个标签即可，每个标签都有自己的<code>index</code>，其实很多时候重写<code>set()</code>方法很具优势，不仅体现思路，而且让代码简洁</p>
</li>
<li><p>外层线性布局需要给每一个标签设置<code>weight</code>比重，且值都相等，均分</p>
</li>
<li><p>当我们创建一个标签时，调用<code>addView()</code>不能在<code>apply</code>里面添加，因为标签本身就是容器，所以在<code>apply</code>内部调用的<code>addView()</code>是标签的而不是外层容器的，因此只能在<code>also</code>里面把当前标签添加进外层容器，只有单个控件才能在<code>apply</code>中调用外层容器的<code>addView()</code>，这点很重要</p>
</li>
</ol>
<h3 id="三-小结"><a href="#三-小结" class="headerlink" title="三.小结"></a>三.小结</h3><p>此Demo采用系统的布局方式仅是一个引入，综合自定义属性，还挺有意义的，毕竟绝大部分app都会有底部导航栏</p>
<p><strong>代码链接</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/androidUI-BottomTabBar/tree/master/app/src/main/java/swu/cx/learning_10_17">底部导航栏</a></p>
<h3 id="四-测量模式MeasureSpec"><a href="#四-测量模式MeasureSpec" class="headerlink" title="四.测量模式MeasureSpec"></a>四.测量模式MeasureSpec</h3><blockquote>
<p>测量模式是对控件的尺寸进行约束，有以下三种</p>
</blockquote>
<ol>
<li><p>EXACTLY</p>
<p>在xml中设置具体的值：如100dp</p>
</li>
<li><p>AT_MOST</p>
<p>不能超过某个值：match_parent、wrap_content</p>
</li>
<li><p>UNSPECIFIED</p>
<p>不具体的：无限、滚动，常用于ScrollView、RecyclerView，很少使用此测量模式</p>
</li>
</ol>
<h3 id="五-从测量模式中获取尺寸"><a href="#五-从测量模式中获取尺寸" class="headerlink" title="五.从测量模式中获取尺寸"></a>五.从测量模式中获取尺寸</h3><blockquote>
<p><code>MeasureSpec</code>是一个整数，4字节，32位，由于它的范围很大，单纯就屏幕尺寸来说绰绰有余，所以它不仅能存储控件的大小，还能存储控件的测量模式，测量模式仅占高两位</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public static int getMode(int measureSpec) &#123;</span><br><span class="line">            //noinspection ResourceType</span><br><span class="line">            return (measureSpec &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public static int getSize(int measureSpec) &#123;</span><br><span class="line">            return (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>MODE_SHIFT</code>的值为30，<code>MODE_MASK</code>的二进制值为<strong>11左移30位</strong></p>
<p><strong>下面通过图解来理解<code>getMode</code>和<code>getSize</code></strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.png"></p>
<blockquote>
<p>只需知道<code>MeasureSpec</code>的存值和取值原理即可，存值与上图同理</p>
</blockquote>
<h3 id="六-LayoutParams与xml中layout-width-height的关系"><a href="#六-LayoutParams与xml中layout-width-height的关系" class="headerlink" title="六.LayoutParams与xml中layout_width/height的关系"></a>六.LayoutParams与xml中layout_width/height的关系</h3><blockquote>
<p><code>LayoutParams</code>-&gt;布局参数，任何一个控件都有一个<code>layoutparams</code>里面保存了你在xml中设置的<code>layout_width/height</code>的具体值，可通过<code>width和height</code>获取，下面通过源码分析它和xml中布局宽高的关系</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public LayoutParams(Context c, AttributeSet attrs) &#123;</span><br><span class="line">            TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.ViewGroup_Layout);</span><br><span class="line">            setBaseAttributes(a,</span><br><span class="line">                    R.styleable.ViewGroup_Layout_layout_width,</span><br><span class="line">                    R.styleable.ViewGroup_Layout_layout_height);</span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>LayoutParams</code>内部是通过解析xml中对应的属性来获取到控件的<code>layout_width/height</code>，<code>layoutparams</code>在自定义ViewGroup中会使用到，此处只需明白其中的<code>width和height</code>是如何获取到的即可</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>在以后实际开发中，自定义ViewGroup很多时候都会采取底部导航栏的形式继承系统的布局方式，毕竟UI设计师的想法是有限的，建议先掌握继承系统的布局写法，近年兴起的流式布局会在下一篇文章中讲述，</p>
</blockquote>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义ViewGroup</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面对自定义ViewGroup做了一个简单的引入，本文将详细讲解真正自定义ViewGroup的三种情况</p>
</blockquote>
<ol>
<li>父容器尺寸确定，需要根据父容器的尺寸确定子控件的尺寸</li>
<li>子控件尺寸确定，需要确定父容器的尺寸</li>
<li>子控件和父容器尺寸都不确定，先测量子控件，在确定父容器尺寸</li>
</ol>
<ul>
<li><p>一个ViewGroup添加控件的具体流程分5步</p>
<ol>
<li><p>通过<code>super.onMeasure(widthMeasureSpec, heightMeasureSpec)</code>拿到容器本身的限制，即预测量容器自身</p>
</li>
<li><p>测量每个子控件的尺寸<code>measureChildren()</code>、<code>measure()</code></p>
</li>
<li><p>在<code>onMeasure()</code>中定排列规则</p>
</li>
<li><p>计算当前容器的最终尺寸</p>
</li>
<li><p>摆放(布局)控件</p>
</li>
</ol>
</li>
</ul>
<h3 id="二-第一种情况实例"><a href="#二-第一种情况实例" class="headerlink" title="二.第一种情况实例"></a>二.第一种情况实例</h3><p>当父容器大小确定后，子控件的大小由我们自己确定，随着子控件的数量增多，每个子控件的尺寸肯定越来越小，实现demo的效果图如下</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5.gif"></p>
<p>过程分析：</p>
<ol>
<li>由于父容器的宽高是确定的，并且布局规则是<strong>每行两个子控件，且相同</strong>，所以子控件的宽度是确定的</li>
<li>而子控件的高度取决于子控件的数量，具体为有多少行子控件，<code>val childHeight = (parentHeight-(row+1)*space)/row</code></li>
<li>计算出子控件的尺寸后，还得获取<code>MeasureSpec</code>，最后测量每一个子控件，本质为储存每一个子控件的尺寸</li>
<li>在布局的时候，注意的一点是<strong>什么时候应该换行，以及换行时，</strong><code>left</code><strong>和</strong><code>top</code><strong>的变化是怎样的</strong>，也就是按照布局规则进行摆放子控件</li>
</ol>
<h3 id="三-第二种情况实例"><a href="#三-第二种情况实例" class="headerlink" title="三.第二种情况实例"></a>三.第二种情况实例</h3><p>当我们在xml配置文件中，确定控件的大小为多少dp，且容器的大小为<code>wrap_content</code>，这时需要通过子控件的大小确定父容器的大小，demo效果图如下：</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%83%85%E5%86%B5.gif"></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%89%8B%E6%9C%BA%E6%BC%94%E7%A4%BA.gif" style="zoom:50%;" />

<p>过程分析：</p>
<ol>
<li>首先搭建框架，我们需要两个变量记录容器最终的大小，最后通过<code>setMeasuredDimension(resultWidth,resultHeight)</code>保存尺寸</li>
<li>中间过程便是通过所有子控件的尺寸来确定父容器的尺寸，下面先按照之前的写法进行测量所有子控件，我们可以通过<code>layoutParams</code>获取子控件的尺寸，然后获取<code>MeasureSpec</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val child = getChildAt(0)</span><br><span class="line">val lp = child.layoutParams</span><br><span class="line">val childWidhSpec = MeasureSpec.makeMeasureSpec(lp.width,MeasureSpec.EXACTLY)</span><br><span class="line">val childHeightSpec = MeasureSpec.makeMeasureSpec(lp.height,MeasureSpec.EXACTLY)</span><br><span class="line">for (i in 0 until childCount)&#123;</span><br><span class="line">     getChildAt(i).measure(childWidhSpec,childHeightSpec)</span><br><span class="line">        &#125;        </span><br></pre></td></tr></table></figure>

<p>​    而以上代完全可以通过一行代码来替换<code>measureChildren(widthMeasureSpec,heightMeasureSpec)</code>，所以对于在xml对子控件设置固定大小的情况下，使用该方法更加简便，可以去查看<code>measureChildren()</code>的内部实现，系统帮我们完成了一系列繁杂的操作</p>
<ol start="3">
<li>由于该demo中的子控件都是规则的，所以测量起来十分方便，只需知道有多少行子控件即可，布局的时候和第一种情况几乎相同</li>
</ol>
<h3 id="四-第三种情况-gt-流式布局"><a href="#四-第三种情况-gt-流式布局" class="headerlink" title="四.第三种情况-&gt;流式布局"></a>四.第三种情况-&gt;流式布局</h3><p>当子控件和父容器都是<code>wrap_content</code>的时候，特别是需要添加间距时，显得稍微复杂一点，下面以近年来兴起的<strong>流失布局</strong>为例分析这种情况，demo效果如下</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80.jpg" style="zoom: 33%;" />

<p>以上模拟的是网易云搜索音乐时可以看到的一个历史记录，采用的是流式布局，给<code>TextView</code>设置圆角背景后效果还不错，如何设置请看这篇博客<a href="https://www.jianshu.com/p/a2131907a0f4">关于View控件详情以及设置圆角背景</a></p>
<p>过程分析：</p>
<ol>
<li>首先依旧搭好框架，先获取容器自身的尺寸以及<code>MeasureSpec</code>，以及设置尺寸，此处需要根据父容器的<code>MeasureSpec</code>进行设置测量尺寸</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resultWidth = if (parentWidhtMode==MeasureSpec.EXACTLY) parentWidth else resultWidth</span><br><span class="line">resultHeight = if (parentHightMode==MeasureSpec.EXACTLY) parentHeight else resultHeight</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>因为我们需要为每一个子控件设置外间距，所以不能采取系统的测量方式即<code>measureChildren</code>或者<code>measureChild</code>，下面给出源码分析</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">        int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">        int specSize = MeasureSpec.getSize(spec);</span><br><span class="line">		//-------------在父容器的约束下，必须减去外间距，剩余的空间才能用于摆放子控件--------------------------</span><br><span class="line">        int size = Math.max(0, specSize - padding);</span><br><span class="line"></span><br><span class="line">        int resultSize = 0;</span><br><span class="line">        int resultMode = 0;</span><br><span class="line"></span><br><span class="line">        switch (specMode) &#123;</span><br><span class="line">        // Parent has imposed an exact size on us</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size. So be it.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&#x27;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent has imposed a maximum size on us</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // Child wants a specific size... so be it</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size, but our size is not fixed.</span><br><span class="line">                // Constrain child to not be bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&#x27;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent asked to see how big we want to be</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // Child wants a specific size... let him have it</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size... find out how big it should</span><br><span class="line">                // be</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size.... find out how</span><br><span class="line">                // big it should be</span><br><span class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        //noinspection ResourceType</span><br><span class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此方法是系统内部测量子控件必定会调用的方法，我们据此进行模仿，代码中<strong>虚线</strong>部分解释在设置外间距的情况下，子控件能用的剩余空间为多少，试想如果我们采用系统的<code>measureChild()</code>方法，那么参数中的<code>padding</code>的值为0，又由于父容器的模式为<code>AT_MOST</code>，子控件也为<code>AT_MOST</code>，根据<code>switch</code>语句容易得出，子控件的最终大小为<code>size</code>也就是父容器的大小，假设只添加一个控件，那么它的宽度即为父容器的宽度，那我们在布局的时候，设置左右外间距，就意味着，真实布局大小为<code>2*space+width</code>，而父容器的大小同理可以得出是屏幕宽度，那岂不就是超出了整个屏幕的宽度了吗，显然，这太糟糕了，所以我们只能自己通过<code>measure()</code>方法存储子控件的尺寸，而所需的<code>MeasureSpec</code>则通过<code>getChildMeasureSpec</code>获取，手动设置间距，xml中的尺寸可以通过<code>layoutParams</code>拿到，这便是手动添加间距的方式</p>
</blockquote>
<ol start="3">
<li>在测量的同时，制定布局方案，这就好比绘制造房子的图纸，而<code>onLayout</code>便相当于根据图纸造房子，即根据已设置好的布局规则摆放子控件，下面通过图解说明摆放规则</li>
</ol>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80.png"></p>
<blockquote>
<p>设置多个数组保存数据的作用就是保存布局规则，在<code>onLayout()</code>中只需要取出数组中的数组摆放控件即可，所以<code>onMeasure()</code>中制定规则更加繁琐</p>
</blockquote>
<p><strong>踩坑点分析</strong></p>
<p>①. 跳出for循环后，其实还有最后一行没有添加到<code>allLineChildren</code>中去，因为最后一行通常不满足换行条件，所以进行判断添加</p>
<p>②. <code>allLineChildren</code>和<code>lineHeights</code>两个属性变量不要在声明时初始化，因为<code>onMeasure()</code>方法会被调用两次，导致重复添加，所以其初始化必须在<code>onMeasure()</code>中</p>
<p>③. <code>lineChildren</code>在换行时不能调用<code>clear()</code>清空，而是创建一个新的实例对象，否则只会添加最后一行的控件</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>自定义ViewGroup的测量与布局不会超出以上三种情况，最重要的是流式布局，建议多写几遍，熟悉自定义规则的步骤，写完三种，发现归根结底，子控件的测量都可使用<code>measure()</code>来实现，自己制作<code>MeasureSpec</code>或者通过系统的方法获取，测量模式很重要，子控件和父容器的尺寸都和此挂钩，一一映射</p>
</blockquote>
<p><strong>代码链接</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/defineViewGroup/tree/master/app/src/main/java/swu/cx/defineviewgroup">自定义ViewGroup</a></p>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义控件与动画</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E4%B8%8E%E5%8A%A8%E7%94%BB.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>之前在简书中写到自定义动画是建立在自定义控件的基础上的，可以理解为自定义的控件本身一块画布(一个矩形区域)，而我们通过onDraw()方法在上面绘制<strong>动态变化更新的图案</strong>即形成了一个全新的控件，同时那些全新的图案便是自定义动画</p>
</blockquote>
<h3 id="二-实现思路"><a href="#二-实现思路" class="headerlink" title="二.实现思路"></a>二.实现思路</h3><p>任何一个自定义的动画都至少有一个<strong>动画因子</strong>，动画的连续变化过程都是由于某个变量的连续改变而发生，称这个变量为动画因子</p>
<p>自定义动画的过程如下：</p>
<ol>
<li> 拆分为多个部分</li>
</ol>
<p>   当你看到一个动画时，首先应该分析它的组成部分，包含哪些几何图形</p>
<ol start="2">
<li><p>寻找关系</p>
<p>这些几何图形之间有没有某种联系，比如两个图形同时出现、同时消失，或者接连出现</p>
</li>
<li><p>每个部分的绘制</p>
<p>分析完毕各部分的关系后便可开始绘制</p>
</li>
<li><p>  寻找动画因子</p>
</li>
</ol>
<p>   先进行绘制初始状态，然后寻找动画因子，让它的值在一个范围内不断变化，并把值传递给起始状态，刷新界面</p>
<ol start="5">
<li>创建动画<br>使用<code>ValueAnimator.ofFloat(value1,value2)</code>不断产生value1和value2之间连续变化的值，此步骤就是让动画因子连续变化，并动态地传值刷新界面</li>
</ol>
<h3 id="三-实战讲解"><a href="#三-实战讲解" class="headerlink" title="三.实战讲解"></a>三.实战讲解</h3><blockquote>
<p>只有将自定义动画应用于实际项目中才会体会到如何拆分动画以及寻找动画因子</p>
</blockquote>
<ol>
<li>贪吃蛇加载</li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%90%83%E5%8A%A8%E7%94%BB.gif" style="zoom: 50%;" />

<blockquote>
<p>此动画有两个动画因子，一是大圆弧张开的角度，二是小球的x坐标，不断改变大圆弧张开的角度<strong>angle</strong>便可实现张闭合嘴，不断改变小球的x坐标，便可实现移动效果，显然这两个动画是同时进行的</p>
</blockquote>
<p><strong>关键点是计算出大球和小球的半径，相对于控件的宽高而言</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (width&gt;=height)&#123;</span><br><span class="line">            radius=height/6f</span><br><span class="line">            //如果宽度小于8.5个R</span><br><span class="line">            if (8.5*radius&gt;width)&#123;</span><br><span class="line">                radius=width/8.5f</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            radius=width/8.5f</span><br><span class="line">            //如果高度小于6个R</span><br><span class="line">            if (6*radius&gt;height)&#123;</span><br><span class="line">                radius=height/6f</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mouseRadius=3f*radius</span><br><span class="line">        space=0.5f*radius</span><br></pre></td></tr></table></figure>

<p><strong>相对尺寸分析</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E8%B4%AA%E5%90%83%E5%B0%BA%E5%AF%B8%E5%88%86%E6%9E%90.png"></p>
<ol start="2">
<li>脉搏跳动加载动画</li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E8%84%89%E6%90%8F%E8%B7%B3%E5%8A%A8.gif" style="zoom:50%;" />

<blockquote>
<p>此动画结构相对简单，仅仅是三个圆的缩放效果，但它们并不是同时开始，关键点是为每一个动画设置延迟加载动画，动画因子是圆的半径</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (width&gt;=height)&#123;</span><br><span class="line">            radius=height/2f</span><br><span class="line">            if (7*radius&gt;width)&#123;</span><br><span class="line">                radius=width/7f</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            radius=width/7f</span><br><span class="line">        &#125;</span><br><span class="line">        cx=(width-7*radius)/2f+radius</span><br><span class="line">        cy=height/2f</span><br></pre></td></tr></table></figure>

<p><strong>尺寸分析</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E8%84%89%E6%90%8F%E8%B7%B3%E5%8A%A8%E5%88%86%E6%9E%90.png"></p>
<blockquote>
<p>以上两个动画稍微麻烦一点的是确定几何图形的相对控件的尺寸，最终的效果还是很棒的</p>
</blockquote>
<ol start="3">
<li>特色进度条加载</li>
</ol>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E7%89%B9%E8%89%B2%E8%BF%9B%E5%BA%A6%E6%9D%A1.gif" style="zoom:50%;" />

<blockquote>
<p>此动画的动画因子有两个，一是<strong>圆角矩形的圆角半径</strong>，它变动的范围是<strong>0-width/2</strong>，二是圆角矩形的宽度，此宽度是由left和right共同决定的，因此只需动态改变left的值即可，变动范围是<strong>0-(width-height)/2</strong>，两个动画是先后执行</p>
</blockquote>
<p>当圆角矩形缩成一个圆时，会打√或者打×，这是由下载成功或者失败来确定的，打√或者打×绘制路径即可</p>
<p><strong>打√尺寸分析</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%89%93%E2%88%9A%E5%88%86%E6%9E%90.jpg" style="zoom: 80%;" />

<p><strong>打×分析</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%89%93%C3%97%E5%88%86%E6%9E%90.jpg" style="zoom:80%;" />

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>以上下载或者加载控件都会通过高阶函数回调下载状态以及等待状态，主要是寻找动画因子、几何图形组成成分、使用ValueAnimator不断产生值，刷新界面，当给动画因子赋值时就会刷新，所以选择重写<code>set()</code>方法，这样做很方便</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义进度的变化因⼦ 0-1.0</span><br><span class="line">    var progress = 0f</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            //刷新</span><br><span class="line">            invalidate()</span><br><span class="line">            //开启完成动画</span><br><span class="line">            if (progress == 1.0f) &#123;</span><br><span class="line">                startFinishAnim()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果看到心仪的动画效果，可以尝试跟着以上步骤将它写出来，相信最终的效果肯定很棒</strong></p>
<p><strong>代码链接</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/androidUI-waitLoading/tree/master/app/src/main/java/swu/cx/test">贪吃和脉搏跳动动画</a></p>
<p><a href="https://gitee.com/wiwiyiyi/andoridUI-progressBar/tree/master/app/src/main/java/swu/cx/progressbar">特色进度条动画</a></p>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义控件实战</title>
    <url>/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%AE%9E%E6%88%98.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>前面已经详细介绍了自定义绘制各种图案，下面通过一个解锁界面的小Demo进行知识点的巩固</p>
</blockquote>
<p><strong>效果图</strong></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Lock/Lock.gif" style="zoom:40%;" />

<p>实现手势滑动解锁的功能有三种思路：</p>
<ol>
<li>第一种是用一个个的ImageView通过ConstarintLayout约束布局形成九宫格，并且线条图片也是提前布局好的，这种方式最简单，逻辑很少，但缺点也很明显：移植复用性太差，除了复制代码还得拷贝图片，并且布局不易管理，不推荐这种方式</li>
<li>自定义控件：通过绘制的方式实现解锁效果，好处明显-&gt;不需要图片占内存，移植复用方便，直拷贝类即可，就像系统的控件一样，直接拿来用就好，很简单，但内部实现的逻辑稍微复杂</li>
<li>自定义ViewGroup：暂时不考虑，因为ViewGroup主要是用来定义自己的Layout规则，通常不涉及绘制，从实现的难易程度来说，自定义控件是最好的方式了</li>
</ol>
<blockquote>
<p>在此提供1和2两种方式实现解锁功能，对比一下就知道自定义控件是有多好用了</p>
</blockquote>
<h3 id="二-通过图片实现解锁"><a href="#二-通过图片实现解锁" class="headerlink" title="二.通过图片实现解锁"></a>二.通过图片实现解锁</h3><p>首先我们得准备好解锁功能需要用到的图片素材，我将其放在百度网盘上</p>
<p><a href="https://pan.baidu.com/s/1WtXT-aD68h-GjlDWfQW0OQ">图片链接</a><br>提取码：tf9o </p>
<blockquote>
<p>为让所有布局图片便于管理，选择专门用一个容器来承载所有ImageView，这样的好处是让所有布局图片形成一个整体，此种方式布局稍微麻烦一点，用好引导线会方便很多</p>
</blockquote>
<p><strong>布局效果展示</strong></p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Lock/Lock1.png"></p>
<ul>
<li><p>基本思路是先把选中之后的红点和线布局好并设置为不可见，最关键的是为每一个点和每条线设置一个tag值，这样通过点的tag线性运算唯一确定一条线并让这条线可见，实现两点连线，设置tag值同样用于记录密码，手势滑动解锁本质也会归结到普通的数字密码，手势仅仅是一个界面，我们需要将滑过的点转换成一串密码，这样才能进行密码的判断</p>
</li>
<li><p>手势滑动和代码逻辑之间的桥梁是<code>onTouchEvent()</code>这个事件监听的方法，详情请看这篇文章<a href="https://www.jianshu.com/p/60656d5dc863">触摸事件的监听</a></p>
</li>
<li><p>此外还需要一个记录点亮过的点和线的数组，因为都是ImageView，所以可以统一管理，当手指离开屏幕后，需要对这些数据还原</p>
</li>
</ul>
<h3 id="三-自定义控件实现解锁"><a href="#三-自定义控件实现解锁" class="headerlink" title="三.自定义控件实现解锁"></a>三.自定义控件实现解锁</h3><p>解锁模块，我们只需要重写<code>onDraw()</code>方法即可，因为全过程只需要不断绘制、刷新界面即可</p>
<p><strong>难点分析:</strong></p>
<ol>
<li>为了能够动态对九个点进行操作，比如点亮后在中心画一个同心圆，以及清空操作，都是以一个点为对象进行操作，很容易想到对它进行封装，封装每个点应该具有的属性，如每个点都会有一个tag进行记录密码</li>
<li>当我们想在解锁这个控件内部调用其他控件，比如密码错误应该通过<strong>TextView</strong>提示用户，显然我们只能通过Activity这个中介来实现，容易想到事件回调，java中采用接口进行回调，优点是<strong>复用性很强</strong>，但缺点也很明显，耦合性很高，在kotlin中高阶函数回调完美解决这个问题，强烈推荐高阶函数回调，<strong>三种回调方式详情点击前往查看</strong></li>
</ol>
<p><a href="https://wiwiyiyi.com/%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E8%AF%A6%E8%A7%A3/#more">三种事件回调对比分析</a></p>
<p><strong>基本思路</strong></p>
<ol>
<li>首先得确定九个点相对于控件的尺寸，同样的九宫格这个正方形区域也和控件的宽高有关，在<code>onsizechanged()</code>此方法中已经能够获取到控件的尺寸，在此方法中我们就得确定好九个点圆心的位置以及其他信息</li>
<li>第一步初始化基本信息后，就可以在<code>onDraw()</code>方法进行绘制九个点，并且还需提前绘制线，点亮点内部的同心圆，这些都得提前绘制好，在后续操中只需调用<code>invalidate()</code>进行界面的刷新即可</li>
<li>重写<code>onTouchEvent()</code>方法，在内部实现手势滑动等监听，判断触摸点是否在某个点内，通过rect矩形区域来判断，每个点都会有自己的矩形区域，并且是自己的属性，方便使用</li>
<li>此处除了将Dot类进行封装外，还将Dot类嵌套在解锁控件内部，进一步封装</li>
</ol>
<p><strong>附上代码链接：</strong></p>
<p><a href="https://gitee.com/wiwiyiyi/androidUI-Lock1/tree/master/app/src/main/java/swu/cx/lock">使用图片实现解锁</a></p>
<p><a href="https://gitee.com/wiwiyiyi/androidUI-defineLock/tree/master/app/src/main/java/swu/cx/definelock">自定义控件实现解锁</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>对比以上两种解锁方式，你会发现自定义控件的强大之处，可以设计你想要的图案以及动画效果，特好用</p>
</blockquote>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>Android高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>被吊打的第一天</title>
    <url>/%E8%A2%AB%E5%90%8A%E6%89%93%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>实习生活开始有几天了，近两天接触到了UI相关的bug修复，因为维护的是近十年的老项目，所以对项目结构一脸懵逼，大量的时间花在了找代码位置的时间上，虽然看似很简单，但却弄复杂了，瞎折磨了近两天，结果被别人20分钟搞定，有点难以接受，也因此多了一些感悟吧，码代码这么久，头一回被吊打，[泪崩]</p>
</blockquote>
<h3 id="二-具体任务分析"><a href="#二-具体任务分析" class="headerlink" title="二.具体任务分析"></a>二.具体任务分析</h3><p>接到的任务有以下三个：</p>
<ol>
<li>更改某处图片(主要是通过工具找位置)</li>
<li>扩大点击事件的响应范围</li>
<li>更改icon以及大小等等</li>
</ol>
<p>总的来说，麻烦的就第二和第三，第三个任务是真的磨人，UI设计的小姐姐把图纸发给你，你真的就可能很懵逼，毕竟是两个维度，她不会将view的嵌套关系给你画出来，只会给一个大概，然后你如果对层层嵌套的布局不熟悉的话，是真的要吐血，因为你在设置间距和大小的时候总会发现位置不对或者超出视图范围，哎，真的难顶，另外，你如果不会使用工具来抓捕视图的话，真的会徘徊在源码的世界，甚至迷失自我。</p>
<p><strong>重点：</strong>第二个任务其实很简单，但就是容易踩坑，突然发现自己很久没有接触UI方面的东西，很多都有点手生，扩大响应范围，我最原始的想法是将零零散散的view通过一层布局包裹来实现，这样点击整个大的嵌套布局就可以轻松实现功能，然后很开心，结果导师说不推荐这样做，毕竟多一层嵌套会多一些视图上的计算以及事件传递啥的，效率不高，虽然这是一个简单又傻冒的想法，后来我折磨了一个晚上，通过事件拦截的方式处理你需要响应外的区域，如果落在外面就直接拦截并消费，不需要再传递给子view，但太久没用，所以调试了很久，踩了很多坑，建议对<code>OnTouchEvent</code>、<code>onInterceptTouchEvent</code>足够了解以及能够使用，另外就是矩形区域的使用，判断触摸点是否在区域内，这都是很基本的了，最后我实现了这个功能。可第二天导师说不行，区域还不够，其实中间有一个bug，我比较投机取巧的解决了，但确实不够灵活，我giao，然后继续看代码流程，看UI，当我总算弄清楚所有布局的时候，却发现无法解决，导师也是这样说，所以我干了个寂寞，再到最后，我的布局更改有问题，代码实现不符规定，唉，奈何时间紧，只能看着导师一顿操作猛如虎，20分钟搞定，直接喷血了。。。。</p>
<h3 id="三-第一次改bug小总结"><a href="#三-第一次改bug小总结" class="headerlink" title="三.第一次改bug小总结"></a>三.第一次改bug小总结</h3><p>看着导师的资深操作，我看呆了，当然了，他对项目整体的把握没得说，所以上来直接开改，其实改UI这种事情一定要落到实处，踏踏实实去做，一点点修改，有局部观的同时要顾及总体，所以你看到尺寸并非就是你要设置的尺寸，你得根据层层嵌套来分析到底需要预留多少才能得出实际应该设置多少的值，我缺少的就是总体观，做的很随意，所以处处都不对，唉，确实挺惨，得好好改改。另外就是，第二处bug根本就不需要做事件拦截，只需要给整个大的view添加一个点击事件，然后再给局部不需要响应的区域添加一个空的点击事件，相当于直接消费了，就不会回传到根视图，只觉得这种思想很牛逼，所以有空再把事件传递机制好好看看。只觉得刚来就有点心浮气躁，不过最近确实烦心吧，本来就是一个小菜鸟，还是得虚心学习，但被吊打还是得习惯。</p>
<h3 id="四-推荐使用的视图分析小工具"><a href="#四-推荐使用的视图分析小工具" class="headerlink" title="四.推荐使用的视图分析小工具"></a>四.推荐使用的视图分析小工具</h3><p>在Android Studio提供了一个非常nice的工具<strong>Legacy Layout Inspector</strong>，连上你的手机，就可抓捕当前的页面，你可以下拉进行选择，因为有的时候会有Dialog之类，这个也是可以抓捕的，具体操作流程如下：</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/as%E8%A7%86%E5%9B%BE%E6%8A%93%E6%8D%95%E5%B7%A5%E5%85%B7.png" style="zoom:40%;" />

<p>然后在Tools工具中就可以看到了，我觉得对实习小白来说真的是一个非常nice的工具，至少你不会因为看不懂界面布局而头疼，也不会因为找不到某个控件id而发愁</p>
<p>然后就是开发者选项中也有一个非常好用的工具</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%AE%9E%E4%B9%A0%E6%88%90%E9%95%BF%E9%9B%86/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.jpg"></p>
<p>你打开指针位置显示和边界布局，也可以清晰的看到页面中的布局是怎样的，就这两个工具已经可以供你快速熟悉公司项目了，只能说得心应手，很爽</p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>如果一个变量的改变会引起某些地方的逻辑处理，即观察这个变量，这时候就需要用到观察者模式，就跟平时的接口回调差不多，只是这里可以处理多个回调响应</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>顾客都很喜欢芒果，只可惜库存不够，所以当芒果到货的时候，需要通知所有关心它的顾客来购买，所以需要在芒果的实体类内部注册多个顾客监听</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Attentions &#123;</span><br><span class="line">    //关注客户列表</span><br><span class="line">    protected List&lt;Observer&gt; observers = new ArrayList();</span><br><span class="line"></span><br><span class="line">    //关注顾客</span><br><span class="line">    public void add(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //取消关注</span><br><span class="line">    public void remove(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //发通知</span><br><span class="line">    public abstract void notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line">public interface Observer &#123;</span><br><span class="line">    void update();</span><br><span class="line">&#125;</span><br><span class="line">public class MangoAttention extends Attentions&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        //遍历观察者集合，调用每一个顾客的购买方法</span><br><span class="line">        for(Observer obs : observers) &#123;</span><br><span class="line">            obs.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //芒果到货了</span><br><span class="line">    public void perform()&#123;</span><br><span class="line">        this.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CustomerObserver implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public CustomerObserver(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(name + &quot;购买青芒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用</span><br><span class="line">MangoAttention attentions = new MangoAttention();//目标</span><br><span class="line">attentions.add(new CustomerObserver(&quot;deer&quot;));</span><br><span class="line">attentions.add(new CustomerObserver(&quot;james&quot;));</span><br><span class="line">attentions.add(new CustomerObserver(&quot;lison&quot;));</span><br><span class="line">attentions.add(new CustomerObserver(&quot;mark&quot;));</span><br><span class="line">//到货</span><br><span class="line">attentions.perform();</span><br></pre></td></tr></table></figure>

<p>简单说就是在被观察者中注册观察者</p>
<p>其实JDK本身就提供了这样的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Mango extends Observable &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Mango(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //芒果到货了</span><br><span class="line">    public void perform()&#123;</span><br><span class="line">        this.setChanged();</span><br><span class="line">        this.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者代码一模一样，但是JDK提供的被观察者内部提供了线程安全的注册方式，所以更推荐使用JDK提供的观察者方式，还省去了自己创建接口的过程</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>观察者模式使用广泛，比如LiveData，理解起来不难，就好比接口回调时，谁想调用谁差不多</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>本文介绍的装饰模式使用很广泛，简单说，就是在父类的基础上新增自己的操作</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>在打包水果的过程中会有新增防伪标签、加急标签等各式各样的附加品，也就是在打包的基础上新增一个过程</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF.png" style="zoom:50%;" />

<p>其实根据描述也能大概知道装饰模式的一些流程，在调用附加功能前，需要先调用原本父类的方法，这也就是扩展</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class BagDecorator(private val bag: Bag): Bag&#123;</span><br><span class="line">    override fun packageFruit(fruit: Fruit) &#123;</span><br><span class="line">        bag.packageFruit(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class CheckedBagDecorator(bag: Bag): BagDecorator(bag) &#123;</span><br><span class="line">    override fun packageFruit(fruit: Fruit) &#123;</span><br><span class="line">        super.packageFruit(fruit)</span><br><span class="line">        check()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun check() &#123;</span><br><span class="line">        print(&quot;打上防伪标识&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">val factory = AppleFactoryImpl()</span><br><span class="line">val bag = CheckedBagDecorator(factory.getBag())</span><br><span class="line">bag.packageFruit(factory.getFruit())</span><br></pre></td></tr></table></figure>

<ol>
<li>和普通的Bag一样，首先实现Bag接口，因为是在打包的基础上添加功能，所以需要持有一个被包装对象即Bag的实现类的引用</li>
<li>具体的装饰类会传入被包装对象，同时扩展打包的方法，先执行被包装对象，再是扩展功能</li>
</ol>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>装饰器模式就是透明化的增加功能，体会抽象装饰器和被包装对象的地位是平等的，具体怎么装饰(扩展功能)是由其子类来扩展，因为只是扩展，所以要保证原有功能不变，即需要组合</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍计数排序，它是非比较排序，同时也是桶排序的一种，计数排序应用不是很广泛，只在某种特定范围条件下使用，比如某大型企业数万名员工年龄排序，以及如何快速获取高考名次，虽然数量比较多，但是其中值的取值范围比较小</p>
</blockquote>
<h3 id="二-计数排序原理以及代码实现"><a href="#二-计数排序原理以及代码实现" class="headerlink" title="二.计数排序原理以及代码实现"></a>二.计数排序原理以及代码实现</h3><p>首先上图进行理解</p>
<p><img src="https://img-blog.csdn.net/20180924230309226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JvY2xpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<blockquote>
<p>根据动图展示，发现原理很简单，没有进行比较，首先根据值的取值范围创建一个count数组，通过某种映射关系可以建立值和count数组下标一一对应，该数组保存的是原始数组中每个值出现的次数，然后遍历原始数组，通过映射关系找到该值对应的数组下标，并且count数组中对应的值+1，直到遍历完毕，接着创建一个和原始数组长度相同的result数组，遍历count数组，通过下标值还原真实值，然后填入到result数组中，出现了多少次便填入几次</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void countSort(int[] arr)&#123;</span><br><span class="line">        int[] tempArray = new int[arr.length];</span><br><span class="line">        int[] countArray = new int[10];</span><br><span class="line">        for(int i= 0;i&lt; arr.length;i++)&#123;</span><br><span class="line">            countArray[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i= 0, k = 0;i&lt; countArray.length;i++)&#123;</span><br><span class="line">            while (countArray[i]-- &gt;0) tempArray[k++] = i;</span><br><span class="line">        &#125;     </span><br><span class="line">        for (int temp: tempArray) &#123;</span><br><span class="line">            System.out.print(temp+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//数据测试</span><br><span class="line">int[] data = &#123;7,2,3,4,5,9,1,2,4,1,3,5,7,8,9,4,6,7,1,5,2,3,5,4,4,6,1,5,8,2&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是基本的算法实现，但是该算法是不稳定的，因为排序的是整型数据，并且范围小，正好可以用元素值作为count数组的下标，但在写入最终的数组中时根本就没有管相同元素的相对位置，仅仅看重同一个元素出现了几次，下面对此算法做出改进，并将基础数据类型换成类类型，模拟实际情况</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static  void countSortObj (Student[] arr)&#123;</span><br><span class="line">        Student[] tempArray = new Student[arr.length];</span><br><span class="line">        int[] scoreCountArray = new int[10];</span><br><span class="line">        for(int i=0;i&lt; tempArray.length;i++)&#123;</span><br><span class="line">            scoreCountArray[arr[i].score]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt; scoreCountArray.length;i++)&#123;</span><br><span class="line">            scoreCountArray[i] = scoreCountArray[i]+scoreCountArray[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = arr.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">            tempArray[--scoreCountArray[arr[i].score]] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; tempArray.length; i++) &#123;</span><br><span class="line">            System.out.print(tempArray[i]+&quot; &quot;);</span><br><span class="line">            if ((i+1)%3==0)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8Fshow.png"></p>
<p>为了方便看效果，此处使用序数词演示，很明显，此算法是稳定的，实例中根据高考分数查看排名也可使用该算法</p>
<blockquote>
<p>算法改进之处：同样首先处理生成count数组，不同的是此处又在count数组的基础上做了累加数组，该处理不仅可以保存元素出现的次数，还可以保存它们的相对位置，但最后一步写入数组时必须将原数组从末尾开始遍历，下面通过图来解释</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png"></p>
<p>相信再结合代码理解会容易很多，实在佩服这个算法，妙啊！</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><strong>要实现稳定的话，使用改进后的累加数组计数</strong></p>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>访问者模式稍稍有点绕，它的应用场景是针对一个集合中存在不同类型的对象，它们有共同的父类，如果说只是简单的通过方法参数重载的方式来遍历这个集合中的元素，都会统一当成它们的父类类型类处理，无法识别具体的类型</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF.png"></p>
<p>现在需要统计库存中的所有水果总价格，很容易想到直接遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Visit &#123;</span><br><span class="line"></span><br><span class="line">	//苹果计价</span><br><span class="line">	public int sell(Apple apple)&#123;</span><br><span class="line">		System.out.println(&quot;apple&#x27;s price: ￥50&quot;);</span><br><span class="line">		return 50;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//桔子计价</span><br><span class="line">	public int sell(Orange orange)&#123;</span><br><span class="line">		System.out.println(&quot;orange&#x27;s price: ￥20&quot;);</span><br><span class="line">		return 20;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//香蕉计价</span><br><span class="line">	public int sell(Banana banana)&#123;</span><br><span class="line">		System.out.println(&quot;banana&#x27;s price: ￥30&quot;);</span><br><span class="line">		return 30;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//其它水果计价</span><br><span class="line">	public int sell(Fruit fruit)&#123;</span><br><span class="line">		System.out.println(&quot;other price: ￥10&quot;);</span><br><span class="line">		return 10;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//直接访问</span><br><span class="line">private static int price() &#123;</span><br><span class="line">        int total = 0;</span><br><span class="line">        for (Fruit fruit : list) &#123;</span><br><span class="line">            total += visit.sell(fruit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;总价值：&quot; + total);</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是问题很明显，就算传入了具体的类型，也无法识别，统一当做Fruit类型来处理，也就是调用的其他水果计价的方法，下面通过双重分派做一层中转</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E5%8F%8C%E9%87%8D%E5%88%86%E6%B4%BE.png"></p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:50%;" />

<p>Fruit中新增一个accept方法并接收一个Visit对象进行转接访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line">   //省略冗余代码</span><br><span class="line">    public int accept(Visit visit)&#123;</span><br><span class="line">        return visit.sell(this);//指针可以传递真实类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历是通过调用Fruit的accept方法，传入Visit对象，内部再调Visit的sell方法进行计价，结果才符合预期，也就是说只有传入<strong>this指针</strong>才能具体区分实际类型，这也就是双重分派，所以访问者模式解决的具体问题如下</p>
<ol>
<li><p>集合中有不同类型的对象，通过方法重载（形参），无法识别它们的具体类型（出错）</p>
</li>
<li><p>通过双重委派，可以实现遍历识别，达成目标</p>
</li>
</ol>
<p>多态的方法重载是静态的</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>此番分析，访问者模式就是在被访问者内部新增一个接收访问者的一个方法，传入this指针，供其分辨具体类型，在实际遍历访问是，通过被访者的accept方法遍历即可</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>责任链模式通常用于开始执行一个业务前的流程检测，这个在OkHttp中有用到，比较典型</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><p>在结算时如果可以折上折，那么策略模式就不能用了，这个叠加的流程就是一个链条，用责任链模式为佳</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF.png" style="zoom:50%;" />

<p>结构图</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/java/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png"> </p>
<ol>
<li>Calculate方法内，判断next结点不为null，则继续调用next.calculate()</li>
<li>客户端调用时，负责初始化整个责任链</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class MultyDiscount implements Discount&#123;</span><br><span class="line">    protected MultyDiscount nextMultyDiscount;</span><br><span class="line"></span><br><span class="line">    public MultyDiscount(MultyDiscount nextMultyDiscount)&#123;</span><br><span class="line">        this.nextMultyDiscount = nextMultyDiscount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int calculate(int money)&#123;</span><br><span class="line">        if (this.nextMultyDiscount != null)&#123;</span><br><span class="line">            return this.nextMultyDiscount.calculate(money);</span><br><span class="line">        &#125;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FullMultyDiscount extends MultyDiscount &#123;</span><br><span class="line">    public FullMultyDiscount(MultyDiscount nextMultyDiscount) &#123;</span><br><span class="line">        super(nextMultyDiscount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int calculate(int money) &#123;</span><br><span class="line">        if (money &gt; 200)&#123;</span><br><span class="line">            System.out.println(&quot;优惠满减20元&quot;);</span><br><span class="line">            money = money - 20;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.calculate(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NewerMultyDiscount extends MultyDiscount &#123;</span><br><span class="line">    public NewerMultyDiscount(MultyDiscount nextMultyDiscount) &#123;</span><br><span class="line">        super(nextMultyDiscount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int calculate(int money) &#123;</span><br><span class="line">        if (money &gt; 100)&#123;</span><br><span class="line">            System.out.println(&quot;首次购买减20元&quot;);</span><br><span class="line">            money = money - 30;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.calculate(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ChainCartClient &#123;</span><br><span class="line"></span><br><span class="line">    //初始化满减优惠券</span><br><span class="line">    private static MultyDiscount multyDiscount = new FullMultyDiscount(null);</span><br><span class="line">    static &#123;</span><br><span class="line">        multyDiscount = new NewerMultyDiscount(multyDiscount);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Fruit&gt; products = new ArrayList();</span><br><span class="line"></span><br><span class="line">        products.add(StaticFactory.getFruitApple());</span><br><span class="line">        products.add(StaticFactory.getFruitBanana());</span><br><span class="line">        products.add(StaticFactory.getFruitOrange());</span><br><span class="line"></span><br><span class="line">        ShoppingCart cart = new OtherPayShopping(products);</span><br><span class="line"></span><br><span class="line">        //注入优惠方案</span><br><span class="line">        cart.setDiscount(multyDiscount);</span><br><span class="line"></span><br><span class="line">        cart.submitOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：当出现多个对象可以处理同一个请求时，适合责任链模式，可以看到上述是多个对象处理价格的场景</p>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式六大原则</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>在项目开发中，必不可少的是对设计模式的掌握，从过往的理解来看，设计模式很多时候都和接口有关，本专题以设计模式六大原则开始</p>
</blockquote>
<h3 id="二-常用的设计模式及其对应的类型"><a href="#二-常用的设计模式及其对应的类型" class="headerlink" title="二.常用的设计模式及其对应的类型"></a>二.常用的设计模式及其对应的类型</h3><ol>
<li>创建型模式：静态工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式</li>
<li>结构型模式：桥接模式、适配器模式、装饰器模式、代理模式、组合模式</li>
<li>行为型模式：模板方法模式、策略模式、观察者模式、责任链模式、命令模式、访问者模式</li>
</ol>
<blockquote>
<p>设计模式是解决问题的思想，重要的是思想，撸码的时候不要可以追求设计模式，否则你会半天撸不出一行码</p>
</blockquote>
<h3 id="三-六大原则详解"><a href="#三-六大原则详解" class="headerlink" title="三.六大原则详解"></a>三.六大原则详解</h3><ol>
<li><p>单一职责原则：一个类负责一项职责</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99.png" style="zoom:30%;" />

<p>单一职责原则比较简单，就是某个功能的独立化，不能将多个功能掺杂在一个类里面，如上图，UserController管理User信息，OrderController管理Order信息</p>
</li>
<li><p>里氏替换原则：子类可以扩展父类的功能，但不要改变父类原有的功能</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99.png" style="zoom:30%;" /></li>
<li><p>依赖倒置原则：面向接口编程</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99.png" style="zoom:30%;" />

<p>​    大白话就是撸码时用接口类型，不用子类类型，多态的体现</p>
</li>
<li><p>接口隔离原则：设计接口功能尽量细粒度，最小功能单元</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png" style="zoom:30%;" />

<p>​    如果需要给AImplChild新增方法，首先想到的是在A接口中新增，但是这样的话AImpl也会实现这个它本身     不需要的test方法，所以单独抽离一个接口让AImplChild来实现，这样的话AImplChild既可以用A也可以用    newA来接收，个人觉得不是很方便，因为如果用newA来接收，那么就无法调用A中的方法，但AImplChild    也是A接口的实现类，所以这种隔离在项目开发中很少用到，小编在实际项目见过接口间的继承，也就是说    这里newA继承A接口，那么newA的实现自然就可以调用A中的方法</p>
</li>
<li><p>迪米特法则：降低耦合，局部变量中，尽量不要导入新的Class类</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99.png" style="zoom:30%;" />

<p>从类的结构上来说，没有影响，但导入了一个新的类，在类的结构上是看不到这个类的使用的，所以在撸码时尽量将局部变量设置为属性</p>
</li>
<li><p>开闭原则：对扩展开放，对修改关闭(比较宏观)</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99.png" style="zoom:33%;" />

<p>当一个体系需要新增功能时，应该合理添加，如上图，增加一套代码，新增接口以及实现等，就算新增的功能很简单，很少，也不能将功能添加在已有的代码中，比如添加到这里UserController中，明显不合理</p>
</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>本文是设计模式的开章，上述介绍的原则中，后续的设计模式中重点考察单一职责原则、依赖倒置原则和开闭原则，以上的原则其实日常撸码中用得很频繁，不要刻意去往这上面靠</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>从本文开始就是结构型设计模式了，适配器模式相信不陌生，小编的理解就是适配器做了一层转换，转换成我们想要的形式，下面的例子并不经典，还是得回归到RecyclerView中才行</p>
</blockquote>
<h3 id="二-场景模拟"><a href="#二-场景模拟" class="headerlink" title="二.场景模拟"></a>二.场景模拟</h3><blockquote>
<p>在水果店经营过程中，发现包装橘子用的包装库存不够了，会想到用苹果的包装来包装橘子，也就是将苹果包装转换成橘子包装</p>
</blockquote>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF%E5%9B%BE.png"></p>
<p>这里有继承和组合，下面通过一张图简单聊聊</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BB%84%E5%90%88.png" style="zoom:50%;" />

<p>​    这也是结构型的两种方式，要调用A、B中的方法，有继承和组合两种方式，明显，组合更加灵活一点，如果有</p>
<p>​    依赖接口而不依赖实现的思想，即面向接口编程，还可以通过set的方式替换接口引用的实例</p>
<ol>
<li><p>OrangeBagAdapter继承OrangeBag的功能，同时组合AppleBag对象，使OrangeBag与AppleBag产生关联</p>
</li>
<li><p>当OrangeBag目标方法被调用时， OrangeBagAdapter转调AppleBag的对象方法</p>
<p>所以本质就是一层转换</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class OrangeBagAdapter(val appleBag: AppleBag): OrangeBag() &#123;</span><br><span class="line">    override fun packageFruit(fruit: Fruit) &#123;</span><br><span class="line">        appleBag.packageFruit(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">val orange = OrangeFactoryImpl().getFruit()</span><br><span class="line">    val bag = OrangeBagAdapter(AppleBag())</span><br><span class="line">    bag.packageFruit(orange)</span><br></pre></td></tr></table></figure>

<h3 id="三-RecyclerView扩展"><a href="#三-RecyclerView扩展" class="headerlink" title="三.RecyclerView扩展"></a>三.RecyclerView扩展</h3><blockquote>
<p>上面的栗子并不经典，都知道RecyclerView通过设置不同的Adapter就可以展示不同的内容，其实Adapter做的功能就是将数据转换成视图，但很多时候，我们会把Adapter做的很乱，会将Holder嵌套在里面，会在onCreateViewHoler和onBindViewHolder中做具体的事情，显然违背了单一职责原则，我们只关心Adapter的数据到视图的转换功能，其他的事情应交由具体的实现来做，下面简单抽离一下</p>
</blockquote>
<ol>
<li><p>定义抽象数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IBaseCustomViewModel &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有任何数据域，因为每种Holder展示的数据各不相同，所以交由实现类去扩展</p>
</li>
<li><p>定义抽象视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ICustomView&lt;D: IBaseCustomViewModel&gt; &#123;</span><br><span class="line">    fun setData(data: D)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将抽象视图和抽象数据相关联，所以在setData中调用数据绑定</p>
</li>
<li><p>定义基本视图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class BaseCustomView&lt;DATA : IBaseCustomViewModel&gt; @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null, style: Int = 0</span><br><span class="line">) : FrameLayout(context, attr, style), ICustomView&lt;DATA&gt; &#123;</span><br><span class="line">    protected lateinit var view: View</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun init() &#123;</span><br><span class="line">        view = LayoutInflater.from(context).inflate(getLayoutId(),this,false)</span><br><span class="line">        addView(view)</span><br><span class="line">    &#125;</span><br><span class="line">    abstract fun getLayoutId(): Int</span><br><span class="line"></span><br><span class="line">    override fun setData(data: DATA) &#123;</span><br><span class="line">        setDataToView(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract fun setDataToView(data: DATA)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本视图就是一个模板，具体的布局ID和绑定数据的方式交由实现类实现</p>
</li>
<li><p>定义通用Holder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BaseHolder(itemView: ICustomView&lt;*&gt;) : RecyclerView.ViewHolder(itemView as View) &#123;</span><br><span class="line"></span><br><span class="line">    private  var mItemViewI: ICustomView&lt;IBaseCustomViewModel&gt; = itemView as ICustomView&lt;IBaseCustomViewModel&gt;</span><br><span class="line"></span><br><span class="line">    fun bind(viewModel: IBaseCustomViewModel) &#123;</span><br><span class="line">        mItemViewI.setData(viewModel)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用Holder完成视图保存以及绑定数据，真正的数据绑定交由具体的视图实现，只需传入具体的数据模型即可</p>
</li>
</ol>
<blockquote>
<p>通过以上步骤，Adapter里面就相当简洁了，亲测很爽，在以前Adapter是非常混乱的，这里其实还有待扩展得地方，就是事件监听的处理，在Adapter中处理也行</p>
</blockquote>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>对于适配器，只需理解适配器的功能是什么–转换，这里额外扩展了一下RecyclerView的Adapter，思来想去就在这里扩展了，使用这一套，Adapter的可读性只能说变得很好，易于管理，是一个不错的选择</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式专题</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍贪心算法，贪心算法是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法，但贪心算法的结果不一定是最优的，但是都相对接近最优解的结果</p>
</blockquote>
<h3 id="二-贪心法实例——集合覆盖问题"><a href="#二-贪心法实例——集合覆盖问题" class="headerlink" title="二.贪心法实例——集合覆盖问题"></a>二.贪心法实例——集合覆盖问题</h3><p>下面以一个小实例来阐释贪心法</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B.png" style="zoom:80%;" />

<p>思路分析：</p>
<ol>
<li>通过一个Map来保存广播台以及它对应的覆盖区域</li>
<li>通过一个集合保存所有的地区</li>
<li>为了选出最佳的组合，肯定存在多次遍历，每遍历一次所有广播只能得到一个最佳的广播台，所以外层是<code>while</code>循环，根据贪心法的原理，那么每次都会选择覆盖还未被覆盖地区的最大值，因此每选出一个广播，就要将已覆盖的区域从所有地区中移除，所以外层<code>while</code>循环的结束条件就是所有地区覆盖完毕，即地区集合为空</li>
<li>此外还需定义一个<code>maxKey</code>来记录每次遍历获得的最佳广播台，遍历结束后，将其添加到结果集合中，以上过程为了不重复添加元素，所以都采用Set来保存数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void GreedyAlgorithm()&#123;</span><br><span class="line">       Map&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap();</span><br><span class="line">       HashSet&lt;String&gt; hashSet1 = new HashSet();</span><br><span class="line">       hashSet1.add(&quot;北京&quot;);</span><br><span class="line">       hashSet1.add(&quot;上海&quot;);</span><br><span class="line">       hashSet1.add(&quot;天津&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet2 = new HashSet();</span><br><span class="line">       hashSet2.add(&quot;广州&quot;);</span><br><span class="line">       hashSet2.add(&quot;北京&quot;);</span><br><span class="line">       hashSet2.add(&quot;深圳&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet3 = new HashSet();</span><br><span class="line">       hashSet3.add(&quot;成都&quot;);</span><br><span class="line">       hashSet3.add(&quot;上海&quot;);</span><br><span class="line">       hashSet3.add(&quot;杭州&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet4 = new HashSet();</span><br><span class="line">       hashSet4.add(&quot;上海&quot;);</span><br><span class="line">       hashSet4.add(&quot;天津&quot;);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hashSet5 = new HashSet();</span><br><span class="line">       hashSet5.add(&quot;杭州&quot;);</span><br><span class="line">       hashSet5.add(&quot;大连&quot;);</span><br><span class="line"></span><br><span class="line">       broadcasts.put(&quot;K1&quot;,hashSet1);</span><br><span class="line">       broadcasts.put(&quot;K2&quot;,hashSet2);</span><br><span class="line">       broadcasts.put(&quot;K3&quot;,hashSet3);</span><br><span class="line">       broadcasts.put(&quot;K4&quot;,hashSet4);</span><br><span class="line">       broadcasts.put(&quot;K5&quot;,hashSet5);</span><br><span class="line">       HashSet&lt;String&gt; allAreas = new HashSet();</span><br><span class="line">       allAreas.add(&quot;北京&quot;);</span><br><span class="line">       allAreas.add(&quot;上海&quot;);</span><br><span class="line">       allAreas.add(&quot;天津&quot;);</span><br><span class="line">       allAreas.add(&quot;广州&quot;);</span><br><span class="line">       allAreas.add(&quot;深圳&quot;);</span><br><span class="line">       allAreas.add(&quot;成都&quot;);</span><br><span class="line">       allAreas.add(&quot;杭州&quot;);</span><br><span class="line">       allAreas.add(&quot;大连&quot;);</span><br><span class="line">       //开始遍历</span><br><span class="line">       HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;();//记录当前广播可以覆盖的还未被覆盖的城市</span><br><span class="line">       String maxKey = null; //记录覆盖城市最多的那个广播</span><br><span class="line">       HashSet&lt;String&gt; selects = new HashSet&lt;&gt;();//保存选择的城市</span><br><span class="line">       while(!allAreas.isEmpty())&#123;</span><br><span class="line">           maxKey = null;</span><br><span class="line">           for (String key:broadcasts.keySet())&#123;</span><br><span class="line">               tempSet.clear();</span><br><span class="line">               tempSet = broadcasts.get(key);</span><br><span class="line">               //求当前广播可以覆盖的未被覆盖的城市</span><br><span class="line">               tempSet.retainAll(allAreas);</span><br><span class="line">               if (!tempSet.isEmpty() &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                   maxKey = key;</span><br><span class="line">               &#125;</span><br><span class="line">               if (maxKey!=null)&#123;</span><br><span class="line">                   selects.add(maxKey);</span><br><span class="line">                   allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (String city:selects) System.out.print(city+&quot; &quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>使用贪心法求解问题的关键在于找到贪心规律，每次找出最优的匹配结果，文章开篇也提到过贪心法的解不一定是最优解，因为现实问题还可能存在很多因素，比如成本</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>链表的局部反转</title>
    <url>/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%8D%E8%BD%AC.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>给你单链表的头节点<code>head</code>和两个整数<code>left</code>和<code>right </code>，其中<code>left</code>&lt;=<code>right</code>。请你反转从位置<code>left</code>到位置<code>right</code>的链表节点，返回 反转后的链表 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [5], left = 1, right = 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 <code>n</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>之前已经刷到过链表反转问题，而此处不一样的是局部反转，只需要记录局部反转链表的前一个和后一个结点即可，这次我使用的是栈来保存需要反转的结点，因为后进先出，刚好满足反转效果，但本题还有一个坑点，如果<code>left</code>的值为1，也就意味着头结点也会加入反转序列，可以自己尝试一下，这种情况最终只会输出一个结点，所以我们需要额外添加一个虚拟结点，这种控制边界问题的结点称为<strong>哨兵</strong>，哨兵结点的next域指向的头结点，如果头结点发生反转，那么此时的头结点将会发生变化，所以需要一个哨兵结点来进行保存新的头结点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseBetween(ListNode head, int left, int right) &#123;</span><br><span class="line">        ListNode FakeHead = new ListNode(0);</span><br><span class="line">        FakeHead.next = head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = new Stack();</span><br><span class="line">        ListNode newHead = FakeHead,newTail = null,headPointer = head;</span><br><span class="line">        for(int i = 1;i&lt;=right;i++)&#123;</span><br><span class="line">            if(i==left-1)&#123;</span><br><span class="line">            	//记录局部反转链表的前一个结点</span><br><span class="line">                newHead = headPointer;</span><br><span class="line">            &#125;else if(i&gt;=left)&#123;</span><br><span class="line">                stack.push(headPointer);</span><br><span class="line">            &#125;</span><br><span class="line">            headPointer = headPointer.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录局部反转链表的下一个结点</span><br><span class="line">        newTail = headPointer;</span><br><span class="line">        int length = stack.size();</span><br><span class="line">        for(int i = 0;i&lt;length;i++)&#123;</span><br><span class="line">            ListNode temp = stack.pop();</span><br><span class="line">            newHead.next = temp;</span><br><span class="line">            newHead = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        newHead.next = newTail;</span><br><span class="line">        return FakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>本题思路并不难，唯一需要注意的是头结点是否需要变化，即边界是否发生变化，需要一个哨兵结点来控制</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>本文将介绍选择排序的原理以及为什么选择排序是不稳定的，由于它的不稳定性，选择排序基本被废弃，不用于项目中</p>
</blockquote>
<h3 id="二-选择排序原理分析和算法实现"><a href="#二-选择排序原理分析和算法实现" class="headerlink" title="二.选择排序原理分析和算法实现"></a>二.选择排序原理分析和算法实现</h3><p>先上动图理解选择排序</p>
<p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190325085919297-1818609484.gif"></p>
<p>个人感觉选择排序和冒泡排序是反着来的，选择排序是前面作为有序区，后面作为无序区，每一趟排序都是将<strong>无序区中的第一个元素作为最小的元素</strong>，然后往后比较查找比它更小的元素位置，查找完后进行交换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ChooseSort &#123;</span><br><span class="line">    static void chooseSort(Element[] dataArray)&#123;</span><br><span class="line">        int minPos;</span><br><span class="line">        int j;</span><br><span class="line">        for(j=0;j&lt;dataArray.length - 1;j++) &#123;</span><br><span class="line">            minPos = j;</span><br><span class="line">            for (int i = j; i &lt; dataArray.length; i++) &#123;</span><br><span class="line">                minPos = dataArray[minPos].value &gt; dataArray[i].value ? i : minPos;</span><br><span class="line">            &#125;</span><br><span class="line">            Element temp = dataArray[minPos];</span><br><span class="line">            dataArray[minPos] = dataArray[j];</span><br><span class="line">            dataArray[j] = temp;</span><br><span class="line">            for (Element temp2:dataArray) &#123;</span><br><span class="line">                System.out.print(temp2+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Element[] datas = &#123;new Element(5,&quot;first&quot;),new Element(8,&quot;second&quot;)</span><br><span class="line">                ,new Element(9,&quot;third&quot;),new Element(6,&quot;fourth&quot;),</span><br><span class="line">                new Element(5,&quot;fifth&quot;),</span><br><span class="line">                new Element(1,&quot;sixth&quot;),new Element(7,&quot;seventh&quot;)</span><br><span class="line">                ,new Element(4,&quot;eighth&quot;)   &#125;;</span><br><span class="line">        chooseSort(datas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public class Element &#123;</span><br><span class="line">    int value;</span><br><span class="line">    String tag;</span><br><span class="line">    public Element(int value, String tag) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &#x27;(&#x27;+&quot;value:&quot;+value+&quot; tag:&quot;+tag+&#x27;)&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我对此处进行排序的元素进行了封装，为了能够演示选择排序的不稳定性，多加了一个标记<code>Tag</code></p>
</blockquote>
<h3 id="三-选择排序的不稳定性"><a href="#三-选择排序的不稳定性" class="headerlink" title="三.选择排序的不稳定性"></a>三.选择排序的不稳定性</h3><p>首先引出不稳定性的概念：</p>
<p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法</p>
<p>根据以上描述以及代码，下面演示一下选择排序的不稳定性：</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%80%89%E6%8B%A9%E4%B8%8D%E7%A8%B3%E5%AE%9A.png"></p>
<p>根据最终的排序结果可以看到，第一个5和第二个5相对位置发生了改变，因此不稳定，这种不稳定性弊端明显，如果你排序的元素还有其他变量域类似于此处的<code>tag</code>，并且其他变量域根据某种排序规则已经排好序了，那么这种结果肯定是我们不想要的，并且徒增麻烦，如果使用冒泡排序对以上的元素进行排序，相同<code>value</code>的相对位置是不会改变的</p>
<h3 id="四-选择排序稳定化"><a href="#四-选择排序稳定化" class="headerlink" title="四.选择排序稳定化"></a>四.选择排序稳定化</h3><p>下面对上面不稳定的算法进行优化，让它变成稳定的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void BubbleSortOptimization(Element[] dataArray)&#123;</span><br><span class="line">       boolean hasExchanged = true;</span><br><span class="line">       int lastPosition = dataArray.length-1;</span><br><span class="line">       int k = 0;</span><br><span class="line">       for(int i=dataArray.length-1;i&gt;0&amp;&amp;hasExchanged;i--)&#123;</span><br><span class="line">           hasExchanged = false;</span><br><span class="line">           for(int j = 0; j&lt;lastPosition; j++)&#123;</span><br><span class="line">               Element temp;</span><br><span class="line">               if (dataArray[j].value&gt;dataArray[j+1].value)&#123;</span><br><span class="line">                   temp = dataArray[j+1];</span><br><span class="line">                   dataArray[j+1] = dataArray[j];</span><br><span class="line">                   dataArray[j]=temp;</span><br><span class="line">                   hasExchanged = true;</span><br><span class="line">                   k = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for (Element temp2:dataArray) &#123;</span><br><span class="line">               System.out.print(temp2+&quot; &quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">           lastPosition = k;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_34437210/article/details/106928384?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-5-106928384.pc_agg_rank_aggregation&utm_term=%E7%A8%B3%E5%AE%9A%E7%9A%84%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&spm=1000.2123.3001.4430">上面的思路来自此篇文章</a></p>
<p>通过依次往后挪动的方式来保证元素之前的相对性，但代价是付出了更多的时间，最坏的情况时间增加了一倍，虽然复杂度还是O(n<sup>2</sup>)</p>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><table>
<thead>
<tr>
<th align="center">时间复杂度(平均)</th>
<th align="center">时间复杂度(最坏)</th>
<th align="center">时间复杂度(最好)</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">不稳</td>
</tr>
</tbody></table>
<blockquote>
<p>选择排序容易理解，但项目中基本不用，就算使用了稳定版的选择排序，耗时也很多</p>
</blockquote>
]]></content>
      <categories>
        <category>排序集</category>
      </categories>
      <tags>
        <tag>算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>集成高德地图总结</title>
    <url>/%E9%9B%86%E6%88%90%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<h3 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h3><blockquote>
<p>市面上的绝大多数App都会使用到定位服务，都需集成高德地图SDK，才能调用其提供的API接口，显示地图以及其他定位功能，跟着官网的文档进行学习即可，但对于Window系统来说，集成时坑多，后期学习相信都没问题，下面小编总结出主要的坑点以及配置流程</p>
</blockquote>
<h3 id="二-获取SHA的值"><a href="#二-获取SHA的值" class="headerlink" title="二.获取SHA的值"></a>二.获取SHA的值</h3><ol>
<li><p>首先登录并进入控制台创建一个应用</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%88%9B%E5%BB%BA%E9%AB%98%E5%BE%B7key.png"></p>
</li>
<li><p>添加一个key</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E5%88%9B%E5%BB%BAkey.png" style="zoom:50%;" /></li>
</ol>
<p><strong>坑点就在第二步，如何获取SHA的值</strong></p>
<h5 id="一-获取调试版SHA1的值"><a href="#一-获取调试版SHA1的值" class="headerlink" title="一.获取调试版SHA1的值"></a>一.获取调试版SHA1的值</h5><p>调试版的获取比较轻松，但近日我再次获取时，又发生了一些变化，安装之前的做法出现以下错误</p>
<p><code>非法选项: C:\Users\1\.android\debug.keystore</code></p>
<p>下面介绍新的做法</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E8%8E%B7%E5%8F%96debug%E7%8A%B6%E6%80%81key.png"></p>
<p><code>keytool -list -alias androiddebugkey -keystore &quot;C盘对应的debug.keystore路径&quot; -storepass android -keypass android</code></p>
<h5 id="二-获取发布版SHA1的值"><a href="#二-获取发布版SHA1的值" class="headerlink" title="二.获取发布版SHA1的值"></a>二.获取发布版SHA1的值</h5><ol>
<li><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E8%8E%B7%E5%8F%96%E5%8F%91%E5%B8%83%E7%89%881.png" style="zoom:80%;" /></li>
<li><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E8%8E%B7%E5%8F%96%E5%8F%91%E5%B8%832.png" style="zoom: 50%;" /></li>
<li><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E8%8E%B7%E5%8F%96%E5%8F%91%E5%B8%83%E7%89%883.png" style="zoom:50%;" /></li>
<li><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/%E8%8E%B7%E5%8F%96%E5%8F%91%E5%B8%83%E7%89%884.png" style="zoom:50%;" /></li>
</ol>
<blockquote>
<p>发布版的获取需要进入到<strong>jdk安装路径中bin文件中</strong>，执行<code>keytool -list -v -keystore jks文件路径</code>命令即可获得发布版SHA1的值</p>
</blockquote>
<h3 id="三-配置so镜像文件以及gradle集成"><a href="#三-配置so镜像文件以及gradle集成" class="headerlink" title="三.配置so镜像文件以及gradle集成"></a>三.配置so镜像文件以及gradle集成</h3><p>在步骤2中创建好key后，<code>&lt;meta-data android:name=&quot;com.amap.api.v2.apikey&quot; android:value=&quot;key&quot;/&gt;</code>，需要在application标签中添加这句话</p>
<p>最后只差配置地图：</p>
<ol>
<li><p>官网提供了两种方式添加地图，一是手动复制对应的jar包到lib目录，另外一种是通过gradle下载，小编推荐第二种，很方便</p>
<p><code>implementation &#39;com.amap.api:3dmap:7.9.0.1&#39;</code></p>
</li>
<li><p>在app模块对应的gradle中的defaultConfig大括号里添加一下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">          abiFilters  &quot;armeabi-v7a&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>官网还添加了其他镜像版本，但其实上面一个就够了，这也是apk瘦身中最主要的一步</p>
</li>
</ol>
<p>最后在manifests中添加权限即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--允许程序打开网络套接字--&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">   &lt;!--允许程序设置内置sd卡的写权限--&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">   &lt;!--允许程序获取网络状态--&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">   &lt;!--允许程序访问WiFi网络信息--&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">   &lt;!--允许程序读写手机状态和身份--&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">   &lt;!--允许程序访问CellID或WiFi热点来获取粗略的位置--&gt;</span><br><span class="line">   &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>添加地图控件并初始化地图的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line">    &lt;com.amap.api.maps.MapView</span><br><span class="line">        android:id=&quot;@+id/mapView&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mapView.onCreate(savedInstanceState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就能显示地图啦</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87/Screenshot_20210410_220225_swu.cx.gaodemap.jpg" style="zoom:25%;" />

<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>由于项目需要，也是第一次接触高德地图的集成，稍微麻烦一点的就是SHA的获取，其他的还好，调试版的SHA都是一样的，只是发布版不一样，日后创建key只需要重新获取发布版的SHA即可</p>
</blockquote>
]]></content>
      <categories>
        <category>问题总结集</category>
      </categories>
  </entry>
  <entry>
    <title>项目组件化入门使用</title>
    <url>/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p>在日常的个人开发中，我们都习惯分包来管理项目，虽然简单，但包与包之间的耦合性太严重，比如将新增的一个A业务通过一个包来管理，后续不需要这个业务了，把这个包删掉后，其他包如果导入了A业务中的一些类，显然修改的地方会有点多，很不方便，而且一旦项目做大以后，包与包之间的导入关系更加复杂，对于后继者来说难以维护，下面介绍组件化的管理方式</p>
<h3 id="二-组件化概念"><a href="#二-组件化概念" class="headerlink" title="二.组件化概念"></a>二.组件化概念</h3><blockquote>
<p>组件化简单说就是通过Module来管理各个业务，各个Module之间不能相互依赖，从而实现高度解耦，自由拆卸和组装，可重用，分层独立化</p>
</blockquote>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:40%;" />

<p>如上图，每个module地位都是平等的，分包管理方式都会将业务代码放在app moudule中，并且只有这一个module，而组件化管理是将一个业务通过一个module来管理，所以app module最终也只是一个入口，形象的说就是一个app壳，<strong>每个子模块之间不能相互依赖</strong></p>
<h3 id="三-Gradle控制测试环境和正式环境"><a href="#三-Gradle控制测试环境和正式环境" class="headerlink" title="三.Gradle控制测试环境和正式环境"></a>三.Gradle控制测试环境和正式环境</h3><p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83.png"></p>
<blockquote>
<p>通过Gradle的相关配置可以决定一个子模块能否独立运行，独立运行时就将该模块打包成apk，正式环境下，不能独立运行，只能作为lib依赖包依附于app壳</p>
</blockquote>
<ol>
<li><p>gradle加载配置流程</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/gradle%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png"></p>
<p>app加载完之后就是各个子模块</p>
</li>
<li><p>抽离使用公共的gradle配置</p>
<p>可以看到每个module都有相似的配置，比如编译版本、目标版本等等，随着模块的增多，为了方便管理，可以将这部分公共的配置抽离形成一个公共的gradle配置文件config.gradle</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E6%8A%BD%E7%A6%BBconfig.gradle.png" style="zoom:50%;" />



<p>在根项目路径下创建一个gradle配置文件，这里使用的是Groovy语法，属于java的一个分支，也有面向对象的特性，增加一个ext扩展块，通过键值对的方式保存公共配置，这个过程是死的，多写几遍就好</p>
</li>
<li><p>导入公共配置并使用</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%AF%BC%E5%85%A5%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"></p>
<p>在项目的build.gradle中通过<code>apply from : &#39;配置文件名&#39;</code>导入，根据之前分析的gradle加载配置流程，当项目的build.gradle加载完之后，在模块的build.gradle中就能访问配置文件中的内容</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E5%AD%90%E6%A8%A1%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%80%BC.png" style="zoom:40%;" />

<p>在子模块中通过<code>rootProject</code>就可以访问公共配置文件中的内容，这里通过一个临时变量来保存拿到的值做一个缓存提升性能，不保存也是可以的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependenciesId = [</span><br><span class="line">            stdlib :&quot;org.jetbrains.kotlin:kotlin-stdlib:1.4.32&quot;,</span><br><span class="line">            core :&#x27;androidx.core:core-ktx:1.6.0&#x27;,</span><br><span class="line">            appcompat :&#x27;androidx.appcompat:appcompat:1.3.1&#x27;,</span><br><span class="line">            material :&#x27;com.google.android.material:material:1.4.0&#x27;,</span><br><span class="line">            constraintlayout :&#x27;androidx.constraintlayout:constraintlayout:2.1.1&#x27;</span><br><span class="line">    ]</span><br><span class="line">//遍历依赖</span><br><span class="line">dependenciesId.each &#123; k, v -&gt; implementation v &#125;</span><br></pre></td></tr></table></figure>

<p>可以将implementation类型的依赖统一通过键值对来管理，然后在build.gradle的dependencies{}中遍历依赖，同理androidTestImplementation类型的依赖也可以通过此方法来管理</p>
<p>注：对于library没有applicationID</p>
</li>
<li><p>控制测试环境和正式环境</p>
<p>两种情况通过一个开关就可以控制，在ext扩展块中定义一个布尔变量即可，这里以debug和release两种包来进行区分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isReleased = false</span><br><span class="line">   </span><br><span class="line">  url = [</span><br><span class="line">          debug: &quot;123455555&quot;,</span><br><span class="line">          release: &quot;adkfjafkasf&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>在app模块的build.gradle中进行配置，如果是debug签名，则生成debug的url，反之生成release的url</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/buildTypes%E4%B8%AD%E7%94%9F%E6%88%90%E5%80%BC.png" style="zoom:25%;" />

<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/BuildConfig.png" style="zoom:33%;" />

<p>如上图所示，很显然，defaultConfig这个闭包中可以指定编译生成的BuildConfig类中的内容，可以通过以下代码生成对应的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildConfigField(&quot;类型&quot;,&quot;变量名&quot;,对应配置文件的值)</span><br></pre></td></tr></table></figure>

<p>如此一来就可以在代码中拿到配置文件中的值来判断是否是测试环境，做相应的处理</p>
<p>接下来就是如何通过配置文件中的这个变量来决定模块是否可以独立运行，我们知道如果一个模块能够独立运行，那么它导入的插件一定是<code>&#39;com.android.application&#39;</code>，否则是<code>com.android.library&#39;</code>，所以通过一个if控制即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (isReleased) &#123;</span><br><span class="line">    apply plugin: &#x27;com.android.library&#x27;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    apply plugin: &#x27;com.android.application&#x27;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: &#x27;kotlin-android&#x27;</span><br></pre></td></tr></table></figure>

<p>对于这种需要动态调整的插件导入，不使用plugins { id ‘插件名’}的方式导入，kotlin模块比较坑，必须按照上述模板写，如此一来就可以通过isReleased变量控制模块是否可以独立运行了</p>
</li>
<li><p>正式环境，子模块依附于app壳</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/%E4%BE%9D%E9%99%84%E4%BA%8Eapp%E5%A3%B3.png" style="zoom:33%;" /></li>
</ol>
<h3 id="四-测试环境下控制AndroidManifest以及测试代码"><a href="#四-测试环境下控制AndroidManifest以及测试代码" class="headerlink" title="四.测试环境下控制AndroidManifest以及测试代码"></a>四.测试环境下控制AndroidManifest以及测试代码</h3><blockquote>
<p>在测试环境下，我们希望使用测试的Activity，这个就需要通过提供测试环境下的AndroidManifest文件以及控制文件路径来实现</p>
</blockquote>
<ol>
<li><p>提供测试环境的AndroidManifest以及测试的Activity</p>
</li>
<li><p>在子模块的build.gradle中通过sourceSets根据是否是正式环境来指定AndroidManifest的文件路径</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/sourceSets%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.png" style="zoom:33%;" />

<p>注：在正式打包时，测试代码不应打包，所以在sourceSets中还可以屏蔽测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java &#123;</span><br><span class="line">            exclude &quot;**/debug/**&quot;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h3><blockquote>
<p>将项目组件化的过程是固定的，因为涉及到一些gradle配置以及groovy语法，所以需要多写几次，此外也可以了解一下groovy语法</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>组件化系列</category>
      </categories>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.html</url>
    <content><![CDATA[<h3 id="一-题目描述"><a href="#一-题目描述" class="headerlink" title="一.题目描述"></a>一.题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E7%AE%97%E6%B3%95%E7%AF%87/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84.png" style="zoom:67%;" />

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<h3 id="二-思路分析"><a href="#二-思路分析" class="headerlink" title="二.思路分析"></a>二.思路分析</h3><blockquote>
<p>小编开始审错题了，将该矩阵当做了方阵，所以之前写的算法仅适用于方阵，但最容易想到的思路还是旋转打印路径的方式，官方文档也是这样处理的，但后来小编采纳了另外一个博主的思路，他将此问题模型化了，可以将矩阵看作是带有上下左右边界的一块地，每次都会经历向右、向下、向左、向上四个方向的打印操作，因此通过四个for循环进行模拟，从起始边到终点边，每遍历完一边，就将那边向内移动一个距离，直到某两个对边超过对方就算遍历完成，该思路很清晰并且好记，下面上代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int[] spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        if (matrix.length==0) return new int[0];</span><br><span class="line">        int left = 0 ,right = matrix[0].length-1, top = 0, bottom = matrix.length-1;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int[] result = new int[(right+1)*(bottom+1)];</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            for (int i = left;i&lt;=right;i++) result[count++] = matrix[top][i];</span><br><span class="line">            if (++top&gt;bottom) break;</span><br><span class="line">            for (int i = top; i &lt;= bottom; i++) result[count++] = matrix[i][right];</span><br><span class="line">            if (left&gt;--right) break;</span><br><span class="line">            for (int i = right; i &gt;=left ; i--) result[count++] = matrix[bottom][i];</span><br><span class="line">            if (top&gt;--bottom) break;</span><br><span class="line">            for (int i = bottom; i &gt;= top ; i--) result[count++] = matrix[i][left];</span><br><span class="line">            if (++left&gt;right) break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h3><blockquote>
<p>此类问题关键点是模型化，只要找到合适的模型进行处理，就相当快</p>
</blockquote>
]]></content>
      <categories>
        <category>力扣题解</category>
      </categories>
  </entry>
  <entry>
    <title>首次开源库-不一样的文字渐变效果</title>
    <url>/%E9%A6%96%E6%AC%A1%E5%BC%80%E6%BA%90%E5%BA%93-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><blockquote>
<p>此前也常有自定义View，其实功能都是建立在自定义绘制的基础上，这次记录一下，顺便发布到MavenCentral中去，本次要发布的是一个文字渐变效果的TextView，所以算是对系统控件的一个扩展，使用场景比较巧合，当时首次使用用作一段文本的渐变效果，思虑一番，发现对文本做渐变效果的控件貌似还没有，下面会通过两种方式来实现相同的效果</p>
</blockquote>
<h3 id="二-自定义View搭配自定义ViewGroup实现文本渐变"><a href="#二-自定义View搭配自定义ViewGroup实现文本渐变" class="headerlink" title="二.自定义View搭配自定义ViewGroup实现文本渐变"></a>二.自定义View搭配自定义ViewGroup实现文本渐变</h3><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/%E6%96%87%E6%9C%AC%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9Cshow.gif" style="zoom:50%;" />

<p>首先来感受一下效果，哎，发现貌似还挺简单的，不过实际处理起来真不简单，如果没有找到合适的切入点，对于这种段落式效果，很容易想到分行嘛，外层是线性布局，所以就有了第一版，也许会很好奇，段落，一个TextView不就搞定了吗，确实是，但是你要如何实现逐行的动画，每一行作为一个单元，还能单独测量每一行，区分每一行的标志就是换行，如果纯自定义的话又如何能实现，所以这里只能先分两步，自定义单元行，以及容器，下面简单展示一下代码结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ClipAbleTextView @JvmOverloads constructor(</span><br><span class="line">    context: Context,</span><br><span class="line">    attr: AttributeSet? = null,</span><br><span class="line">    style: Int = 0</span><br><span class="line">) : View(context, attr, style) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        parseAttr(attr)</span><br><span class="line">    &#125;</span><br><span class="line">    //记录外设属性</span><br><span class="line">    private var textBgColor: Int = 0</span><br><span class="line">    private var textForeColor: Int = 0</span><br><span class="line">    private var mTextSize: Float = 0f</span><br><span class="line">    private lateinit var mContent: String // 聚宝坑</span><br><span class="line">//    private var mContent: String = &quot; &quot;</span><br><span class="line"></span><br><span class="line">    //背景起始画笔</span><br><span class="line">    private var textBgPaint = Paint().apply &#123;</span><br><span class="line">        color = textBgColor</span><br><span class="line">        textSize = mTextSize</span><br><span class="line">        setStyle(Paint.Style.FILL)</span><br><span class="line">    &#125;</span><br><span class="line">    //渐变画笔</span><br><span class="line">    private var textForePaint = Paint().apply &#123;</span><br><span class="line">        color = textForeColor</span><br><span class="line">        textSize = mTextSize</span><br><span class="line">        setStyle(Paint.Style.FILL)</span><br><span class="line">    &#125;</span><br><span class="line">    //行高</span><br><span class="line">    private val lineHeight: Float by lazy &#123;</span><br><span class="line">        val rect = Rect()</span><br><span class="line">        textBgPaint.getTextBounds(mContent, 0, mContent.length, rect)</span><br><span class="line">        rect.height().toFloat()</span><br><span class="line">    &#125;</span><br><span class="line">    //渐变因子</span><br><span class="line">    private var gradualFactor = 0f</span><br><span class="line"></span><br><span class="line">    private fun parseAttr(attr: AttributeSet?) &#123;</span><br><span class="line">        if (attr == null) &#123;</span><br><span class="line">            Log.e(TAG,&quot;attr is null!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        val typedArray: TypedArray = context.obtainStyledAttributes(attr, R.styleable.ClipAbleTextView)</span><br><span class="line">        textBgColor = typedArray.getColor(R.styleable.ClipAbleTextView_background_text_color, Color.BLACK)</span><br><span class="line">        textForeColor = typedArray.getColor(R.styleable.ClipAbleTextView_foreground_text_color, Color.BLACK)</span><br><span class="line">        mTextSize = typedArray.getDimension(R.styleable.ClipAbleTextView_textSize, 20f)</span><br><span class="line">        mContent = typedArray.getString(R.styleable.ClipAbleTextView_text_content) ?: &quot;&quot;</span><br><span class="line">        typedArray.recycle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">        val width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        val height = lineHeight + Utils.dp2px(context, 9)</span><br><span class="line">        setMeasuredDimension(width, height.toInt())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onDraw(canvas: Canvas?) &#123;</span><br><span class="line">        drawBgText(canvas)</span><br><span class="line">        drawForeText(canvas)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //绘制背景文字</span><br><span class="line">    private fun drawBgText(canvas: Canvas?) &#123;</span><br><span class="line">        canvas?.save()</span><br><span class="line">        canvas?.clipRect(measuredWidth * gradualFactor,0f,measuredWidth.toFloat(), measuredHeight.toFloat())</span><br><span class="line">        canvas?.drawText(mContent, 0f, lineHeight, textBgPaint)</span><br><span class="line">        canvas?.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //绘制渐变前景文字</span><br><span class="line">    private fun drawForeText(canvas: Canvas?) &#123;</span><br><span class="line">        canvas?.save()</span><br><span class="line">        canvas?.clipRect(0f,0f,measuredWidth * gradualFactor, measuredHeight.toFloat())</span><br><span class="line">        canvas?.drawText(mContent, 0f, lineHeight, textForePaint)</span><br><span class="line">        canvas?.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private var textAnimator: ValueAnimator? = null</span><br><span class="line"></span><br><span class="line">    fun startGradualDraw(task: (()-&gt;Unit)?) &#123;</span><br><span class="line">        textAnimator = ValueAnimator.ofFloat(0f,1f).apply &#123;</span><br><span class="line">            addUpdateListener &#123;</span><br><span class="line">                gradualFactor = it.animatedValue as Float</span><br><span class="line">                invalidate()</span><br><span class="line">            &#125;</span><br><span class="line">            addListener(object : Animator.AnimatorListener&#123;</span><br><span class="line">                override fun onAnimationStart(p0: Animator?) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onAnimationEnd(p0: Animator?) &#123;</span><br><span class="line">                    task?.invoke()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onAnimationCancel(p0: Animator?) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                override fun onAnimationRepeat(p0: Animator?) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            duration = 7000</span><br><span class="line">        &#125;</span><br><span class="line">        textAnimator?.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun resetStatus() &#123;</span><br><span class="line">        gradualFactor = 0f</span><br><span class="line">        invalidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cancelAnimation() &#123;</span><br><span class="line">        textAnimator?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TAG = &quot;ClipAbleTextView&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ClipTextViewContainer @JvmOverloads constructor(context: Context, attr: AttributeSet? = null, style: Int = 0)</span><br><span class="line">    : LinearLayout(context, attr, style) &#123;</span><br><span class="line"></span><br><span class="line">    private val clipChildContainer: MutableList&lt;ClipAbleTextView&gt; by lazy &#123;</span><br><span class="line">        mutableListOf&lt;ClipAbleTextView&gt;().apply &#123;</span><br><span class="line">            for (i in 0 until childCount) &#123;</span><br><span class="line">                this.add(getChildAt(i) as ClipAbleTextView)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private var index = 0</span><br><span class="line">    var animationEnded = false</span><br><span class="line">    init &#123;</span><br><span class="line">        orientation = VERTICAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun playText() &#123;</span><br><span class="line">        if (clipChildContainer.size == 0) return</span><br><span class="line">        clipChildContainer[index].startGradualDraw &#123;</span><br><span class="line">            index++</span><br><span class="line">            if (index &lt; childCount) &#123;</span><br><span class="line">                playText()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index = 0</span><br><span class="line">                animationEnded = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun reset() &#123;</span><br><span class="line">        clipChildContainer.forEach&#123;</span><br><span class="line">            it.resetStatus()</span><br><span class="line">        &#125;</span><br><span class="line">        animationEnded = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cancelAllAnimation() &#123;</span><br><span class="line">        clipChildContainer.forEach&#123;</span><br><span class="line">            it.cancelAnimation()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是比较关键性的代码了，纯自定义每行的View，只能实现文字渐变效果，不能换行，其实应该有实现方案，不过很麻烦，当时时间紧迫只能先这样了，然后外层容器也得自定义，控制每行的动画，其他的部分就很简单了，然后想说的是，上述的方案局限性超大，因为没有自动换行的功能，所以只能手动控制每一行的内容，特别呆，如果说仅仅是为了实现功能，都还只能说将就能用</p>
<h3 id="三-扩展系统的TextView实现文本渐变"><a href="#三-扩展系统的TextView实现文本渐变" class="headerlink" title="三.扩展系统的TextView实现文本渐变"></a>三.扩展系统的TextView实现文本渐变</h3><p>其实上面那个版本的缺点就是不能自动换行，说到自动换行，肯定首选系统的TextView，那么就得研究一下系统的TextView是如何实现每一行文本测量以及换行了</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F.png" style="zoom:30%;" />

<p>在onMeasure里面有一个<code>mLayout</code>的变量，上述截图前会通过<code>mLayout</code>拿到文本宽高的测量值，显然，第一次Measure的时候，它为空，所以进入<code>makeNewLayout</code>构造一个实例</p>
<p><img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F2.png"></p>
<p>随后进入到<code>makeSingleLayout</code>方法中</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F3.png" style="zoom:33%;" />

<p>经过调试，发现<code>mLayout</code>会通过<code>StaticLayout</code>来生成，下面进入到它的构造函数里，会看到末尾有执行了<code>generate</code>方法，里面的流程稍微复杂，只需要找和行数相关的代码即可，随后定位到<code>out</code>函数的调用处</p>
<img src="https://blog-picture-1302250619.cos.ap-chongqing.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E5%88%97/Layout%E6%B5%8B%E9%87%8F4.png" style="zoom:33%;" />

<p>看到这里其实也就差不多了，具体换行的逻辑貌似是通过<code>LineBreaker</code>来管理的，大致流程走通后，对于自定义一个TextView就很简单了，只需要通过<code>mLayout</code>来获取到行数，每一行的具体内容，都有相应的api供使用，剩余的工作就是绘制了，这里一笔带过</p>
<p>这个自定义的文本渐变效果，为了让功能更加健全，也是做了一些处理的</p>
<p>坑点：</p>
<ol>
<li>在实现动画的过程中，发现cancel结束后是会走end的，这种情况就需要额外的标志判断</li>
<li>在暂停动画，也就是取消动画后，再次开始需要在上次完成的进度基础上来设置动画时长，否则会变得很慢</li>
</ol>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h3><blockquote>
<p>这是首次发布的开源库，还是蛮有意思的吧，上述的原理也是一个探索的过程，下面通过添加依赖体验不一样的文本段落式渐变</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#x27;io.github.wiwi289:GradualShowTextView:1.0.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/wiwi289/GradualShowTextView">仓库地址</a></p>
]]></content>
      <categories>
        <category>Android自定义系列</category>
      </categories>
      <tags>
        <tag>发布开源库</tag>
      </tags>
  </entry>
</search>
